// This file is generated by rust-protobuf 2.25.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cubic.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_1;

#[derive(PartialEq,Clone,Default)]
pub struct ListModelsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelsRequest {
    fn default() -> &'a ListModelsRequest {
        <ListModelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListModelsRequest {
    pub fn new() -> ListModelsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListModelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelsRequest {
        ListModelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelsRequest>(
                "ListModelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelsRequest {
        static instance: ::protobuf::rt::LazyV2<ListModelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelsRequest::new)
    }
}

impl ::protobuf::Clear for ListModelsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognizeRequest {
    // message fields
    pub config: ::protobuf::SingularPtrField<RecognitionConfig>,
    pub audio: ::protobuf::SingularPtrField<RecognitionAudio>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognizeRequest {
    fn default() -> &'a RecognizeRequest {
        <RecognizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RecognizeRequest {
    pub fn new() -> RecognizeRequest {
        ::std::default::Default::default()
    }

    // .cobaltspeech.cubic.RecognitionConfig config = 1;


    pub fn get_config(&self) -> &RecognitionConfig {
        self.config.as_ref().unwrap_or_else(|| <RecognitionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: RecognitionConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut RecognitionConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> RecognitionConfig {
        self.config.take().unwrap_or_else(|| RecognitionConfig::new())
    }

    // .cobaltspeech.cubic.RecognitionAudio audio = 2;


    pub fn get_audio(&self) -> &RecognitionAudio {
        self.audio.as_ref().unwrap_or_else(|| <RecognitionAudio as ::protobuf::Message>::default_instance())
    }
    pub fn clear_audio(&mut self) {
        self.audio.clear();
    }

    pub fn has_audio(&self) -> bool {
        self.audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio(&mut self, v: RecognitionAudio) {
        self.audio = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audio(&mut self) -> &mut RecognitionAudio {
        if self.audio.is_none() {
            self.audio.set_default();
        }
        self.audio.as_mut().unwrap()
    }

    // Take field
    pub fn take_audio(&mut self) -> RecognitionAudio {
        self.audio.take().unwrap_or_else(|| RecognitionAudio::new())
    }
}

impl ::protobuf::Message for RecognizeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.audio {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.audio)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.audio.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognizeRequest {
        RecognizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecognitionConfig>>(
                "config",
                |m: &RecognizeRequest| { &m.config },
                |m: &mut RecognizeRequest| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecognitionAudio>>(
                "audio",
                |m: &RecognizeRequest| { &m.audio },
                |m: &mut RecognizeRequest| { &mut m.audio },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognizeRequest>(
                "RecognizeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognizeRequest {
        static instance: ::protobuf::rt::LazyV2<RecognizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognizeRequest::new)
    }
}

impl ::protobuf::Clear for RecognizeRequest {
    fn clear(&mut self) {
        self.config.clear();
        self.audio.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamingRecognizeRequest {
    // message oneof groups
    pub request: ::std::option::Option<StreamingRecognizeRequest_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamingRecognizeRequest {
    fn default() -> &'a StreamingRecognizeRequest {
        <StreamingRecognizeRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StreamingRecognizeRequest_oneof_request {
    config(RecognitionConfig),
    audio(RecognitionAudio),
}

impl StreamingRecognizeRequest {
    pub fn new() -> StreamingRecognizeRequest {
        ::std::default::Default::default()
    }

    // .cobaltspeech.cubic.RecognitionConfig config = 1;


    pub fn get_config(&self) -> &RecognitionConfig {
        match self.request {
            ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(ref v)) => v,
            _ => <RecognitionConfig as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_config(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: RecognitionConfig) {
        self.request = ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut RecognitionConfig {
        if let ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(RecognitionConfig::new()));
        }
        match self.request {
            ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config(&mut self) -> RecognitionConfig {
        if self.has_config() {
            match self.request.take() {
                ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(v)) => v,
                _ => panic!(),
            }
        } else {
            RecognitionConfig::new()
        }
    }

    // .cobaltspeech.cubic.RecognitionAudio audio = 2;


    pub fn get_audio(&self) -> &RecognitionAudio {
        match self.request {
            ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(ref v)) => v,
            _ => <RecognitionAudio as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_audio(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_audio(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio(&mut self, v: RecognitionAudio) {
        self.request = ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio(&mut self) -> &mut RecognitionAudio {
        if let ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(RecognitionAudio::new()));
        }
        match self.request {
            ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio(&mut self) -> RecognitionAudio {
        if self.has_audio() {
            match self.request.take() {
                ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(v)) => v,
                _ => panic!(),
            }
        } else {
            RecognitionAudio::new()
        }
    }
}

impl ::protobuf::Message for StreamingRecognizeRequest {
    fn is_initialized(&self) -> bool {
        if let Some(StreamingRecognizeRequest_oneof_request::config(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StreamingRecognizeRequest_oneof_request::audio(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::config(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(StreamingRecognizeRequest_oneof_request::audio(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &StreamingRecognizeRequest_oneof_request::config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StreamingRecognizeRequest_oneof_request::audio(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &StreamingRecognizeRequest_oneof_request::config(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StreamingRecognizeRequest_oneof_request::audio(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamingRecognizeRequest {
        StreamingRecognizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RecognitionConfig>(
                "config",
                StreamingRecognizeRequest::has_config,
                StreamingRecognizeRequest::get_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RecognitionAudio>(
                "audio",
                StreamingRecognizeRequest::has_audio,
                StreamingRecognizeRequest::get_audio,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamingRecognizeRequest>(
                "StreamingRecognizeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamingRecognizeRequest {
        static instance: ::protobuf::rt::LazyV2<StreamingRecognizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamingRecognizeRequest::new)
    }
}

impl ::protobuf::Clear for StreamingRecognizeRequest {
    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamingRecognizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamingRecognizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompileContextRequest {
    // message fields
    pub model_id: ::std::string::String,
    pub token: ::std::string::String,
    pub phrases: ::protobuf::RepeatedField<ContextPhrase>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompileContextRequest {
    fn default() -> &'a CompileContextRequest {
        <CompileContextRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompileContextRequest {
    pub fn new() -> CompileContextRequest {
        ::std::default::Default::default()
    }

    // string model_id = 1;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // string token = 2;


    pub fn get_token(&self) -> &str {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.token, ::std::string::String::new())
    }

    // repeated .cobaltspeech.cubic.ContextPhrase phrases = 3;


    pub fn get_phrases(&self) -> &[ContextPhrase] {
        &self.phrases
    }
    pub fn clear_phrases(&mut self) {
        self.phrases.clear();
    }

    // Param is passed by value, moved
    pub fn set_phrases(&mut self, v: ::protobuf::RepeatedField<ContextPhrase>) {
        self.phrases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_phrases(&mut self) -> &mut ::protobuf::RepeatedField<ContextPhrase> {
        &mut self.phrases
    }

    // Take field
    pub fn take_phrases(&mut self) -> ::protobuf::RepeatedField<ContextPhrase> {
        ::std::mem::replace(&mut self.phrases, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CompileContextRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.phrases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.token)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.phrases)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.model_id);
        }
        if !self.token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.token);
        }
        for value in &self.phrases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.model_id.is_empty() {
            os.write_string(1, &self.model_id)?;
        }
        if !self.token.is_empty() {
            os.write_string(2, &self.token)?;
        }
        for v in &self.phrases {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompileContextRequest {
        CompileContextRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &CompileContextRequest| { &m.model_id },
                |m: &mut CompileContextRequest| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &CompileContextRequest| { &m.token },
                |m: &mut CompileContextRequest| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContextPhrase>>(
                "phrases",
                |m: &CompileContextRequest| { &m.phrases },
                |m: &mut CompileContextRequest| { &mut m.phrases },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompileContextRequest>(
                "CompileContextRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompileContextRequest {
        static instance: ::protobuf::rt::LazyV2<CompileContextRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompileContextRequest::new)
    }
}

impl ::protobuf::Clear for CompileContextRequest {
    fn clear(&mut self) {
        self.model_id.clear();
        self.token.clear();
        self.phrases.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompileContextRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompileContextRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionResponse {
    // message fields
    pub cubic: ::std::string::String,
    pub server: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionResponse {
    fn default() -> &'a VersionResponse {
        <VersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl VersionResponse {
    pub fn new() -> VersionResponse {
        ::std::default::Default::default()
    }

    // string cubic = 1;


    pub fn get_cubic(&self) -> &str {
        &self.cubic
    }
    pub fn clear_cubic(&mut self) {
        self.cubic.clear();
    }

    // Param is passed by value, moved
    pub fn set_cubic(&mut self, v: ::std::string::String) {
        self.cubic = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cubic(&mut self) -> &mut ::std::string::String {
        &mut self.cubic
    }

    // Take field
    pub fn take_cubic(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cubic, ::std::string::String::new())
    }

    // string server = 2;


    pub fn get_server(&self) -> &str {
        &self.server
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: ::std::string::String) {
        self.server = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut ::std::string::String {
        &mut self.server
    }

    // Take field
    pub fn take_server(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VersionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cubic)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cubic.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cubic);
        }
        if !self.server.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.server);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cubic.is_empty() {
            os.write_string(1, &self.cubic)?;
        }
        if !self.server.is_empty() {
            os.write_string(2, &self.server)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionResponse {
        VersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cubic",
                |m: &VersionResponse| { &m.cubic },
                |m: &mut VersionResponse| { &mut m.cubic },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server",
                |m: &VersionResponse| { &m.server },
                |m: &mut VersionResponse| { &mut m.server },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VersionResponse>(
                "VersionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VersionResponse {
        static instance: ::protobuf::rt::LazyV2<VersionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VersionResponse::new)
    }
}

impl ::protobuf::Clear for VersionResponse {
    fn clear(&mut self) {
        self.cubic.clear();
        self.server.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListModelsResponse {
    // message fields
    pub models: ::protobuf::RepeatedField<Model>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListModelsResponse {
    fn default() -> &'a ListModelsResponse {
        <ListModelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListModelsResponse {
    pub fn new() -> ListModelsResponse {
        ::std::default::Default::default()
    }

    // repeated .cobaltspeech.cubic.Model models = 1;


    pub fn get_models(&self) -> &[Model] {
        &self.models
    }
    pub fn clear_models(&mut self) {
        self.models.clear();
    }

    // Param is passed by value, moved
    pub fn set_models(&mut self, v: ::protobuf::RepeatedField<Model>) {
        self.models = v;
    }

    // Mutable pointer to the field.
    pub fn mut_models(&mut self) -> &mut ::protobuf::RepeatedField<Model> {
        &mut self.models
    }

    // Take field
    pub fn take_models(&mut self) -> ::protobuf::RepeatedField<Model> {
        ::std::mem::replace(&mut self.models, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListModelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.models {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.models)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.models {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListModelsResponse {
        ListModelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Model>>(
                "models",
                |m: &ListModelsResponse| { &m.models },
                |m: &mut ListModelsResponse| { &mut m.models },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListModelsResponse>(
                "ListModelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListModelsResponse {
        static instance: ::protobuf::rt::LazyV2<ListModelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListModelsResponse::new)
    }
}

impl ::protobuf::Clear for ListModelsResponse {
    fn clear(&mut self) {
        self.models.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListModelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListModelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionResponse {
    // message fields
    pub results: ::protobuf::RepeatedField<RecognitionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionResponse {
    fn default() -> &'a RecognitionResponse {
        <RecognitionResponse as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionResponse {
    pub fn new() -> RecognitionResponse {
        ::std::default::Default::default()
    }

    // repeated .cobaltspeech.cubic.RecognitionResult results = 1;


    pub fn get_results(&self) -> &[RecognitionResult] {
        &self.results
    }
    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<RecognitionResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<RecognitionResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<RecognitionResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RecognitionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionResponse {
        RecognitionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecognitionResult>>(
                "results",
                |m: &RecognitionResponse| { &m.results },
                |m: &mut RecognitionResponse| { &mut m.results },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionResponse>(
                "RecognitionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionResponse {
        static instance: ::protobuf::rt::LazyV2<RecognitionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionResponse::new)
    }
}

impl ::protobuf::Clear for RecognitionResponse {
    fn clear(&mut self) {
        self.results.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompileContextResponse {
    // message fields
    pub context: ::protobuf::SingularPtrField<CompiledContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompileContextResponse {
    fn default() -> &'a CompileContextResponse {
        <CompileContextResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompileContextResponse {
    pub fn new() -> CompileContextResponse {
        ::std::default::Default::default()
    }

    // .cobaltspeech.cubic.CompiledContext context = 1;


    pub fn get_context(&self) -> &CompiledContext {
        self.context.as_ref().unwrap_or_else(|| <CompiledContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: CompiledContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut CompiledContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> CompiledContext {
        self.context.take().unwrap_or_else(|| CompiledContext::new())
    }
}

impl ::protobuf::Message for CompileContextResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompileContextResponse {
        CompileContextResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompiledContext>>(
                "context",
                |m: &CompileContextResponse| { &m.context },
                |m: &mut CompileContextResponse| { &mut m.context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompileContextResponse>(
                "CompileContextResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompileContextResponse {
        static instance: ::protobuf::rt::LazyV2<CompileContextResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompileContextResponse::new)
    }
}

impl ::protobuf::Clear for CompileContextResponse {
    fn clear(&mut self) {
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompileContextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompileContextResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionConfig {
    // message fields
    pub model_id: ::std::string::String,
    pub audio_encoding: RecognitionConfig_Encoding,
    pub idle_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub enable_word_time_offsets: bool,
    pub enable_word_confidence: bool,
    pub enable_raw_transcript: bool,
    pub enable_confusion_network: bool,
    pub audio_channels: ::std::vec::Vec<u32>,
    pub metadata: ::protobuf::SingularPtrField<RecognitionMetadata>,
    pub context: ::protobuf::SingularPtrField<RecognitionContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionConfig {
    fn default() -> &'a RecognitionConfig {
        <RecognitionConfig as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionConfig {
    pub fn new() -> RecognitionConfig {
        ::std::default::Default::default()
    }

    // string model_id = 1;


    pub fn get_model_id(&self) -> &str {
        &self.model_id
    }
    pub fn clear_model_id(&mut self) {
        self.model_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_model_id(&mut self, v: ::std::string::String) {
        self.model_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model_id(&mut self) -> &mut ::std::string::String {
        &mut self.model_id
    }

    // Take field
    pub fn take_model_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model_id, ::std::string::String::new())
    }

    // .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;


    pub fn get_audio_encoding(&self) -> RecognitionConfig_Encoding {
        self.audio_encoding
    }
    pub fn clear_audio_encoding(&mut self) {
        self.audio_encoding = RecognitionConfig_Encoding::RAW_LINEAR16;
    }

    // Param is passed by value, moved
    pub fn set_audio_encoding(&mut self, v: RecognitionConfig_Encoding) {
        self.audio_encoding = v;
    }

    // .google.protobuf.Duration idle_timeout = 3;


    pub fn get_idle_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.idle_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_idle_timeout(&mut self) {
        self.idle_timeout.clear();
    }

    pub fn has_idle_timeout(&self) -> bool {
        self.idle_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.idle_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_idle_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.idle_timeout.is_none() {
            self.idle_timeout.set_default();
        }
        self.idle_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_idle_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.idle_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // bool enable_word_time_offsets = 4;


    pub fn get_enable_word_time_offsets(&self) -> bool {
        self.enable_word_time_offsets
    }
    pub fn clear_enable_word_time_offsets(&mut self) {
        self.enable_word_time_offsets = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_word_time_offsets(&mut self, v: bool) {
        self.enable_word_time_offsets = v;
    }

    // bool enable_word_confidence = 5;


    pub fn get_enable_word_confidence(&self) -> bool {
        self.enable_word_confidence
    }
    pub fn clear_enable_word_confidence(&mut self) {
        self.enable_word_confidence = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_word_confidence(&mut self, v: bool) {
        self.enable_word_confidence = v;
    }

    // bool enable_raw_transcript = 6;


    pub fn get_enable_raw_transcript(&self) -> bool {
        self.enable_raw_transcript
    }
    pub fn clear_enable_raw_transcript(&mut self) {
        self.enable_raw_transcript = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_raw_transcript(&mut self, v: bool) {
        self.enable_raw_transcript = v;
    }

    // bool enable_confusion_network = 7;


    pub fn get_enable_confusion_network(&self) -> bool {
        self.enable_confusion_network
    }
    pub fn clear_enable_confusion_network(&mut self) {
        self.enable_confusion_network = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_confusion_network(&mut self, v: bool) {
        self.enable_confusion_network = v;
    }

    // repeated uint32 audio_channels = 8;


    pub fn get_audio_channels(&self) -> &[u32] {
        &self.audio_channels
    }
    pub fn clear_audio_channels(&mut self) {
        self.audio_channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_audio_channels(&mut self, v: ::std::vec::Vec<u32>) {
        self.audio_channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audio_channels(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.audio_channels
    }

    // Take field
    pub fn take_audio_channels(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.audio_channels, ::std::vec::Vec::new())
    }

    // .cobaltspeech.cubic.RecognitionMetadata metadata = 9;


    pub fn get_metadata(&self) -> &RecognitionMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <RecognitionMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: RecognitionMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut RecognitionMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> RecognitionMetadata {
        self.metadata.take().unwrap_or_else(|| RecognitionMetadata::new())
    }

    // .cobaltspeech.cubic.RecognitionContext context = 10;


    pub fn get_context(&self) -> &RecognitionContext {
        self.context.as_ref().unwrap_or_else(|| <RecognitionContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: RecognitionContext) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut RecognitionContext {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> RecognitionContext {
        self.context.take().unwrap_or_else(|| RecognitionContext::new())
    }
}

impl ::protobuf::Message for RecognitionConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.idle_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.audio_encoding, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.idle_timeout)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_word_time_offsets = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_word_confidence = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_raw_transcript = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_confusion_network = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.audio_channels)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.model_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.model_id);
        }
        if self.audio_encoding != RecognitionConfig_Encoding::RAW_LINEAR16 {
            my_size += ::protobuf::rt::enum_size(2, self.audio_encoding);
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enable_word_time_offsets != false {
            my_size += 2;
        }
        if self.enable_word_confidence != false {
            my_size += 2;
        }
        if self.enable_raw_transcript != false {
            my_size += 2;
        }
        if self.enable_confusion_network != false {
            my_size += 2;
        }
        for value in &self.audio_channels {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.model_id.is_empty() {
            os.write_string(1, &self.model_id)?;
        }
        if self.audio_encoding != RecognitionConfig_Encoding::RAW_LINEAR16 {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.audio_encoding))?;
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enable_word_time_offsets != false {
            os.write_bool(4, self.enable_word_time_offsets)?;
        }
        if self.enable_word_confidence != false {
            os.write_bool(5, self.enable_word_confidence)?;
        }
        if self.enable_raw_transcript != false {
            os.write_bool(6, self.enable_raw_transcript)?;
        }
        if self.enable_confusion_network != false {
            os.write_bool(7, self.enable_confusion_network)?;
        }
        for v in &self.audio_channels {
            os.write_uint32(8, *v)?;
        };
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionConfig {
        RecognitionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model_id",
                |m: &RecognitionConfig| { &m.model_id },
                |m: &mut RecognitionConfig| { &mut m.model_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RecognitionConfig_Encoding>>(
                "audio_encoding",
                |m: &RecognitionConfig| { &m.audio_encoding },
                |m: &mut RecognitionConfig| { &mut m.audio_encoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "idle_timeout",
                |m: &RecognitionConfig| { &m.idle_timeout },
                |m: &mut RecognitionConfig| { &mut m.idle_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_word_time_offsets",
                |m: &RecognitionConfig| { &m.enable_word_time_offsets },
                |m: &mut RecognitionConfig| { &mut m.enable_word_time_offsets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_word_confidence",
                |m: &RecognitionConfig| { &m.enable_word_confidence },
                |m: &mut RecognitionConfig| { &mut m.enable_word_confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_raw_transcript",
                |m: &RecognitionConfig| { &m.enable_raw_transcript },
                |m: &mut RecognitionConfig| { &mut m.enable_raw_transcript },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_confusion_network",
                |m: &RecognitionConfig| { &m.enable_confusion_network },
                |m: &mut RecognitionConfig| { &mut m.enable_confusion_network },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "audio_channels",
                |m: &RecognitionConfig| { &m.audio_channels },
                |m: &mut RecognitionConfig| { &mut m.audio_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecognitionMetadata>>(
                "metadata",
                |m: &RecognitionConfig| { &m.metadata },
                |m: &mut RecognitionConfig| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecognitionContext>>(
                "context",
                |m: &RecognitionConfig| { &m.context },
                |m: &mut RecognitionConfig| { &mut m.context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionConfig>(
                "RecognitionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionConfig {
        static instance: ::protobuf::rt::LazyV2<RecognitionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionConfig::new)
    }
}

impl ::protobuf::Clear for RecognitionConfig {
    fn clear(&mut self) {
        self.model_id.clear();
        self.audio_encoding = RecognitionConfig_Encoding::RAW_LINEAR16;
        self.idle_timeout.clear();
        self.enable_word_time_offsets = false;
        self.enable_word_confidence = false;
        self.enable_raw_transcript = false;
        self.enable_confusion_network = false;
        self.audio_channels.clear();
        self.metadata.clear();
        self.context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RecognitionConfig_Encoding {
    RAW_LINEAR16 = 0,
    WAV = 1,
    MP3 = 2,
    FLAC = 3,
    VOX8000 = 4,
    ULAW8000 = 5,
    ALAW8000 = 6,
    OPUS = 7,
}

impl ::protobuf::ProtobufEnum for RecognitionConfig_Encoding {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RecognitionConfig_Encoding> {
        match value {
            0 => ::std::option::Option::Some(RecognitionConfig_Encoding::RAW_LINEAR16),
            1 => ::std::option::Option::Some(RecognitionConfig_Encoding::WAV),
            2 => ::std::option::Option::Some(RecognitionConfig_Encoding::MP3),
            3 => ::std::option::Option::Some(RecognitionConfig_Encoding::FLAC),
            4 => ::std::option::Option::Some(RecognitionConfig_Encoding::VOX8000),
            5 => ::std::option::Option::Some(RecognitionConfig_Encoding::ULAW8000),
            6 => ::std::option::Option::Some(RecognitionConfig_Encoding::ALAW8000),
            7 => ::std::option::Option::Some(RecognitionConfig_Encoding::OPUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RecognitionConfig_Encoding] = &[
            RecognitionConfig_Encoding::RAW_LINEAR16,
            RecognitionConfig_Encoding::WAV,
            RecognitionConfig_Encoding::MP3,
            RecognitionConfig_Encoding::FLAC,
            RecognitionConfig_Encoding::VOX8000,
            RecognitionConfig_Encoding::ULAW8000,
            RecognitionConfig_Encoding::ALAW8000,
            RecognitionConfig_Encoding::OPUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RecognitionConfig_Encoding>("RecognitionConfig.Encoding", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RecognitionConfig_Encoding {
}

impl ::std::default::Default for RecognitionConfig_Encoding {
    fn default() -> Self {
        RecognitionConfig_Encoding::RAW_LINEAR16
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionConfig_Encoding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionMetadata {
    // message fields
    pub custom_metadata: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionMetadata {
    fn default() -> &'a RecognitionMetadata {
        <RecognitionMetadata as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionMetadata {
    pub fn new() -> RecognitionMetadata {
        ::std::default::Default::default()
    }

    // string custom_metadata = 1;


    pub fn get_custom_metadata(&self) -> &str {
        &self.custom_metadata
    }
    pub fn clear_custom_metadata(&mut self) {
        self.custom_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_metadata(&mut self, v: ::std::string::String) {
        self.custom_metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.custom_metadata
    }

    // Take field
    pub fn take_custom_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_metadata, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RecognitionMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.custom_metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.custom_metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.custom_metadata.is_empty() {
            os.write_string(1, &self.custom_metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionMetadata {
        RecognitionMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_metadata",
                |m: &RecognitionMetadata| { &m.custom_metadata },
                |m: &mut RecognitionMetadata| { &mut m.custom_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionMetadata>(
                "RecognitionMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionMetadata {
        static instance: ::protobuf::rt::LazyV2<RecognitionMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionMetadata::new)
    }
}

impl ::protobuf::Clear for RecognitionMetadata {
    fn clear(&mut self) {
        self.custom_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionContext {
    // message fields
    pub compiled: ::protobuf::RepeatedField<CompiledContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionContext {
    fn default() -> &'a RecognitionContext {
        <RecognitionContext as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionContext {
    pub fn new() -> RecognitionContext {
        ::std::default::Default::default()
    }

    // repeated .cobaltspeech.cubic.CompiledContext compiled = 1;


    pub fn get_compiled(&self) -> &[CompiledContext] {
        &self.compiled
    }
    pub fn clear_compiled(&mut self) {
        self.compiled.clear();
    }

    // Param is passed by value, moved
    pub fn set_compiled(&mut self, v: ::protobuf::RepeatedField<CompiledContext>) {
        self.compiled = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compiled(&mut self) -> &mut ::protobuf::RepeatedField<CompiledContext> {
        &mut self.compiled
    }

    // Take field
    pub fn take_compiled(&mut self) -> ::protobuf::RepeatedField<CompiledContext> {
        ::std::mem::replace(&mut self.compiled, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RecognitionContext {
    fn is_initialized(&self) -> bool {
        for v in &self.compiled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.compiled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.compiled {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.compiled {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionContext {
        RecognitionContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CompiledContext>>(
                "compiled",
                |m: &RecognitionContext| { &m.compiled },
                |m: &mut RecognitionContext| { &mut m.compiled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionContext>(
                "RecognitionContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionContext {
        static instance: ::protobuf::rt::LazyV2<RecognitionContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionContext::new)
    }
}

impl ::protobuf::Clear for RecognitionContext {
    fn clear(&mut self) {
        self.compiled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompiledContext {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompiledContext {
    fn default() -> &'a CompiledContext {
        <CompiledContext as ::protobuf::Message>::default_instance()
    }
}

impl CompiledContext {
    pub fn new() -> CompiledContext {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CompiledContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompiledContext {
        CompiledContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CompiledContext| { &m.data },
                |m: &mut CompiledContext| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompiledContext>(
                "CompiledContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompiledContext {
        static instance: ::protobuf::rt::LazyV2<CompiledContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompiledContext::new)
    }
}

impl ::protobuf::Clear for CompiledContext {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompiledContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompiledContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContextPhrase {
    // message fields
    pub text: ::std::string::String,
    pub boost: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContextPhrase {
    fn default() -> &'a ContextPhrase {
        <ContextPhrase as ::protobuf::Message>::default_instance()
    }
}

impl ContextPhrase {
    pub fn new() -> ContextPhrase {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // float boost = 2;


    pub fn get_boost(&self) -> f32 {
        self.boost
    }
    pub fn clear_boost(&mut self) {
        self.boost = 0.;
    }

    // Param is passed by value, moved
    pub fn set_boost(&mut self, v: f32) {
        self.boost = v;
    }
}

impl ::protobuf::Message for ContextPhrase {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.boost = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.text);
        }
        if self.boost != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.text.is_empty() {
            os.write_string(1, &self.text)?;
        }
        if self.boost != 0. {
            os.write_float(2, self.boost)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContextPhrase {
        ContextPhrase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &ContextPhrase| { &m.text },
                |m: &mut ContextPhrase| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "boost",
                |m: &ContextPhrase| { &m.boost },
                |m: &mut ContextPhrase| { &mut m.boost },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContextPhrase>(
                "ContextPhrase",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContextPhrase {
        static instance: ::protobuf::rt::LazyV2<ContextPhrase> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContextPhrase::new)
    }
}

impl ::protobuf::Clear for ContextPhrase {
    fn clear(&mut self) {
        self.text.clear();
        self.boost = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContextPhrase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextPhrase {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionAudio {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionAudio {
    fn default() -> &'a RecognitionAudio {
        <RecognitionAudio as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionAudio {
    pub fn new() -> RecognitionAudio {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RecognitionAudio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionAudio {
        RecognitionAudio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &RecognitionAudio| { &m.data },
                |m: &mut RecognitionAudio| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionAudio>(
                "RecognitionAudio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionAudio {
        static instance: ::protobuf::rt::LazyV2<RecognitionAudio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionAudio::new)
    }
}

impl ::protobuf::Clear for RecognitionAudio {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionAudio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Model {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub attributes: ::protobuf::SingularPtrField<ModelAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Model {
    fn default() -> &'a Model {
        <Model as ::protobuf::Message>::default_instance()
    }
}

impl Model {
    pub fn new() -> Model {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .cobaltspeech.cubic.ModelAttributes attributes = 3;


    pub fn get_attributes(&self) -> &ModelAttributes {
        self.attributes.as_ref().unwrap_or_else(|| <ModelAttributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ModelAttributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut ModelAttributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> ModelAttributes {
        self.attributes.take().unwrap_or_else(|| ModelAttributes::new())
    }
}

impl ::protobuf::Message for Model {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Model {
        Model::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Model| { &m.id },
                |m: &mut Model| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Model| { &m.name },
                |m: &mut Model| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModelAttributes>>(
                "attributes",
                |m: &Model| { &m.attributes },
                |m: &mut Model| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Model>(
                "Model",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Model {
        static instance: ::protobuf::rt::LazyV2<Model> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Model::new)
    }
}

impl ::protobuf::Clear for Model {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Model {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Model {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModelAttributes {
    // message fields
    pub sample_rate: u32,
    pub context_info: ::protobuf::SingularPtrField<ContextInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModelAttributes {
    fn default() -> &'a ModelAttributes {
        <ModelAttributes as ::protobuf::Message>::default_instance()
    }
}

impl ModelAttributes {
    pub fn new() -> ModelAttributes {
        ::std::default::Default::default()
    }

    // uint32 sample_rate = 1;


    pub fn get_sample_rate(&self) -> u32 {
        self.sample_rate
    }
    pub fn clear_sample_rate(&mut self) {
        self.sample_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_sample_rate(&mut self, v: u32) {
        self.sample_rate = v;
    }

    // .cobaltspeech.cubic.ContextInfo context_info = 2;


    pub fn get_context_info(&self) -> &ContextInfo {
        self.context_info.as_ref().unwrap_or_else(|| <ContextInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_context_info(&mut self) {
        self.context_info.clear();
    }

    pub fn has_context_info(&self) -> bool {
        self.context_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_info(&mut self, v: ContextInfo) {
        self.context_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context_info(&mut self) -> &mut ContextInfo {
        if self.context_info.is_none() {
            self.context_info.set_default();
        }
        self.context_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_context_info(&mut self) -> ContextInfo {
        self.context_info.take().unwrap_or_else(|| ContextInfo::new())
    }
}

impl ::protobuf::Message for ModelAttributes {
    fn is_initialized(&self) -> bool {
        for v in &self.context_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sample_rate = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sample_rate != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sample_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.context_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sample_rate != 0 {
            os.write_uint32(1, self.sample_rate)?;
        }
        if let Some(ref v) = self.context_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModelAttributes {
        ModelAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "sample_rate",
                |m: &ModelAttributes| { &m.sample_rate },
                |m: &mut ModelAttributes| { &mut m.sample_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContextInfo>>(
                "context_info",
                |m: &ModelAttributes| { &m.context_info },
                |m: &mut ModelAttributes| { &mut m.context_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModelAttributes>(
                "ModelAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ModelAttributes {
        static instance: ::protobuf::rt::LazyV2<ModelAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ModelAttributes::new)
    }
}

impl ::protobuf::Clear for ModelAttributes {
    fn clear(&mut self) {
        self.sample_rate = 0;
        self.context_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModelAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContextInfo {
    // message fields
    pub supports_context: bool,
    pub allowed_context_tokens: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContextInfo {
    fn default() -> &'a ContextInfo {
        <ContextInfo as ::protobuf::Message>::default_instance()
    }
}

impl ContextInfo {
    pub fn new() -> ContextInfo {
        ::std::default::Default::default()
    }

    // bool supports_context = 1;


    pub fn get_supports_context(&self) -> bool {
        self.supports_context
    }
    pub fn clear_supports_context(&mut self) {
        self.supports_context = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_context(&mut self, v: bool) {
        self.supports_context = v;
    }

    // repeated string allowed_context_tokens = 2;


    pub fn get_allowed_context_tokens(&self) -> &[::std::string::String] {
        &self.allowed_context_tokens
    }
    pub fn clear_allowed_context_tokens(&mut self) {
        self.allowed_context_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_context_tokens(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_context_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_context_tokens(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_context_tokens
    }

    // Take field
    pub fn take_allowed_context_tokens(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_context_tokens, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContextInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_context = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_context_tokens)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.supports_context != false {
            my_size += 2;
        }
        for value in &self.allowed_context_tokens {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.supports_context != false {
            os.write_bool(1, self.supports_context)?;
        }
        for v in &self.allowed_context_tokens {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContextInfo {
        ContextInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_context",
                |m: &ContextInfo| { &m.supports_context },
                |m: &mut ContextInfo| { &mut m.supports_context },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allowed_context_tokens",
                |m: &ContextInfo| { &m.allowed_context_tokens },
                |m: &mut ContextInfo| { &mut m.allowed_context_tokens },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContextInfo>(
                "ContextInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContextInfo {
        static instance: ::protobuf::rt::LazyV2<ContextInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContextInfo::new)
    }
}

impl ::protobuf::Clear for ContextInfo {
    fn clear(&mut self) {
        self.supports_context = false;
        self.allowed_context_tokens.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContextInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContextInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionResult {
    // message fields
    pub alternatives: ::protobuf::RepeatedField<RecognitionAlternative>,
    pub is_partial: bool,
    pub cnet: ::protobuf::SingularPtrField<RecognitionConfusionNetwork>,
    pub audio_channel: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionResult {
    fn default() -> &'a RecognitionResult {
        <RecognitionResult as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionResult {
    pub fn new() -> RecognitionResult {
        ::std::default::Default::default()
    }

    // repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;


    pub fn get_alternatives(&self) -> &[RecognitionAlternative] {
        &self.alternatives
    }
    pub fn clear_alternatives(&mut self) {
        self.alternatives.clear();
    }

    // Param is passed by value, moved
    pub fn set_alternatives(&mut self, v: ::protobuf::RepeatedField<RecognitionAlternative>) {
        self.alternatives = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alternatives(&mut self) -> &mut ::protobuf::RepeatedField<RecognitionAlternative> {
        &mut self.alternatives
    }

    // Take field
    pub fn take_alternatives(&mut self) -> ::protobuf::RepeatedField<RecognitionAlternative> {
        ::std::mem::replace(&mut self.alternatives, ::protobuf::RepeatedField::new())
    }

    // bool is_partial = 2;


    pub fn get_is_partial(&self) -> bool {
        self.is_partial
    }
    pub fn clear_is_partial(&mut self) {
        self.is_partial = false;
    }

    // Param is passed by value, moved
    pub fn set_is_partial(&mut self, v: bool) {
        self.is_partial = v;
    }

    // .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;


    pub fn get_cnet(&self) -> &RecognitionConfusionNetwork {
        self.cnet.as_ref().unwrap_or_else(|| <RecognitionConfusionNetwork as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cnet(&mut self) {
        self.cnet.clear();
    }

    pub fn has_cnet(&self) -> bool {
        self.cnet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cnet(&mut self, v: RecognitionConfusionNetwork) {
        self.cnet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cnet(&mut self) -> &mut RecognitionConfusionNetwork {
        if self.cnet.is_none() {
            self.cnet.set_default();
        }
        self.cnet.as_mut().unwrap()
    }

    // Take field
    pub fn take_cnet(&mut self) -> RecognitionConfusionNetwork {
        self.cnet.take().unwrap_or_else(|| RecognitionConfusionNetwork::new())
    }

    // uint32 audio_channel = 4;


    pub fn get_audio_channel(&self) -> u32 {
        self.audio_channel
    }
    pub fn clear_audio_channel(&mut self) {
        self.audio_channel = 0;
    }

    // Param is passed by value, moved
    pub fn set_audio_channel(&mut self, v: u32) {
        self.audio_channel = v;
    }
}

impl ::protobuf::Message for RecognitionResult {
    fn is_initialized(&self) -> bool {
        for v in &self.alternatives {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cnet {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.alternatives)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_partial = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cnet)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.audio_channel = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.alternatives {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_partial != false {
            my_size += 2;
        }
        if let Some(ref v) = self.cnet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.audio_channel != 0 {
            my_size += ::protobuf::rt::value_size(4, self.audio_channel, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.alternatives {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_partial != false {
            os.write_bool(2, self.is_partial)?;
        }
        if let Some(ref v) = self.cnet.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.audio_channel != 0 {
            os.write_uint32(4, self.audio_channel)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionResult {
        RecognitionResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecognitionAlternative>>(
                "alternatives",
                |m: &RecognitionResult| { &m.alternatives },
                |m: &mut RecognitionResult| { &mut m.alternatives },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_partial",
                |m: &RecognitionResult| { &m.is_partial },
                |m: &mut RecognitionResult| { &mut m.is_partial },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RecognitionConfusionNetwork>>(
                "cnet",
                |m: &RecognitionResult| { &m.cnet },
                |m: &mut RecognitionResult| { &mut m.cnet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "audio_channel",
                |m: &RecognitionResult| { &m.audio_channel },
                |m: &mut RecognitionResult| { &mut m.audio_channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionResult>(
                "RecognitionResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionResult {
        static instance: ::protobuf::rt::LazyV2<RecognitionResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionResult::new)
    }
}

impl ::protobuf::Clear for RecognitionResult {
    fn clear(&mut self) {
        self.alternatives.clear();
        self.is_partial = false;
        self.cnet.clear();
        self.audio_channel = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionAlternative {
    // message fields
    pub transcript: ::std::string::String,
    pub raw_transcript: ::std::string::String,
    pub confidence: f64,
    pub words: ::protobuf::RepeatedField<WordInfo>,
    pub raw_words: ::protobuf::RepeatedField<WordInfo>,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionAlternative {
    fn default() -> &'a RecognitionAlternative {
        <RecognitionAlternative as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionAlternative {
    pub fn new() -> RecognitionAlternative {
        ::std::default::Default::default()
    }

    // string transcript = 1;


    pub fn get_transcript(&self) -> &str {
        &self.transcript
    }
    pub fn clear_transcript(&mut self) {
        self.transcript.clear();
    }

    // Param is passed by value, moved
    pub fn set_transcript(&mut self, v: ::std::string::String) {
        self.transcript = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transcript(&mut self) -> &mut ::std::string::String {
        &mut self.transcript
    }

    // Take field
    pub fn take_transcript(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.transcript, ::std::string::String::new())
    }

    // string raw_transcript = 6;


    pub fn get_raw_transcript(&self) -> &str {
        &self.raw_transcript
    }
    pub fn clear_raw_transcript(&mut self) {
        self.raw_transcript.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_transcript(&mut self, v: ::std::string::String) {
        self.raw_transcript = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_transcript(&mut self) -> &mut ::std::string::String {
        &mut self.raw_transcript
    }

    // Take field
    pub fn take_raw_transcript(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.raw_transcript, ::std::string::String::new())
    }

    // double confidence = 2;


    pub fn get_confidence(&self) -> f64 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f64) {
        self.confidence = v;
    }

    // repeated .cobaltspeech.cubic.WordInfo words = 3;


    pub fn get_words(&self) -> &[WordInfo] {
        &self.words
    }
    pub fn clear_words(&mut self) {
        self.words.clear();
    }

    // Param is passed by value, moved
    pub fn set_words(&mut self, v: ::protobuf::RepeatedField<WordInfo>) {
        self.words = v;
    }

    // Mutable pointer to the field.
    pub fn mut_words(&mut self) -> &mut ::protobuf::RepeatedField<WordInfo> {
        &mut self.words
    }

    // Take field
    pub fn take_words(&mut self) -> ::protobuf::RepeatedField<WordInfo> {
        ::std::mem::replace(&mut self.words, ::protobuf::RepeatedField::new())
    }

    // repeated .cobaltspeech.cubic.WordInfo raw_words = 7;


    pub fn get_raw_words(&self) -> &[WordInfo] {
        &self.raw_words
    }
    pub fn clear_raw_words(&mut self) {
        self.raw_words.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_words(&mut self, v: ::protobuf::RepeatedField<WordInfo>) {
        self.raw_words = v;
    }

    // Mutable pointer to the field.
    pub fn mut_raw_words(&mut self) -> &mut ::protobuf::RepeatedField<WordInfo> {
        &mut self.raw_words
    }

    // Take field
    pub fn take_raw_words(&mut self) -> ::protobuf::RepeatedField<WordInfo> {
        ::std::mem::replace(&mut self.raw_words, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Duration start_time = 4;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Duration {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Duration {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration duration = 5;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RecognitionAlternative {
    fn is_initialized(&self) -> bool {
        for v in &self.words {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.raw_words {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.transcript)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.raw_transcript)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.confidence = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.words)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.raw_words)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transcript.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.transcript);
        }
        if !self.raw_transcript.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.raw_transcript);
        }
        if self.confidence != 0. {
            my_size += 9;
        }
        for value in &self.words {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.raw_words {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.transcript.is_empty() {
            os.write_string(1, &self.transcript)?;
        }
        if !self.raw_transcript.is_empty() {
            os.write_string(6, &self.raw_transcript)?;
        }
        if self.confidence != 0. {
            os.write_double(2, self.confidence)?;
        }
        for v in &self.words {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.raw_words {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionAlternative {
        RecognitionAlternative::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transcript",
                |m: &RecognitionAlternative| { &m.transcript },
                |m: &mut RecognitionAlternative| { &mut m.transcript },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "raw_transcript",
                |m: &RecognitionAlternative| { &m.raw_transcript },
                |m: &mut RecognitionAlternative| { &mut m.raw_transcript },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "confidence",
                |m: &RecognitionAlternative| { &m.confidence },
                |m: &mut RecognitionAlternative| { &mut m.confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WordInfo>>(
                "words",
                |m: &RecognitionAlternative| { &m.words },
                |m: &mut RecognitionAlternative| { &mut m.words },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WordInfo>>(
                "raw_words",
                |m: &RecognitionAlternative| { &m.raw_words },
                |m: &mut RecognitionAlternative| { &mut m.raw_words },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "start_time",
                |m: &RecognitionAlternative| { &m.start_time },
                |m: &mut RecognitionAlternative| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &RecognitionAlternative| { &m.duration },
                |m: &mut RecognitionAlternative| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionAlternative>(
                "RecognitionAlternative",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionAlternative {
        static instance: ::protobuf::rt::LazyV2<RecognitionAlternative> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionAlternative::new)
    }
}

impl ::protobuf::Clear for RecognitionAlternative {
    fn clear(&mut self) {
        self.transcript.clear();
        self.raw_transcript.clear();
        self.confidence = 0.;
        self.words.clear();
        self.raw_words.clear();
        self.start_time.clear();
        self.duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionAlternative {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionAlternative {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WordInfo {
    // message fields
    pub word: ::std::string::String,
    pub confidence: f64,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WordInfo {
    fn default() -> &'a WordInfo {
        <WordInfo as ::protobuf::Message>::default_instance()
    }
}

impl WordInfo {
    pub fn new() -> WordInfo {
        ::std::default::Default::default()
    }

    // string word = 1;


    pub fn get_word(&self) -> &str {
        &self.word
    }
    pub fn clear_word(&mut self) {
        self.word.clear();
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        &mut self.word
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.word, ::std::string::String::new())
    }

    // double confidence = 2;


    pub fn get_confidence(&self) -> f64 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f64) {
        self.confidence = v;
    }

    // .google.protobuf.Duration start_time = 3;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Duration {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Duration {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration duration = 4;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for WordInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.word)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.confidence = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.word.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.word);
        }
        if self.confidence != 0. {
            my_size += 9;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.word.is_empty() {
            os.write_string(1, &self.word)?;
        }
        if self.confidence != 0. {
            os.write_double(2, self.confidence)?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WordInfo {
        WordInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "word",
                |m: &WordInfo| { &m.word },
                |m: &mut WordInfo| { &mut m.word },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "confidence",
                |m: &WordInfo| { &m.confidence },
                |m: &mut WordInfo| { &mut m.confidence },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "start_time",
                |m: &WordInfo| { &m.start_time },
                |m: &mut WordInfo| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &WordInfo| { &m.duration },
                |m: &mut WordInfo| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WordInfo>(
                "WordInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WordInfo {
        static instance: ::protobuf::rt::LazyV2<WordInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WordInfo::new)
    }
}

impl ::protobuf::Clear for WordInfo {
    fn clear(&mut self) {
        self.word.clear();
        self.confidence = 0.;
        self.start_time.clear();
        self.duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WordInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WordInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecognitionConfusionNetwork {
    // message fields
    pub links: ::protobuf::RepeatedField<ConfusionNetworkLink>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecognitionConfusionNetwork {
    fn default() -> &'a RecognitionConfusionNetwork {
        <RecognitionConfusionNetwork as ::protobuf::Message>::default_instance()
    }
}

impl RecognitionConfusionNetwork {
    pub fn new() -> RecognitionConfusionNetwork {
        ::std::default::Default::default()
    }

    // repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;


    pub fn get_links(&self) -> &[ConfusionNetworkLink] {
        &self.links
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::protobuf::RepeatedField<ConfusionNetworkLink>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::protobuf::RepeatedField<ConfusionNetworkLink> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::protobuf::RepeatedField<ConfusionNetworkLink> {
        ::std::mem::replace(&mut self.links, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RecognitionConfusionNetwork {
    fn is_initialized(&self) -> bool {
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.links)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.links {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecognitionConfusionNetwork {
        RecognitionConfusionNetwork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfusionNetworkLink>>(
                "links",
                |m: &RecognitionConfusionNetwork| { &m.links },
                |m: &mut RecognitionConfusionNetwork| { &mut m.links },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecognitionConfusionNetwork>(
                "RecognitionConfusionNetwork",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecognitionConfusionNetwork {
        static instance: ::protobuf::rt::LazyV2<RecognitionConfusionNetwork> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecognitionConfusionNetwork::new)
    }
}

impl ::protobuf::Clear for RecognitionConfusionNetwork {
    fn clear(&mut self) {
        self.links.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecognitionConfusionNetwork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecognitionConfusionNetwork {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfusionNetworkLink {
    // message fields
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub arcs: ::protobuf::RepeatedField<ConfusionNetworkArc>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfusionNetworkLink {
    fn default() -> &'a ConfusionNetworkLink {
        <ConfusionNetworkLink as ::protobuf::Message>::default_instance()
    }
}

impl ConfusionNetworkLink {
    pub fn new() -> ConfusionNetworkLink {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration start_time = 1;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Duration {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Duration {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration duration = 2;


    pub fn get_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.duration.is_none() {
            self.duration.set_default();
        }
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;


    pub fn get_arcs(&self) -> &[ConfusionNetworkArc] {
        &self.arcs
    }
    pub fn clear_arcs(&mut self) {
        self.arcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_arcs(&mut self, v: ::protobuf::RepeatedField<ConfusionNetworkArc>) {
        self.arcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arcs(&mut self) -> &mut ::protobuf::RepeatedField<ConfusionNetworkArc> {
        &mut self.arcs
    }

    // Take field
    pub fn take_arcs(&mut self) -> ::protobuf::RepeatedField<ConfusionNetworkArc> {
        ::std::mem::replace(&mut self.arcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConfusionNetworkLink {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.duration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.arcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.duration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.arcs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfusionNetworkLink {
        ConfusionNetworkLink::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "start_time",
                |m: &ConfusionNetworkLink| { &m.start_time },
                |m: &mut ConfusionNetworkLink| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "duration",
                |m: &ConfusionNetworkLink| { &m.duration },
                |m: &mut ConfusionNetworkLink| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfusionNetworkArc>>(
                "arcs",
                |m: &ConfusionNetworkLink| { &m.arcs },
                |m: &mut ConfusionNetworkLink| { &mut m.arcs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfusionNetworkLink>(
                "ConfusionNetworkLink",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfusionNetworkLink {
        static instance: ::protobuf::rt::LazyV2<ConfusionNetworkLink> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfusionNetworkLink::new)
    }
}

impl ::protobuf::Clear for ConfusionNetworkLink {
    fn clear(&mut self) {
        self.start_time.clear();
        self.duration.clear();
        self.arcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfusionNetworkLink {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfusionNetworkLink {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfusionNetworkArc {
    // message fields
    pub word: ::std::string::String,
    pub confidence: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfusionNetworkArc {
    fn default() -> &'a ConfusionNetworkArc {
        <ConfusionNetworkArc as ::protobuf::Message>::default_instance()
    }
}

impl ConfusionNetworkArc {
    pub fn new() -> ConfusionNetworkArc {
        ::std::default::Default::default()
    }

    // string word = 1;


    pub fn get_word(&self) -> &str {
        &self.word
    }
    pub fn clear_word(&mut self) {
        self.word.clear();
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        &mut self.word
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.word, ::std::string::String::new())
    }

    // double confidence = 2;


    pub fn get_confidence(&self) -> f64 {
        self.confidence
    }
    pub fn clear_confidence(&mut self) {
        self.confidence = 0.;
    }

    // Param is passed by value, moved
    pub fn set_confidence(&mut self, v: f64) {
        self.confidence = v;
    }
}

impl ::protobuf::Message for ConfusionNetworkArc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.word)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.confidence = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.word.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.word);
        }
        if self.confidence != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.word.is_empty() {
            os.write_string(1, &self.word)?;
        }
        if self.confidence != 0. {
            os.write_double(2, self.confidence)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfusionNetworkArc {
        ConfusionNetworkArc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "word",
                |m: &ConfusionNetworkArc| { &m.word },
                |m: &mut ConfusionNetworkArc| { &mut m.word },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "confidence",
                |m: &ConfusionNetworkArc| { &m.confidence },
                |m: &mut ConfusionNetworkArc| { &mut m.confidence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfusionNetworkArc>(
                "ConfusionNetworkArc",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfusionNetworkArc {
        static instance: ::protobuf::rt::LazyV2<ConfusionNetworkArc> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfusionNetworkArc::new)
    }
}

impl ::protobuf::Clear for ConfusionNetworkArc {
    fn clear(&mut self) {
        self.word.clear();
        self.confidence = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfusionNetworkArc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfusionNetworkArc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bcubic.proto\x12\x12cobaltspeech.cubic\x1a\x1cgoogle/api/annotation\
    s.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/emp\
    ty.proto\"\x13\n\x11ListModelsRequest\"\x8d\x01\n\x10RecognizeRequest\
    \x12=\n\x06config\x18\x01\x20\x01(\x0b2%.cobaltspeech.cubic.RecognitionC\
    onfigR\x06config\x12:\n\x05audio\x18\x02\x20\x01(\x0b2$.cobaltspeech.cub\
    ic.RecognitionAudioR\x05audio\"\xa5\x01\n\x19StreamingRecognizeRequest\
    \x12?\n\x06config\x18\x01\x20\x01(\x0b2%.cobaltspeech.cubic.RecognitionC\
    onfigH\0R\x06config\x12<\n\x05audio\x18\x02\x20\x01(\x0b2$.cobaltspeech.\
    cubic.RecognitionAudioH\0R\x05audioB\t\n\x07request\"\x85\x01\n\x15Compi\
    leContextRequest\x12\x19\n\x08model_id\x18\x01\x20\x01(\tR\x07modelId\
    \x12\x14\n\x05token\x18\x02\x20\x01(\tR\x05token\x12;\n\x07phrases\x18\
    \x03\x20\x03(\x0b2!.cobaltspeech.cubic.ContextPhraseR\x07phrases\"?\n\
    \x0fVersionResponse\x12\x14\n\x05cubic\x18\x01\x20\x01(\tR\x05cubic\x12\
    \x16\n\x06server\x18\x02\x20\x01(\tR\x06server\"G\n\x12ListModelsRespons\
    e\x121\n\x06models\x18\x01\x20\x03(\x0b2\x19.cobaltspeech.cubic.ModelR\
    \x06models\"V\n\x13RecognitionResponse\x12?\n\x07results\x18\x01\x20\x03\
    (\x0b2%.cobaltspeech.cubic.RecognitionResultR\x07results\"W\n\x16Compile\
    ContextResponse\x12=\n\x07context\x18\x01\x20\x01(\x0b2#.cobaltspeech.cu\
    bic.CompiledContextR\x07context\"\xbb\x05\n\x11RecognitionConfig\x12\x19\
    \n\x08model_id\x18\x01\x20\x01(\tR\x07modelId\x12U\n\x0eaudio_encoding\
    \x18\x02\x20\x01(\x0e2..cobaltspeech.cubic.RecognitionConfig.EncodingR\r\
    audioEncoding\x12<\n\x0cidle_timeout\x18\x03\x20\x01(\x0b2\x19.google.pr\
    otobuf.DurationR\x0bidleTimeout\x127\n\x18enable_word_time_offsets\x18\
    \x04\x20\x01(\x08R\x15enableWordTimeOffsets\x124\n\x16enable_word_confid\
    ence\x18\x05\x20\x01(\x08R\x14enableWordConfidence\x122\n\x15enable_raw_\
    transcript\x18\x06\x20\x01(\x08R\x13enableRawTranscript\x128\n\x18enable\
    _confusion_network\x18\x07\x20\x01(\x08R\x16enableConfusionNetwork\x12%\
    \n\x0eaudio_channels\x18\x08\x20\x03(\rR\raudioChannels\x12C\n\x08metada\
    ta\x18\t\x20\x01(\x0b2'.cobaltspeech.cubic.RecognitionMetadataR\x08metad\
    ata\x12@\n\x07context\x18\n\x20\x01(\x0b2&.cobaltspeech.cubic.Recognitio\
    nContextR\x07context\"k\n\x08Encoding\x12\x10\n\x0cRAW_LINEAR16\x10\0\
    \x12\x07\n\x03WAV\x10\x01\x12\x07\n\x03MP3\x10\x02\x12\x08\n\x04FLAC\x10\
    \x03\x12\x0b\n\x07VOX8000\x10\x04\x12\x0c\n\x08ULAW8000\x10\x05\x12\x0c\
    \n\x08ALAW8000\x10\x06\x12\x08\n\x04OPUS\x10\x07\">\n\x13RecognitionMeta\
    data\x12'\n\x0fcustom_metadata\x18\x01\x20\x01(\tR\x0ecustomMetadata\"U\
    \n\x12RecognitionContext\x12?\n\x08compiled\x18\x01\x20\x03(\x0b2#.cobal\
    tspeech.cubic.CompiledContextR\x08compiled\"%\n\x0fCompiledContext\x12\
    \x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"9\n\rContextPhrase\x12\x12\
    \n\x04text\x18\x01\x20\x01(\tR\x04text\x12\x14\n\x05boost\x18\x02\x20\
    \x01(\x02R\x05boost\"&\n\x10RecognitionAudio\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\"p\n\x05Model\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12C\n\nattributes\
    \x18\x03\x20\x01(\x0b2#.cobaltspeech.cubic.ModelAttributesR\nattributes\
    \"v\n\x0fModelAttributes\x12\x1f\n\x0bsample_rate\x18\x01\x20\x01(\rR\ns\
    ampleRate\x12B\n\x0ccontext_info\x18\x02\x20\x01(\x0b2\x1f.cobaltspeech.\
    cubic.ContextInfoR\x0bcontextInfo\"n\n\x0bContextInfo\x12)\n\x10supports\
    _context\x18\x01\x20\x01(\x08R\x0fsupportsContext\x124\n\x16allowed_cont\
    ext_tokens\x18\x02\x20\x03(\tR\x14allowedContextTokens\"\xec\x01\n\x11Re\
    cognitionResult\x12N\n\x0calternatives\x18\x01\x20\x03(\x0b2*.cobaltspee\
    ch.cubic.RecognitionAlternativeR\x0calternatives\x12\x1d\n\nis_partial\
    \x18\x02\x20\x01(\x08R\tisPartial\x12C\n\x04cnet\x18\x03\x20\x01(\x0b2/.\
    cobaltspeech.cubic.RecognitionConfusionNetworkR\x04cnet\x12#\n\raudio_ch\
    annel\x18\x04\x20\x01(\rR\x0caudioChannel\"\xdf\x02\n\x16RecognitionAlte\
    rnative\x12\x1e\n\ntranscript\x18\x01\x20\x01(\tR\ntranscript\x12%\n\x0e\
    raw_transcript\x18\x06\x20\x01(\tR\rrawTranscript\x12\x1e\n\nconfidence\
    \x18\x02\x20\x01(\x01R\nconfidence\x122\n\x05words\x18\x03\x20\x03(\x0b2\
    \x1c.cobaltspeech.cubic.WordInfoR\x05words\x129\n\traw_words\x18\x07\x20\
    \x03(\x0b2\x1c.cobaltspeech.cubic.WordInfoR\x08rawWords\x128\n\nstart_ti\
    me\x18\x04\x20\x01(\x0b2\x19.google.protobuf.DurationR\tstartTime\x125\n\
    \x08duration\x18\x05\x20\x01(\x0b2\x19.google.protobuf.DurationR\x08dura\
    tion\"\xaf\x01\n\x08WordInfo\x12\x12\n\x04word\x18\x01\x20\x01(\tR\x04wo\
    rd\x12\x1e\n\nconfidence\x18\x02\x20\x01(\x01R\nconfidence\x128\n\nstart\
    _time\x18\x03\x20\x01(\x0b2\x19.google.protobuf.DurationR\tstartTime\x12\
    5\n\x08duration\x18\x04\x20\x01(\x0b2\x19.google.protobuf.DurationR\x08d\
    uration\"]\n\x1bRecognitionConfusionNetwork\x12>\n\x05links\x18\x01\x20\
    \x03(\x0b2(.cobaltspeech.cubic.ConfusionNetworkLinkR\x05links\"\xc4\x01\
    \n\x14ConfusionNetworkLink\x128\n\nstart_time\x18\x01\x20\x01(\x0b2\x19.\
    google.protobuf.DurationR\tstartTime\x125\n\x08duration\x18\x02\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x08duration\x12;\n\x04arcs\x18\x03\
    \x20\x03(\x0b2'.cobaltspeech.cubic.ConfusionNetworkArcR\x04arcs\"I\n\x13\
    ConfusionNetworkArc\x12\x12\n\x04word\x18\x01\x20\x01(\tR\x04word\x12\
    \x1e\n\nconfidence\x18\x02\x20\x01(\x01R\nconfidence2\xe4\x04\n\x05Cubic\
    \x12\\\n\x07Version\x12\x16.google.protobuf.Empty\x1a#.cobaltspeech.cubi\
    c.VersionResponse\"\x14\x82\xd3\xe4\x93\x02\x0e\x12\x0c/api/version\x12t\
    \n\nListModels\x12%.cobaltspeech.cubic.ListModelsRequest\x1a&.cobaltspee\
    ch.cubic.ListModelsResponse\"\x17\x82\xd3\xe4\x93\x02\x11\x12\x0f/api/li\
    stmodels\x12u\n\tRecognize\x12$.cobaltspeech.cubic.RecognizeRequest\x1a'\
    .cobaltspeech.cubic.RecognitionResponse\"\x19\x82\xd3\xe4\x93\x02\x13\"\
    \x0e/api/recognize:\x01*\x12\x85\x01\n\x12StreamingRecognize\x12-.cobalt\
    speech.cubic.StreamingRecognizeRequest\x1a'.cobaltspeech.cubic.Recogniti\
    onResponse\"\x13\x82\xd3\xe4\x93\x02\r\x12\x0b/api/stream(\x010\x01\x12\
    \x87\x01\n\x0eCompileContext\x12).cobaltspeech.cubic.CompileContextReque\
    st\x1a*.cobaltspeech.cubic.CompileContextResponse\"\x1e\x82\xd3\xe4\x93\
    \x02\x18\"\x13/api/compilecontext:\x01*B\x20Z\t.;cubicpb\xaa\x02\x12Coba\
    ltSpeech.CubicJ\xe3\xab\x01\n\x07\x12\x05\x0e\0\xf8\x03\x01\n\xd4\x04\n\
    \x01\x0c\x12\x03\x0e\0\x1222\x20Copyright\x20(2019)\x20Cobalt\x20Speech\
    \x20and\x20Language\x20Inc.\n2\x95\x04\x20Licensed\x20under\x20the\x20Ap\
    ache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20\
    may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\
    \x20the\x20License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\
    \x20License\x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/\
    LICENSE-2.0\n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\
    \x20agreed\x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\
    \x20the\x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20B\
    ASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIN\
    D,\x20either\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20\
    for\x20the\x20specific\x20language\x20governing\x20permissions\x20and\n\
    \x20limitations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\
    \x10\0\x1b\n\t\n\x02\x03\0\x12\x03\x12\0&\n\t\n\x02\x03\x01\x12\x03\x13\
    \0(\n\t\n\x02\x03\x02\x12\x03\x14\0%\n\x08\n\x01\x08\x12\x03\x16\0\x20\n\
    \t\n\x02\x08\x0b\x12\x03\x16\0\x20\n\x08\n\x01\x08\x12\x03\x17\0/\n\t\n\
    \x02\x08%\x12\x03\x17\0/\nM\n\x02\x06\0\x12\x04\x1a\0Q\x01\x1aA\x20Servi\
    ce\x20that\x20implements\x20the\x20Cobalt\x20Cubic\x20Speech\x20Recognit\
    ion\x20API\n\n\n\n\x03\x06\0\x01\x12\x03\x1a\x08\r\n1\n\x04\x06\0\x02\0\
    \x12\x04\x1c\x02\x20\x03\x1a#\x20Queries\x20the\x20Version\x20of\x20the\
    \x20Server\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x1c\x06\r\n\x0c\n\x05\
    \x06\0\x02\0\x02\x12\x03\x1c\x0f$\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\
    \x1c/>\n\r\n\x05\x06\0\x02\0\x04\x12\x04\x1d\x04\x1f\x06\n\x11\n\t\x06\0\
    \x02\0\x04\xb0\xca\xbc\"\x12\x04\x1d\x04\x1f\x06\nG\n\x04\x06\0\x02\x01\
    \x12\x04$\x02(\x03\x1a9\x20Retrieves\x20a\x20list\x20of\x20available\x20\
    speech\x20recognition\x20models\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03$\
    \x06\x10\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03$\x12#\n\x0c\n\x05\x06\0\
    \x02\x01\x03\x12\x03$.@\n\r\n\x05\x06\0\x02\x01\x04\x12\x04%\x04'\x06\n\
    \x11\n\t\x06\0\x02\x01\x04\xb0\xca\xbc\"\x12\x04%\x04'\x06\n\xa9\x02\n\
    \x04\x06\0\x02\x02\x12\x04.\x023\x03\x1a\x9a\x02\x20Performs\x20synchron\
    ous\x20speech\x20recognition:\x20receive\x20results\x20after\x20all\x20a\
    udio\n\x20has\x20been\x20sent\x20and\x20processed.\x20\x20It\x20is\x20ex\
    pected\x20that\x20this\x20request\x20be\x20typically\n\x20used\x20for\
    \x20short\x20audio\x20content:\x20less\x20than\x20a\x20minute\x20long.\
    \x20\x20For\x20longer\x20content,\n\x20the\x20`StreamingRecognize`\x20me\
    thod\x20should\x20be\x20preferred.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\
    \x03.\x06\x0f\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03.\x10\x20\n\x0c\n\x05\
    \x06\0\x02\x02\x03\x12\x03.+>\n\r\n\x05\x06\0\x02\x02\x04\x12\x04/\x042\
    \x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04/\x042\x06\n\xeb\
    \x01\n\x04\x06\0\x02\x03\x12\x048\x02<\x03\x1a\xdc\x01\x20Performs\x20bi\
    directional\x20streaming\x20speech\x20recognition.\x20\x20Receive\x20res\
    ults\x20while\n\x20sending\x20audio.\x20\x20This\x20method\x20is\x20only\
    \x20available\x20via\x20GRPC\x20and\x20not\x20via\n\x20HTTP+JSON.\x20How\
    ever,\x20a\x20web\x20browser\x20may\x20use\x20websockets\x20to\x20use\
    \x20this\x20service.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x038\x06\x18\n\
    \x0c\n\x05\x06\0\x02\x03\x05\x12\x038\x1a\x20\n\x0c\n\x05\x06\0\x02\x03\
    \x02\x12\x038!:\n\x0c\n\x05\x06\0\x02\x03\x06\x12\x038EK\n\x0c\n\x05\x06\
    \0\x02\x03\x03\x12\x038L_\n\r\n\x05\x06\0\x02\x03\x04\x12\x049\x04;\x06\
    \n\x11\n\t\x06\0\x02\x03\x04\xb0\xca\xbc\"\x12\x049\x04;\x06\n\x90\x07\n\
    \x04\x06\0\x02\x04\x12\x04K\x02P\x03\x1a\x81\x07\x20Compiles\x20recognit\
    ion\x20context\x20information,\x20such\x20as\x20a\x20specialized\x20list\
    \x20of\n\x20words\x20or\x20phrases,\x20into\x20a\x20compact,\x20efficien\
    t\x20form\x20to\x20send\x20with\x20subsequent\n\x20`Recognize`\x20or\x20\
    `StreamingRecognize`\x20requests\x20to\x20customize\x20speech\n\x20recog\
    nition.\x20For\x20example,\x20a\x20list\x20of\x20contact\x20names\x20may\
    \x20be\x20compiled\x20in\x20a\n\x20mobile\x20app\x20and\x20sent\x20with\
    \x20each\x20recognition\x20request\x20so\x20that\x20the\x20app\x20user's\
    \n\x20contact\x20names\x20are\x20more\x20likely\x20to\x20be\x20recognize\
    d\x20than\x20arbitrary\x20names.\x20This\n\x20pre-compilation\x20ensures\
    \x20that\x20there\x20is\x20no\x20added\x20latency\x20for\x20the\x20recog\
    nition\n\x20request.\x20It\x20is\x20important\x20to\x20note\x20that\x20i\
    n\x20order\x20to\x20compile\x20context\x20for\x20a\n\x20model,\x20that\
    \x20model\x20has\x20to\x20support\x20context\x20in\x20the\x20first\x20pl\
    ace,\x20which\x20can\x20be\n\x20verified\x20by\x20checking\x20its\x20`Mo\
    delAttributes.ContextInfo`\x20obtained\x20via\x20the\n\x20`ListModels`\
    \x20method.\x20Also,\x20the\x20compiled\x20data\x20will\x20be\x20model\
    \x20specific;\x20that\n\x20is,\x20the\x20data\x20compiled\x20for\x20one\
    \x20model\x20will\x20generally\x20not\x20be\x20usable\x20with\x20a\n\x20\
    different\x20model.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03K\x06\x14\n\
    \x0c\n\x05\x06\0\x02\x04\x02\x12\x03K\x15*\n\x0c\n\x05\x06\0\x02\x04\x03\
    \x12\x03K5K\n\r\n\x05\x06\0\x02\x04\x04\x12\x04L\x04O\x06\n\x11\n\t\x06\
    \0\x02\x04\x04\xb0\xca\xbc\"\x12\x04L\x04O\x06\nR\n\x02\x04\0\x12\x03T\0\
    \x1c\x1aG\x20The\x20top-level\x20message\x20sent\x20by\x20the\x20client\
    \x20for\x20the\x20`ListModels`\x20method.\n\n\n\n\x03\x04\0\x01\x12\x03T\
    \x08\x19\n\x9e\x02\n\x02\x04\x01\x12\x04Z\0`\x01\x1a\x91\x02\x20The\x20t\
    op-level\x20message\x20sent\x20by\x20the\x20client\x20for\x20the\x20`Rec\
    ognize`\x20method.\x20\x20Both\n\x20the\x20`RecognitionConfig`\x20and\
    \x20`RecognitionAudio`\x20fields\x20are\x20required.\x20\x20The\n\x20ent\
    ire\x20audio\x20data\x20must\x20be\x20sent\x20in\x20one\x20request.\x20\
    \x20If\x20your\x20audio\x20data\x20is\x20larger,\n\x20please\x20use\x20t\
    he\x20`StreamingRecognize`\x20call..\n\n\n\n\x03\x04\x01\x01\x12\x03Z\
    \x08\x18\n?\n\x04\x04\x01\x02\0\x12\x03\\\x02\x1f\x1a2\x20Provides\x20co\
    nfiguration\x20to\x20create\x20the\x20recognizer.\n\n\x0c\n\x05\x04\x01\
    \x02\0\x06\x12\x03\\\x02\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\\\x14\
    \x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\\\x1d\x1e\n.\n\x04\x04\x01\
    \x02\x01\x12\x03_\x02\x1d\x1a!\x20The\x20audio\x20data\x20to\x20be\x20re\
    cognized\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03_\x02\x12\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03_\x13\x18\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03_\x1b\x1c\n\xd1\x03\n\x02\x04\x02\x12\x04h\0n\x01\x1a\xc4\x03\
    \x20The\x20top-level\x20message\x20sent\x20by\x20the\x20client\x20for\
    \x20the\x20`StreamingRecognize`\n\x20request.\x20\x20Multiple\x20`Stream\
    ingRecognizeRequest`\x20messages\x20are\x20sent.\x20The\x20first\n\x20me\
    ssage\x20must\x20contain\x20a\x20`RecognitionConfig`\x20message\x20only,\
    \x20and\x20all\x20subsequent\n\x20messages\x20must\x20contain\x20`Recogn\
    itionAudio`\x20only.\x20\x20All\x20`RecognitionAudio`\n\x20messages\x20m\
    ust\x20contain\x20non-empty\x20audio.\x20\x20If\x20audio\x20content\x20i\
    s\x20empty,\x20the\x20server\n\x20may\x20interpret\x20it\x20as\x20end\
    \x20of\x20stream\x20and\x20stop\x20accepting\x20any\x20further\x20messag\
    es.\n\n\n\n\x03\x04\x02\x01\x12\x03h\x08!\n\x0c\n\x04\x04\x02\x08\0\x12\
    \x04i\x02l\x03\n\x0c\n\x05\x04\x02\x08\0\x01\x12\x03i\x08\x0f\n\x0b\n\
    \x04\x04\x02\x02\0\x12\x03j\x04!\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03j\
    \x04\x15\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03j\x16\x1c\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03j\x1f\x20\n\x0b\n\x04\x04\x02\x02\x01\x12\x03k\x04\
    \x1f\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03k\x04\x14\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03k\x15\x1a\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\
    \x03k\x1d\x1e\n\xae\x04\n\x02\x04\x03\x12\x05x\0\x86\x01\x01\x1a\xa0\x04\
    \x20The\x20top-level\x20message\x20sent\x20by\x20the\x20client\x20for\
    \x20the\x20`CompileContext`\x20request.\x20It\n\x20contains\x20a\x20list\
    \x20of\x20phrases\x20or\x20words,\x20paired\x20with\x20a\x20context\x20t\
    oken\x20included\x20in\n\x20the\x20model\x20being\x20used.\x20The\x20tok\
    en\x20specifies\x20a\x20category\x20such\x20as\x20\"menu_item\",\n\x20\"\
    airport\",\x20\"contact\",\x20\"product_name\"\x20etc.\x20The\x20context\
    \x20token\x20is\x20used\x20to\n\x20determine\x20the\x20places\x20in\x20t\
    he\x20recognition\x20output\x20where\x20the\x20provided\x20list\x20of\n\
    \x20phrases\x20or\x20words\x20may\x20appear.\x20The\x20allowed\x20contex\
    t\x20tokens\x20for\x20a\x20given\x20model\x20can\n\x20be\x20found\x20in\
    \x20its\x20`ModelAttributes.ContextInfo`\x20obtained\x20via\x20the\x20`L\
    istModels`\n\x20method.\n\n\n\n\x03\x04\x03\x01\x12\x03x\x08\x1d\n\xe1\
    \x01\n\x04\x04\x03\x02\0\x12\x03|\x02\x16\x1a\xd3\x01\x20Unique\x20ident\
    ifier\x20of\x20the\x20model\x20to\x20compile\x20the\x20context\x20inform\
    ation\x20for.\x20The\n\x20model\x20chosen\x20needs\x20to\x20support\x20c\
    ontext\x20which\x20can\x20be\x20verified\x20by\x20checking\x20its\n\x20`\
    ModelAttributes.ContextInfo`\x20obtained\x20via\x20`ListModels`.\n\n\x0c\
    \n\x05\x04\x03\x02\0\x05\x12\x03|\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x03|\t\x11\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03|\x14\x15\n\xf5\x01\
    \n\x04\x04\x03\x02\x01\x12\x04\x82\x01\x02\x13\x1a\xe6\x01\x20The\x20tok\
    en\x20that\x20is\x20associated\x20with\x20the\x20provided\x20list\x20of\
    \x20phrases\x20or\x20words\n\x20(e.g\x20\"menu_item\",\x20\"airport\"\
    \x20etc.).\x20Must\x20be\x20one\x20of\x20the\x20tokens\x20included\x20in\
    \n\x20the\x20model\x20being\x20used,\x20which\x20can\x20be\x20retrieved\
    \x20by\x20calling\x20the\x20`ListModels`\n\x20method.\n\n\r\n\x05\x04\
    \x03\x02\x01\x05\x12\x04\x82\x01\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\
    \x12\x04\x82\x01\t\x0e\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\x82\x01\x11\
    \x12\n<\n\x04\x04\x03\x02\x02\x12\x04\x85\x01\x02%\x1a.\x20List\x20of\
    \x20phrases\x20and/or\x20words\x20to\x20be\x20compiled.\n\n\r\n\x05\x04\
    \x03\x02\x02\x04\x12\x04\x85\x01\x02\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\
    \x04\x85\x01\x0b\x18\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\x85\x01\x19\
    \x20\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\x85\x01#$\nH\n\x02\x04\x04\
    \x12\x06\x89\x01\0\x8f\x01\x01\x1a:\x20The\x20message\x20sent\x20by\x20t\
    he\x20server\x20for\x20the\x20`Version`\x20method.\n\n\x0b\n\x03\x04\x04\
    \x01\x12\x04\x89\x01\x08\x17\nE\n\x04\x04\x04\x02\0\x12\x04\x8b\x01\x02\
    \x13\x1a7\x20version\x20of\x20the\x20cubic\x20library\x20handling\x20the\
    \x20recognition\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x8b\x01\x02\x08\n\
    \r\n\x05\x04\x04\x02\0\x01\x12\x04\x8b\x01\t\x0e\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\x8b\x01\x11\x12\n=\n\x04\x04\x04\x02\x01\x12\x04\x8e\x01\
    \x02\x14\x1a/\x20version\x20of\x20the\x20server\x20handling\x20these\x20\
    requests\n\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\x8e\x01\x02\x08\n\r\n\
    \x05\x04\x04\x02\x01\x01\x12\x04\x8e\x01\t\x0f\n\r\n\x05\x04\x04\x02\x01\
    \x03\x12\x04\x8e\x01\x12\x13\nN\n\x02\x04\x05\x12\x06\x93\x01\0\x96\x01\
    \x01\x1a@\x20The\x20message\x20returned\x20to\x20the\x20client\x20by\x20\
    the\x20`ListModels`\x20method.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x93\x01\
    \x08\x1a\nH\n\x04\x04\x05\x02\0\x12\x04\x95\x01\x02\x1c\x1a:\x20List\x20\
    of\x20models\x20available\x20for\x20use\x20that\x20match\x20the\x20reque\
    st.\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\x95\x01\x02\n\n\r\n\x05\x04\
    \x05\x02\0\x06\x12\x04\x95\x01\x0b\x10\n\r\n\x05\x04\x05\x02\0\x01\x12\
    \x04\x95\x01\x11\x17\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x95\x01\x1a\x1b\
    \n\x88\x04\n\x02\x04\x06\x12\x06\x9f\x01\0\xa1\x01\x01\x1a\xf9\x03\x20Co\
    llection\x20of\x20sequence\x20of\x20recognition\x20results\x20in\x20a\
    \x20portion\x20of\x20audio.\x20\x20When\n\x20transcribing\x20a\x20single\
    \x20audio\x20channel\x20(e.g.\x20RAW_LINEAR16\x20input,\x20or\x20a\x20mo\
    no\n\x20file),\x20results\x20will\x20be\x20ordered\x20chronologically.\
    \x20\x20When\x20transcribing\x20multiple\n\x20channels,\x20the\x20result\
    s\x20of\x20all\x20channels\x20will\x20be\x20interleaved.\x20\x20Results\
    \x20of\x20each\n\x20individual\x20channel\x20will\x20be\x20chronological\
    .\x20\x20No\x20such\x20promise\x20is\x20made\x20for\x20the\n\x20ordering\
    \x20of\x20results\x20of\x20different\x20channels,\x20as\x20results\x20ar\
    e\x20returned\x20for\x20each\n\x20channel\x20individually\x20as\x20soon\
    \x20as\x20they\x20are\x20ready.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\x9f\
    \x01\x08\x1b\n\x0c\n\x04\x04\x06\x02\0\x12\x04\xa0\x01\x02)\n\r\n\x05\
    \x04\x06\x02\0\x04\x12\x04\xa0\x01\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\
    \x04\xa0\x01\x0b\x1c\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xa0\x01\x1d$\n\
    \r\n\x05\x04\x06\x02\0\x03\x12\x04\xa0\x01'(\nR\n\x02\x04\x07\x12\x06\
    \xa4\x01\0\xaa\x01\x01\x1aD\x20The\x20message\x20returned\x20to\x20the\
    \x20client\x20by\x20the\x20`CompileContext`\x20method.\n\n\x0b\n\x03\x04\
    \x07\x01\x12\x04\xa4\x01\x08\x1e\n\x8d\x02\n\x04\x04\x07\x02\0\x12\x04\
    \xa9\x01\x02\x1e\x1a\xfe\x01\x20Context\x20information\x20in\x20a\x20com\
    pact\x20form\x20that\x20is\x20efficient\x20for\x20use\x20in\n\x20subsequ\
    ent\x20recognition\x20requests.\x20The\x20size\x20of\x20the\x20compiled\
    \x20form\x20will\x20depend\n\x20on\x20the\x20amount\x20of\x20text\x20tha\
    t\x20was\x20sent\x20for\x20compilation.\x20For\x201000\x20words\x20it's\
    \n\x20generally\x20less\x20than\x20100\x20kilobytes.\n\n\r\n\x05\x04\x07\
    \x02\0\x06\x12\x04\xa9\x01\x02\x11\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xa9\x01\x12\x19\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xa9\x01\x1c\x1d\n9\
    \n\x02\x04\x08\x12\x06\xad\x01\0\xa2\x02\x01\x1a+\x20Configuration\x20fo\
    r\x20setting\x20up\x20a\x20Recognizer\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \xad\x01\x08\x19\nZ\n\x04\x04\x08\x02\0\x12\x04\xaf\x01\x02\x16\x1aL\x20\
    Unique\x20identifier\x20of\x20the\x20model\x20to\x20use,\x20as\x20obtain\
    ed\x20from\x20a\x20`Model`\x20message.\n\n\r\n\x05\x04\x08\x02\0\x05\x12\
    \x04\xaf\x01\x02\x08\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xaf\x01\t\x11\n\
    \r\n\x05\x04\x08\x02\0\x03\x12\x04\xaf\x01\x14\x15\n\xb7\x01\n\x04\x04\
    \x08\x04\0\x12\x06\xb5\x01\x02\xd1\x01\x03\x1a\xa6\x01\x20The\x20encodin\
    g\x20of\x20the\x20audio\x20data\x20to\x20be\x20sent\x20for\x20recognitio\
    n.\n\n\x20For\x20best\x20results,\x20the\x20audio\x20source\x20should\
    \x20be\x20captured\x20and\x20transmitted\x20using\n\x20the\x20RAW_LINEAR\
    16\x20encoding.\n\n\r\n\x05\x04\x08\x04\0\x01\x12\x04\xb5\x01\x07\x0f\n\
    \xa7\x01\n\x06\x04\x08\x04\0\x02\0\x12\x04\xb8\x01\x04\x15\x1a\x96\x01\
    \x20Raw\x20(headerless)\x20Uncompressed\x2016-bit\x20signed\x20little\
    \x20endian\x20samples\x20(linear\n\x20PCM),\x20single\x20channel,\x20sam\
    pled\x20at\x20the\x20rate\x20expected\x20by\x20the\x20chosen\x20`Model`.\
    \n\n\x0f\n\x07\x04\x08\x04\0\x02\0\x01\x12\x04\xb8\x01\x04\x10\n\x0f\n\
    \x07\x04\x08\x04\0\x02\0\x02\x12\x04\xb8\x01\x13\x14\n\x93\x01\n\x06\x04\
    \x08\x04\0\x02\x01\x12\x04\xbc\x01\x04\x0c\x1a\x82\x01\x20WAV\x20(data\
    \x20with\x20RIFF\x20headers),\x20with\x20data\x20sampled\x20at\x20a\x20r\
    ate\x20equal\x20to\x20or\n\x20higher\x20than\x20the\x20sample\x20rate\
    \x20expected\x20by\x20the\x20chosen\x20Model.\n\n\x0f\n\x07\x04\x08\x04\
    \0\x02\x01\x01\x12\x04\xbc\x01\x04\x07\n\x0f\n\x07\x04\x08\x04\0\x02\x01\
    \x02\x12\x04\xbc\x01\n\x0b\nv\n\x06\x04\x08\x04\0\x02\x02\x12\x04\xc0\
    \x01\x04\x0c\x1af\x20MP3\x20data,\x20sampled\x20at\x20a\x20rate\x20equal\
    \x20to\x20or\x20higher\x20than\x20the\x20sampling\x20rate\n\x20expected\
    \x20by\x20the\x20chosen\x20Model.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x02\
    \x01\x12\x04\xc0\x01\x04\x07\n\x0f\n\x07\x04\x08\x04\0\x02\x02\x02\x12\
    \x04\xc0\x01\n\x0b\nu\n\x06\x04\x08\x04\0\x02\x03\x12\x04\xc4\x01\x04\r\
    \x1ae\x20FLAC\x20data,\x20sampled\x20at\x20a\x20rate\x20equal\x20to\x20o\
    r\x20higher\x20than\x20the\x20sample\x20rate\n\x20expected\x20by\x20the\
    \x20chosen\x20Model.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x01\x12\x04\xc4\
    \x01\x04\x08\n\x0f\n\x07\x04\x08\x04\0\x02\x03\x02\x12\x04\xc4\x01\x0b\
    \x0c\n>\n\x06\x04\x08\x04\0\x02\x04\x12\x04\xc7\x01\x04\x10\x1a.\x20VOX\
    \x20data\x20(Dialogic\x20ADPCM),\x20sampled\x20at\x208\x20KHz.\n\n\x0f\n\
    \x07\x04\x08\x04\0\x02\x04\x01\x12\x04\xc7\x01\x04\x0b\n\x0f\n\x07\x04\
    \x08\x04\0\x02\x04\x02\x12\x04\xc7\x01\x0e\x0f\nT\n\x06\x04\x08\x04\0\
    \x02\x05\x12\x04\xca\x01\x04\x11\x1aD\x20\xce\xbc-law\x20(8-bit)\x20enco\
    ded\x20RAW\x20data,\x20single\x20channel,\x20sampled\x20at\x208\x20KHz.\
    \n\n\x0f\n\x07\x04\x08\x04\0\x02\x05\x01\x12\x04\xca\x01\x04\x0c\n\x0f\n\
    \x07\x04\x08\x04\0\x02\x05\x02\x12\x04\xca\x01\x0f\x10\nS\n\x06\x04\x08\
    \x04\0\x02\x06\x12\x04\xcd\x01\x04\x11\x1aC\x20A-law\x20(8-bit)\x20encod\
    ed\x20RAW\x20data,\x20single\x20channel,\x20sampled\x20at\x208\x20KHz.\n\
    \n\x0f\n\x07\x04\x08\x04\0\x02\x06\x01\x12\x04\xcd\x01\x04\x0c\n\x0f\n\
    \x07\x04\x08\x04\0\x02\x06\x02\x12\x04\xcd\x01\x0f\x10\n\x89\x01\n\x06\
    \x04\x08\x04\0\x02\x07\x12\x04\xd0\x01\x04\r\x1ay\x20Opus\x20(16-bit)\
    \x20encoded\x20RAW\x20data,\x20sampled\x20at\x20a\x20rate\x20equal\x20to\
    \x20or\x20higher\x20than\x20the\x20sample\x20rate\x20expected\x20by\x20t\
    he\x20chosen\x20Model.\n\n\x0f\n\x07\x04\x08\x04\0\x02\x07\x01\x12\x04\
    \xd0\x01\x04\x08\n\x0f\n\x07\x04\x08\x04\0\x02\x07\x02\x12\x04\xd0\x01\
    \x0b\x0c\n\x87\x05\n\x04\x04\x08\x02\x01\x12\x04\xdf\x01\x02\x1e\x1a\xf8\
    \x04\x20Encoding\x20of\x20audio\x20data\x20sent/streamed\x20through\x20t\
    he\x20`RecognitionAudio`\n\x20messages.\x20\x20For\x20encodings\x20like\
    \x20WAV/MP3\x20that\x20have\x20headers,\x20the\x20headers\x20are\n\x20ex\
    pected\x20to\x20be\x20sent\x20at\x20the\x20beginning\x20of\x20the\x20str\
    eam,\x20not\x20in\x20every\n\x20`RecognitionAudio`\x20message.\n\n\x20If\
    \x20not\x20specified,\x20the\x20default\x20encoding\x20is\x20RAW_LINEAR1\
    6.\n\n\x20Depending\x20on\x20how\x20they\x20are\x20configured,\x20server\
    \x20instances\x20of\x20this\x20service\x20may\n\x20not\x20support\x20all\
    \x20the\x20encodings\x20enumerated\x20above.\x20They\x20are\x20always\
    \x20required\x20to\n\x20accept\x20RAW_LINEAR16.\x20\x20If\x20any\x20othe\
    r\x20`Encoding`\x20is\x20specified,\x20and\x20it\x20is\x20not\n\x20avail\
    able\x20on\x20the\x20server\x20being\x20used,\x20the\x20recognition\x20r\
    equest\x20will\x20result\x20in\n\x20an\x20appropriate\x20error\x20messag\
    e.\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xdf\x01\x02\n\n\r\n\x05\x04\
    \x08\x02\x01\x01\x12\x04\xdf\x01\x0b\x19\n\r\n\x05\x04\x08\x02\x01\x03\
    \x12\x04\xdf\x01\x1c\x1d\n\xce\x03\n\x04\x04\x08\x02\x02\x12\x04\xe7\x01\
    \x02,\x1a\xbf\x03\x20Idle\x20Timeout\x20of\x20the\x20created\x20Recogniz\
    er.\x20\x20If\x20no\x20audio\x20data\x20is\x20received\x20by\n\x20the\
    \x20recognizer\x20for\x20this\x20duration,\x20ongoing\x20rpc\x20calls\
    \x20will\x20result\x20in\x20an\n\x20error,\x20the\x20recognizer\x20will\
    \x20be\x20destroyed\x20and\x20thus\x20more\x20audio\x20may\x20not\x20be\
    \x20sent\n\x20to\x20the\x20same\x20recognizer.\x20\x20The\x20server\x20m\
    ay\x20impose\x20a\x20limit\x20on\x20the\x20maximum\x20idle\n\x20timeout\
    \x20that\x20can\x20be\x20specified,\x20and\x20if\x20the\x20value\x20in\
    \x20this\x20message\x20exceeds\n\x20that\x20serverside\x20value,\x20crea\
    ting\x20of\x20the\x20recognizer\x20will\x20fail\x20with\x20an\x20error.\
    \n\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xe7\x01\x02\x1a\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\xe7\x01\x1b'\n\r\n\x05\x04\x08\x02\x02\x03\x12\
    \x04\xe7\x01*+\n\x98\x02\n\x04\x04\x08\x02\x03\x12\x04\xed\x01\x02$\x1a\
    \x89\x02\x20This\x20is\x20an\x20optional\x20field.\x20\x20If\x20this\x20\
    is\x20set\x20to\x20true,\x20each\x20result\x20will\n\x20include\x20a\x20\
    list\x20of\x20words\x20and\x20the\x20start\x20time\x20offset\x20(timesta\
    mp)\x20and\x20the\n\x20duration\x20for\x20each\x20of\x20those\x20words.\
    \x20\x20If\x20set\x20to\x20`false`,\x20no\x20word-level\n\x20timestamps\
    \x20will\x20be\x20returned.\x20\x20The\x20default\x20is\x20`false`.\n\n\
    \r\n\x05\x04\x08\x02\x03\x05\x12\x04\xed\x01\x02\x06\n\r\n\x05\x04\x08\
    \x02\x03\x01\x12\x04\xed\x01\x07\x1f\n\r\n\x05\x04\x08\x02\x03\x03\x12\
    \x04\xed\x01\"#\n\xeb\x01\n\x04\x04\x08\x02\x04\x12\x04\xf2\x01\x02\"\
    \x1a\xdc\x01\x20This\x20is\x20an\x20optional\x20field.\x20\x20If\x20this\
    \x20is\x20set\x20to\x20true,\x20each\x20result\x20will\n\x20include\x20a\
    \x20list\x20of\x20words\x20and\x20the\x20confidence\x20for\x20those\x20w\
    ords.\x20\x20If\x20`false`,\x20no\n\x20word-level\x20confidence\x20infor\
    mation\x20is\x20returned.\x20\x20The\x20default\x20is\x20`false`.\n\n\r\
    \n\x05\x04\x08\x02\x04\x05\x12\x04\xf2\x01\x02\x06\n\r\n\x05\x04\x08\x02\
    \x04\x01\x12\x04\xf2\x01\x07\x1d\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\
    \xf2\x01\x20!\n\xb4\x03\n\x04\x04\x08\x02\x05\x12\x04\xfa\x01\x02!\x1a\
    \xa5\x03\x20This\x20is\x20an\x20optional\x20field.\x20\x20If\x20this\x20\
    is\x20set\x20to\x20true,\x20the\x20field\n\x20`RecognitionAlternative.ra\
    w_transcript`\x20will\x20be\x20populated\x20with\x20the\x20raw\n\x20tran\
    scripts\x20output\x20from\x20the\x20recognizer\x20will\x20be\x20exposed\
    \x20without\x20any\n\x20formatting\x20rules\x20applied.\x20\x20If\x20thi\
    s\x20is\x20set\x20to\x20false,\x20that\x20field\x20will\x20not\n\x20be\
    \x20set\x20in\x20the\x20results.\x20\x20The\x20RecognitionAlternative.tr\
    anscript\x20will\n\x20always\x20be\x20populated\x20with\x20text\x20forma\
    tted\x20according\x20to\x20the\x20server's\x20settings.\n\n\r\n\x05\x04\
    \x08\x02\x05\x05\x12\x04\xfa\x01\x02\x06\n\r\n\x05\x04\x08\x02\x05\x01\
    \x12\x04\xfa\x01\x07\x1c\n\r\n\x05\x04\x08\x02\x05\x03\x12\x04\xfa\x01\
    \x1f\x20\n\xa2\x03\n\x04\x04\x08\x02\x06\x12\x04\x82\x02\x02$\x1a\x93\
    \x03\x20This\x20is\x20an\x20optional\x20field.\x20\x20If\x20this\x20is\
    \x20set\x20to\x20true,\x20the\x20results\x20will\n\x20include\x20a\x20co\
    nfusion\x20network.\x20\x20If\x20set\x20to\x20`false`,\x20no\x20confusio\
    n\x20network\x20will\n\x20be\x20returned.\x20\x20The\x20default\x20is\
    \x20`false`.\x20\x20If\x20the\x20model\x20being\x20used\x20does\x20not\n\
    \x20support\x20a\x20confusion\x20network,\x20results\x20may\x20be\x20ret\
    urned\x20without\x20a\x20confusion\n\x20network\x20available.\x20\x20If\
    \x20this\x20field\x20is\x20set\x20to\x20`true`,\x20then\n\x20`enable_raw\
    _transcript`\x20is\x20also\x20forced\x20to\x20be\x20true.\n\n\r\n\x05\
    \x04\x08\x02\x06\x05\x12\x04\x82\x02\x02\x06\n\r\n\x05\x04\x08\x02\x06\
    \x01\x12\x04\x82\x02\x07\x1f\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\x82\
    \x02\"#\n\xda\x05\n\x04\x04\x08\x02\x07\x12\x04\x94\x02\x02%\x1a\xcb\x05\
    \x20This\x20is\x20an\x20optional\x20field.\x20\x20If\x20the\x20audio\x20\
    has\x20multiple\x20channels,\x20this\x20field\n\x20should\x20be\x20confi\
    gured\x20with\x20the\x20list\x20of\x20channel\x20indices\x20that\x20shou\
    ld\x20be\n\x20transcribed.\x20\x20Channels\x20are\x200-indexed.\n\n\x20E\
    xample:\x20`[0]`\x20for\x20a\x20mono\x20file,\x20`[0,\x201]`\x20for\x20a\
    \x20stereo\x20file.\n\n\x20If\x20this\x20field\x20is\x20not\x20set,\x20a\
    \x20mono\x20file\x20will\x20be\x20assumed\x20by\x20default\x20and\x20onl\
    y\n\x20channel-0\x20will\x20be\x20transcribed\x20even\x20if\x20the\x20fi\
    le\x20actually\x20has\x20additional\n\x20channels.\n\n\x20Channels\x20th\
    at\x20are\x20present\x20in\x20the\x20audio\x20may\x20be\x20omitted,\x20b\
    ut\x20it\x20is\x20an\x20error\n\x20to\x20include\x20a\x20channel\x20inde\
    x\x20in\x20this\x20field\x20that\x20is\x20not\x20present\x20in\x20the\
    \x20audio.\n\x20Channels\x20may\x20be\x20listed\x20in\x20any\x20order\
    \x20but\x20the\x20same\x20index\x20may\x20not\x20be\x20repeated\n\x20in\
    \x20this\x20list.\n\n\x20BAD:\x20`[0,\x202]`\x20for\x20a\x20stereo\x20fi\
    le;\x20BAD:\x20`[0,\x200]`\x20for\x20a\x20mono\x20file.\n\n\r\n\x05\x04\
    \x08\x02\x07\x04\x12\x04\x94\x02\x02\n\n\r\n\x05\x04\x08\x02\x07\x05\x12\
    \x04\x94\x02\x0b\x11\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\x94\x02\x12\
    \x20\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\x94\x02#$\n\x92\x02\n\x04\x04\
    \x08\x02\x08\x12\x04\x9a\x02\x02#\x1a\x83\x02\x20This\x20is\x20an\x20opt\
    ional\x20field.\x20\x20If\x20there\x20is\x20any\x20metadata\x20associate\
    d\x20with\x20the\n\x20audio\x20being\x20sent,\x20use\x20this\x20field\
    \x20to\x20provide\x20it\x20to\x20cubic.\x20\x20The\x20server\x20may\n\
    \x20record\x20this\x20metadata\x20when\x20processing\x20the\x20request.\
    \x20\x20The\x20server\x20does\x20not\x20use\n\x20this\x20field\x20for\
    \x20any\x20other\x20purpose.\n\n\r\n\x05\x04\x08\x02\x08\x06\x12\x04\x9a\
    \x02\x02\x15\n\r\n\x05\x04\x08\x02\x08\x01\x12\x04\x9a\x02\x16\x1e\n\r\n\
    \x05\x04\x08\x02\x08\x03\x12\x04\x9a\x02!\"\n\xca\x02\n\x04\x04\x08\x02\
    \t\x12\x04\xa1\x02\x02\"\x1a\xbb\x02\x20This\x20is\x20an\x20optional\x20\
    field\x20for\x20providing\x20any\x20additional\x20context\x20information\
    \n\x20that\x20may\x20aid\x20speech\x20recognition.\x20\x20This\x20can\
    \x20also\x20be\x20used\x20to\x20add\n\x20out-of-vocabulary\x20words\x20t\
    o\x20the\x20model\x20or\x20boost\x20recognition\x20of\x20specific\n\x20p\
    roper\x20names\x20or\x20commands.\x20Context\x20information\x20must\x20b\
    e\x20pre-compiled\x20via\x20the\n\x20`CompileContext()`\x20method.\n\n\r\
    \n\x05\x04\x08\x02\t\x06\x12\x04\xa1\x02\x02\x14\n\r\n\x05\x04\x08\x02\t\
    \x01\x12\x04\xa1\x02\x15\x1c\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\xa1\x02\
    \x1f!\nD\n\x02\x04\t\x12\x06\xa5\x02\0\xab\x02\x01\x1a6\x20Metadata\x20a\
    ssociated\x20with\x20the\x20audio\x20to\x20be\x20recognized.\n\n\x0b\n\
    \x03\x04\t\x01\x12\x04\xa5\x02\x08\x1b\n\xae\x01\n\x04\x04\t\x02\0\x12\
    \x04\xaa\x02\x02\x1d\x1a\x9f\x01\x20Any\x20custom\x20metadata\x20that\
    \x20the\x20client\x20wants\x20to\x20associate\x20with\x20the\x20recordin\
    g.\n\x20This\x20could\x20be\x20a\x20simple\x20string\x20(e.g.\x20a\x20tr\
    acing\x20ID)\x20or\x20structured\x20data\n\x20(e.g.\x20JSON)\n\n\r\n\x05\
    \x04\t\x02\0\x05\x12\x04\xaa\x02\x02\x08\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xaa\x02\t\x18\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xaa\x02\x1b\x1c\n\
    \xe1\x01\n\x02\x04\n\x12\x06\xb0\x02\0\xb4\x02\x01\x1a\xd2\x01\x20A\x20c\
    ollection\x20of\x20additional\x20context\x20information\x20that\x20may\
    \x20aid\x20speech\n\x20recognition.\x20\x20This\x20can\x20be\x20used\x20\
    to\x20add\x20out-of-vocabulary\x20words\x20to\x20\x20\n\x20the\x20model\
    \x20or\x20to\x20boost\x20recognition\x20of\x20specific\x20proper\x20name\
    s\x20or\x20commands.\x20\n\n\x0b\n\x03\x04\n\x01\x12\x04\xb0\x02\x08\x1a\
    \n\x99\x01\n\x04\x04\n\x02\0\x12\x04\xb3\x02\x02(\x1a\x8a\x01\x20List\
    \x20of\x20compiled\x20context\x20information,\x20with\x20each\x20entry\
    \x20being\x20compiled\x20from\x20a\n\x20list\x20of\x20words\x20or\x20phr\
    ases\x20using\x20the\x20`CompileContext`\x20method.\n\n\r\n\x05\x04\n\
    \x02\0\x04\x12\x04\xb3\x02\x02\n\n\r\n\x05\x04\n\x02\0\x06\x12\x04\xb3\
    \x02\x0b\x1a\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xb3\x02\x1b#\n\r\n\x05\
    \x04\n\x02\0\x03\x12\x04\xb3\x02&'\n\x8d\x02\n\x02\x04\x0b\x12\x06\xba\
    \x02\0\xbd\x02\x01\x1a\xfe\x01\x20Context\x20information\x20in\x20a\x20c\
    ompact\x20form\x20that\x20is\x20efficient\x20for\x20use\x20in\x20subsequ\
    ent\n\x20recognition\x20requests.\x20The\x20size\x20of\x20the\x20compile\
    d\x20form\x20will\x20depend\x20on\x20the\x20amount\n\x20of\x20text\x20th\
    at\x20was\x20sent\x20for\x20compilation.\x20For\x201000\x20words\x20it's\
    \x20generally\x20less\n\x20than\x20100\x20kilobytes.\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xba\x02\x08\x17\nQ\n\x04\x04\x0b\x02\0\x12\x04\xbc\x02\
    \x02\x11\x1aC\x20The\x20context\x20information\x20compiled\x20by\x20the\
    \x20`CompileContext`\x20method.\x20\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\
    \x04\xbc\x02\x02\x07\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xbc\x02\x08\x0c\
    \n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xbc\x02\x0f\x10\n\xe2\x02\n\x02\x04\
    \x0c\x12\x06\xc4\x02\0\xd8\x02\x01\x1a\xd3\x02\x20A\x20phrase\x20or\x20w\
    ord\x20that\x20is\x20to\x20be\x20compiled\x20into\x20context\x20informat\
    ion\x20that\x20can\x20be\n\x20later\x20used\x20to\x20improve\x20speech\
    \x20recognition\x20during\x20a\x20`Recognize`\x20or\n\x20`StreamingRecog\
    nize`\x20call.\x20Along\x20with\x20the\x20phrase\x20or\x20word\x20itself\
    ,\x20there\x20is\x20an\n\x20optional\x20boost\x20parameter\x20that\x20ca\
    n\x20be\x20used\x20to\x20boost\x20the\x20likelihood\x20of\x20the\n\x20ph\
    rase\x20or\x20word\x20in\x20the\x20recognition\x20output.\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\xc4\x02\x08\x15\n*\n\x04\x04\x0c\x02\0\x12\x04\xc6\
    \x02\x02\x13\x1a\x1c\x20The\x20actual\x20phrase\x20or\x20word.\n\n\r\n\
    \x05\x04\x0c\x02\0\x05\x12\x04\xc6\x02\x02\x08\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xc6\x02\t\r\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xc6\x02\x11\
    \x12\n\xfc\x07\n\x04\x04\x0c\x02\x01\x12\x04\xd7\x02\x02\x12\x1a\xed\x07\
    \x20This\x20is\x20an\x20optional\x20field.\x20The\x20boost\x20value\x20i\
    s\x20a\x20positive\x20number\x20which\x20is\n\x20used\x20to\x20increase\
    \x20the\x20probability\x20of\x20the\x20phrase\x20or\x20word\x20appearing\
    \x20in\x20the\n\x20output.\x20This\x20setting\x20can\x20be\x20used\x20to\
    \x20differentiate\x20between\x20similar\x20sounding\n\x20words,\x20with\
    \x20the\x20desired\x20word\x20given\x20a\x20bigger\x20boost\x20value.\n\
    \n\x20By\x20default,\x20all\x20phrases\x20or\x20words\x20are\x20given\
    \x20an\x20equal\x20probability\x20of\x201/N\n\x20(where\x20N\x20=\x20tot\
    al\x20number\x20of\x20phrases\x20or\x20words).\x20If\x20a\x20boost\x20va\
    lue\x20is\x20provided,\n\x20the\x20new\x20probability\x20is\x20(boost\
    \x20+\x201)\x20*\x201/N.\x20We\x20normalize\x20the\x20boosted\n\x20proba\
    bilities\x20for\x20all\x20the\x20phrases\x20or\x20words\x20so\x20that\
    \x20they\x20sum\x20to\x20one.\x20This\n\x20means\x20that\x20the\x20boost\
    \x20value\x20only\x20has\x20an\x20effect\x20if\x20there\x20are\x20relati\
    ve\n\x20differences\x20in\x20the\x20values\x20for\x20different\x20phrase\
    s\x20or\x20words.\x20That\x20is,\x20if\x20all\n\x20phrases\x20or\x20word\
    s\x20have\x20the\x20same\x20boost\x20value,\x20after\x20normalization\
    \x20they\x20will\n\x20all\x20still\x20have\x20the\x20same\x20probability\
    .\x20This\x20also\x20means\x20that\x20the\x20boost\x20value\n\x20can\x20\
    be\x20any\x20positive\x20value,\x20but\x20it\x20is\x20best\x20to\x20stic\
    k\x20between\x200\x20to\x2020.\n\n\x20Negative\x20values\x20are\x20not\
    \x20supported\x20and\x20will\x20be\x20treated\x20as\x200\x20values.\n\n\
    \r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xd7\x02\x02\x07\n\r\n\x05\x04\x0c\
    \x02\x01\x01\x12\x04\xd7\x02\x08\r\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \xd7\x02\x10\x11\n2\n\x02\x04\r\x12\x06\xdb\x02\0\xdd\x02\x01\x1a$\x20Au\
    dio\x20to\x20be\x20sent\x20to\x20the\x20recognizer\n\n\x0b\n\x03\x04\r\
    \x01\x12\x04\xdb\x02\x08\x18\n\x0c\n\x04\x04\r\x02\0\x12\x04\xdc\x02\x02\
    \x11\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xdc\x02\x02\x07\n\r\n\x05\x04\r\
    \x02\0\x01\x12\x04\xdc\x02\x08\x0c\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xdc\
    \x02\x0f\x10\n,\n\x02\x04\x0e\x12\x06\xe0\x02\0\xed\x02\x01\x1a\x1e\x20D\
    escription\x20of\x20a\x20Cubic\x20Model\n\n\x0b\n\x03\x04\x0e\x01\x12\
    \x04\xe0\x02\x08\r\n\xb9\x01\n\x04\x04\x0e\x02\0\x12\x04\xe4\x02\x02\x10\
    \x1a\xaa\x01\x20Unique\x20identifier\x20of\x20the\x20model.\x20\x20This\
    \x20identifier\x20is\x20used\x20to\x20choose\x20the\n\x20model\x20that\
    \x20should\x20be\x20used\x20for\x20recognition,\x20and\x20is\x20specifie\
    d\x20in\x20the\n\x20`RecognitionConfig`\x20message.\n\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\xe4\x02\x02\x08\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xe4\x02\t\x0b\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xe4\x02\x0e\x0f\n\xbc\
    \x01\n\x04\x04\x0e\x02\x01\x12\x04\xe9\x02\x02\x12\x1a\xad\x01\x20Model\
    \x20name.\x20\x20This\x20is\x20a\x20concise\x20name\x20describing\x20the\
    \x20model,\x20and\x20maybe\n\x20presented\x20to\x20the\x20end-user,\x20f\
    or\x20example,\x20to\x20help\x20choose\x20which\x20model\x20to\x20use\n\
    \x20for\x20their\x20recognition\x20task.\n\n\r\n\x05\x04\x0e\x02\x01\x05\
    \x12\x04\xe9\x02\x02\x08\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xe9\x02\t\
    \r\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xe9\x02\x10\x11\n\x20\n\x04\x04\
    \x0e\x02\x02\x12\x04\xec\x02\x02!\x1a\x12\x20Model\x20attributes\n\n\r\n\
    \x05\x04\x0e\x02\x02\x06\x12\x04\xec\x02\x02\x11\n\r\n\x05\x04\x0e\x02\
    \x02\x01\x12\x04\xec\x02\x12\x1c\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\
    \xec\x02\x1f\x20\n+\n\x02\x04\x0f\x12\x06\xf0\x02\0\xf6\x02\x01\x1a\x1d\
    \x20Attributes\x20of\x20a\x20Cubic\x20Model\n\n\x0b\n\x03\x04\x0f\x01\
    \x12\x04\xf0\x02\x08\x17\n8\n\x04\x04\x0f\x02\0\x12\x04\xf2\x02\x02\x19\
    \x1a*\x20Audio\x20sample\x20rate\x20supported\x20by\x20the\x20model\n\n\
    \r\n\x05\x04\x0f\x02\0\x05\x12\x04\xf2\x02\x02\x08\n\r\n\x05\x04\x0f\x02\
    \0\x01\x12\x04\xf2\x02\t\x14\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xf2\x02\
    \x17\x18\nE\n\x04\x04\x0f\x02\x01\x12\x04\xf5\x02\x02\x1f\x1a7\x20Attrib\
    utes\x20specifc\x20to\x20supporting\x20recognition\x20context.\n\n\r\n\
    \x05\x04\x0f\x02\x01\x06\x12\x04\xf5\x02\x02\r\n\r\n\x05\x04\x0f\x02\x01\
    \x01\x12\x04\xf5\x02\x0e\x1a\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xf5\
    \x02\x1d\x1e\nL\n\x02\x04\x10\x12\x06\xf9\x02\0\x83\x03\x01\x1a>\x20Mode\
    l\x20information\x20specifc\x20to\x20supporting\x20recognition\x20contex\
    t.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xf9\x02\x08\x13\n\xec\x01\n\x04\x04\
    \x10\x02\0\x12\x04\xfd\x02\x02\x1c\x1a\xdd\x01\x20If\x20this\x20is\x20se\
    t\x20to\x20true,\x20the\x20model\x20supports\x20taking\x20context\x20inf\
    ormation\x20into\n\x20account\x20to\x20aid\x20speech\x20recognition.\x20\
    The\x20information\x20may\x20be\x20sent\x20with\x20with\n\x20recognition\
    \x20requests\x20via\x20RecognitionContext\x20inside\x20RecognitionConfig\
    .\n\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xfd\x02\x02\x06\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xfd\x02\x07\x17\n\r\n\x05\x04\x10\x02\0\x03\x12\
    \x04\xfd\x02\x1a\x1b\n\xf2\x01\n\x04\x04\x10\x02\x01\x12\x04\x82\x03\x02\
    -\x1a\xe3\x01\x20A\x20list\x20of\x20tokens\x20(e.g\x20\"name\",\x20\"air\
    port\"\x20etc.)\x20that\x20serve\x20has\x20placeholders\n\x20in\x20the\
    \x20model\x20where\x20a\x20client\x20provided\x20list\x20of\x20phrases\
    \x20or\x20words\x20may\x20be\x20used\n\x20to\x20aid\x20speech\x20recogni\
    tion\x20and\x20produce\x20the\x20exact\x20desired\x20recognition\x20outp\
    ut.\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\x82\x03\x02\n\n\r\n\x05\x04\
    \x10\x02\x01\x05\x12\x04\x82\x03\x0b\x11\n\r\n\x05\x04\x10\x02\x01\x01\
    \x12\x04\x82\x03\x12(\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x82\x03+,\nI\
    \n\x02\x04\x11\x12\x06\x86\x03\0\x9b\x03\x01\x1a;\x20A\x20recognition\
    \x20result\x20corresponding\x20to\x20a\x20portion\x20of\x20audio.\n\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\x86\x03\x08\x19\nE\n\x04\x04\x11\x02\0\
    \x12\x04\x88\x03\x023\x1a7\x20An\x20n-best\x20list\x20of\x20recognition\
    \x20hypotheses\x20alternatives\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x88\
    \x03\x02\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\x88\x03\x0b!\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\x88\x03\".\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\x88\x0312\n\xfa\x02\n\x04\x04\x11\x02\x01\x12\x04\x90\x03\x02\x16\
    \x1a\xeb\x02\x20If\x20this\x20is\x20set\x20to\x20true,\x20it\x20denotes\
    \x20that\x20the\x20result\x20is\x20an\x20interim\x20partial\n\x20result,\
    \x20and\x20could\x20change\x20after\x20more\x20audio\x20is\x20processed.\
    \x20\x20If\x20unset,\x20or\x20set\n\x20to\x20false,\x20it\x20denotes\x20\
    that\x20this\x20is\x20a\x20final\x20result\x20and\x20will\x20not\x20chan\
    ge.\n\n\x20Servers\x20are\x20not\x20required\x20to\x20implement\x20suppo\
    rt\x20for\x20returning\x20partial\n\x20results,\x20and\x20clients\x20sho\
    uld\x20generally\x20not\x20depend\x20on\x20their\x20availability.\n\n\r\
    \n\x05\x04\x11\x02\x01\x05\x12\x04\x90\x03\x02\x06\n\r\n\x05\x04\x11\x02\
    \x01\x01\x12\x04\x90\x03\x07\x11\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\
    \x90\x03\x14\x15\n\xb0\x01\n\x04\x04\x11\x02\x02\x12\x04\x95\x03\x02'\
    \x1a\xa1\x01\x20If\x20`enable_confusion_network`\x20was\x20set\x20to\x20\
    true\x20in\x20the\x20`RecognitionConfig`,\n\x20and\x20if\x20the\x20model\
    \x20supports\x20it,\x20a\x20confusion\x20network\x20will\x20be\x20availa\
    ble\x20in\x20the\n\x20results.\n\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\
    \x95\x03\x02\x1d\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\x95\x03\x1e\"\n\r\
    \n\x05\x04\x11\x02\x02\x03\x12\x04\x95\x03%&\n\x92\x01\n\x04\x04\x11\x02\
    \x03\x12\x04\x99\x03\x02\x1b\x1a\x83\x01\x20Channel\x20of\x20the\x20audi\
    o\x20file\x20that\x20this\x20result\x20was\x20transcribed\x20from.\x20\
    \x20For\x20a\n\x20mono\x20file,\x20or\x20RAW_LINEAR16\x20input,\x20this\
    \x20will\x20be\x20set\x20to\x200.\n\n\r\n\x05\x04\x11\x02\x03\x05\x12\
    \x04\x99\x03\x02\x08\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\x99\x03\t\x16\
    \n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\x99\x03\x19\x1a\n(\n\x02\x04\x12\
    \x12\x06\x9e\x03\0\xcb\x03\x01\x1a\x1a\x20A\x20recognition\x20hypothesis\
    \n\n\x0b\n\x03\x04\x12\x01\x12\x04\x9e\x03\x08\x1e\n\xf5\x03\n\x04\x04\
    \x12\x02\0\x12\x04\xa9\x03\x02\x18\x1a\xe6\x03\x20Text\x20representing\
    \x20the\x20transcription\x20of\x20the\x20words\x20that\x20the\x20user\
    \x20spoke.\n\n\x20The\x20transcript\x20will\x20be\x20formatted\x20accord\
    ing\x20to\x20the\x20servers\x20formatting\n\x20configuration.\x20If\x20y\
    ou\x20want\x20the\x20raw\x20transcript,\x20please\x20see\x20the\x20field\
    \n\x20`raw_transcript`.\x20\x20If\x20the\x20server\x20is\x20configured\
    \x20to\x20not\x20use\x20any\x20formatting,\n\x20then\x20this\x20field\
    \x20will\x20contain\x20the\x20raw\x20transcript.\n\n\x20As\x20an\x20exam\
    ple,\x20if\x20the\x20spoken\x20utterance\x20was\x20\"four\x20people\",\
    \x20and\x20the\n\x20server\x20was\x20configured\x20to\x20format\x20numbe\
    rs,\x20this\x20field\x20would\x20be\x20set\x20to\n\x20\"4\x20people\".\n\
    \n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xa9\x03\x02\x08\n\r\n\x05\x04\x12\
    \x02\0\x01\x12\x04\xa9\x03\t\x13\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xa9\
    \x03\x16\x17\n\xc8\x03\n\x04\x04\x12\x02\x01\x12\x04\xb3\x03\x02\x1c\x1a\
    \xb9\x03\x20Text\x20representing\x20the\x20transcription\x20of\x20the\
    \x20words\x20that\x20the\x20user\x20spoke,\n\x20without\x20any\x20format\
    ting.\x20\x20This\x20field\x20will\x20be\x20populated\x20only\x20the\x20\
    config\n\x20`RecognitionConfig.enable_raw_transcript`\x20is\x20set\x20to\
    \x20true.\x20Otherwise\x20this\n\x20field\x20will\x20be\x20an\x20empty\
    \x20string.\x20If\x20you\x20want\x20the\x20formatted\x20transcript,\x20p\
    lease\n\x20see\x20the\x20field\x20`transcript`.\n\n\x20As\x20an\x20examp\
    le,\x20if\x20the\x20spoken\x20utterance\x20was\x20`here\x20are\x20four\
    \x20words`,\n\x20this\x20field\x20would\x20be\x20set\x20to\x20\"HERE\x20\
    ARE\x20FOUR\x20WORDS\".\n\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xb3\x03\
    \x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xb3\x03\t\x17\n\r\n\x05\
    \x04\x12\x02\x01\x03\x12\x04\xb3\x03\x1a\x1b\n\x81\x01\n\x04\x04\x12\x02\
    \x02\x12\x04\xb7\x03\x02\x18\x1as\x20Confidence\x20estimate\x20between\
    \x200\x20and\x201.\x20A\x20higher\x20number\x20represents\x20a\x20higher\
    \n\x20likelihood\x20of\x20the\x20output\x20being\x20correct.\n\n\r\n\x05\
    \x04\x12\x02\x02\x05\x12\x04\xb7\x03\x02\x08\n\r\n\x05\x04\x12\x02\x02\
    \x01\x12\x04\xb7\x03\t\x13\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xb7\x03\
    \x16\x17\n\xe9\x01\n\x04\x04\x12\x02\x03\x12\x04\xbc\x03\x02\x1e\x1a\xda\
    \x01\x20A\x20list\x20of\x20word-specific\x20information\x20for\x20each\
    \x20recognized\x20word\x20in\x20the\n\x20`transcript`\x20field.\x20This\
    \x20is\x20available\x20only\x20if\x20`enable_word_confidence`\x20or\n\
    \x20`enable_word_time_offsets`\x20was\x20set\x20to\x20`true`\x20in\x20th\
    e\x20`RecognitionConfig`.\n\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xbc\
    \x03\x02\n\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\xbc\x03\x0b\x13\n\r\n\
    \x05\x04\x12\x02\x03\x01\x12\x04\xbc\x03\x14\x19\n\r\n\x05\x04\x12\x02\
    \x03\x03\x12\x04\xbc\x03\x1c\x1d\n\xa2\x02\n\x04\x04\x12\x02\x04\x12\x04\
    \xc2\x03\x02\"\x1a\x93\x02\x20A\x20list\x20of\x20word-specific\x20inform\
    ation\x20for\x20each\x20recognized\x20word\x20in\x20the\n\x20`raw_transc\
    ript`\x20field.\x20This\x20is\x20available\x20only\x20if\x20`enable_word\
    _confidence`\n\x20or\x20`enable_word_time_offsets`\x20was\x20set\x20to\
    \x20`true`\x20_and_\n\x20`enable_raw_transcript`\x20is\x20also\x20set\
    \x20to\x20`true`\x20in\x20the\x20`RecognitionConfig`.\n\n\r\n\x05\x04\
    \x12\x02\x04\x04\x12\x04\xc2\x03\x02\n\n\r\n\x05\x04\x12\x02\x04\x06\x12\
    \x04\xc2\x03\x0b\x13\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xc2\x03\x14\
    \x1d\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\xc2\x03\x20!\n\x8c\x01\n\x04\
    \x04\x12\x02\x05\x12\x04\xc6\x03\x02*\x1a~\x20Time\x20offset\x20relative\
    \x20to\x20the\x20beginning\x20of\x20audio\x20received\x20by\x20the\x20re\
    cognizer\n\x20and\x20corresponding\x20to\x20the\x20start\x20of\x20this\
    \x20utterance.\n\n\r\n\x05\x04\x12\x02\x05\x06\x12\x04\xc6\x03\x02\x1a\n\
    \r\n\x05\x04\x12\x02\x05\x01\x12\x04\xc6\x03\x1b%\n\r\n\x05\x04\x12\x02\
    \x05\x03\x12\x04\xc6\x03()\nF\n\x04\x04\x12\x02\x06\x12\x04\xc9\x03\x02(\
    \x1a8\x20Duration\x20of\x20the\x20current\x20utterance\x20in\x20the\x20s\
    poken\x20audio.\n\n\r\n\x05\x04\x12\x02\x06\x06\x12\x04\xc9\x03\x02\x1a\
    \n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\xc9\x03\x1b#\n\r\n\x05\x04\x12\
    \x02\x06\x03\x12\x04\xc9\x03&'\n>\n\x02\x04\x13\x12\x06\xce\x03\0\xdc\
    \x03\x01\x1a0\x20Word-specific\x20information\x20for\x20recognized\x20wo\
    rds\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xce\x03\x08\x10\n+\n\x04\x04\x13\
    \x02\0\x12\x04\xd0\x03\x02\x12\x1a\x1d\x20The\x20actual\x20word\x20in\
    \x20the\x20text\n\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xd0\x03\x02\x08\n\
    \r\n\x05\x04\x13\x02\0\x01\x12\x04\xd0\x03\t\r\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\xd0\x03\x10\x11\n\x8d\x01\n\x04\x04\x13\x02\x01\x12\x04\xd4\
    \x03\x02\x18\x1a\x7f\x20Confidence\x20estimate\x20between\x200\x20and\
    \x201.\x20\x20A\x20higher\x20number\x20represents\x20a\n\x20higher\x20li\
    kelihood\x20that\x20the\x20word\x20was\x20correctly\x20recognized.\n\n\r\
    \n\x05\x04\x13\x02\x01\x05\x12\x04\xd4\x03\x02\x08\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\xd4\x03\t\x13\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xd4\
    \x03\x16\x17\n\x8f\x01\n\x04\x04\x13\x02\x02\x12\x04\xd8\x03\x02*\x1a\
    \x80\x01\x20Time\x20offset\x20relative\x20to\x20the\x20beginning\x20of\
    \x20audio\x20received\x20by\x20the\x20recognizer\n\x20and\x20correspondi\
    ng\x20to\x20the\x20start\x20of\x20this\x20spoken\x20word.\n\n\r\n\x05\
    \x04\x13\x02\x02\x06\x12\x04\xd8\x03\x02\x1a\n\r\n\x05\x04\x13\x02\x02\
    \x01\x12\x04\xd8\x03\x1b%\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xd8\x03(\
    )\nA\n\x04\x04\x13\x02\x03\x12\x04\xdb\x03\x02(\x1a3\x20Duration\x20of\
    \x20the\x20current\x20word\x20in\x20the\x20spoken\x20audio.\n\n\r\n\x05\
    \x04\x13\x02\x03\x06\x12\x04\xdb\x03\x02\x1a\n\r\n\x05\x04\x13\x02\x03\
    \x01\x12\x04\xdb\x03\x1b#\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xdb\x03&\
    '\n7\n\x02\x04\x14\x12\x06\xdf\x03\0\xe1\x03\x01\x1a)\x20Confusion\x20ne\
    twork\x20in\x20recognition\x20output\n\n\x0b\n\x03\x04\x14\x01\x12\x04\
    \xdf\x03\x08#\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xe0\x03\x02*\n\r\n\x05\
    \x04\x14\x02\0\x04\x12\x04\xe0\x03\x02\n\n\r\n\x05\x04\x14\x02\0\x06\x12\
    \x04\xe0\x03\x0b\x1f\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xe0\x03\x20%\n\
    \r\n\x05\x04\x14\x02\0\x03\x12\x04\xe0\x03()\n1\n\x02\x04\x15\x12\x06\
    \xe4\x03\0\xee\x03\x01\x1a#\x20A\x20Link\x20inside\x20a\x20confusion\x20\
    network\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xe4\x03\x08\x1c\n\x86\x01\n\
    \x04\x04\x15\x02\0\x12\x04\xe7\x03\x02*\x1ax\x20Time\x20offset\x20relati\
    ve\x20to\x20the\x20beginning\x20of\x20audio\x20received\x20by\x20the\x20\
    recognizer\n\x20and\x20corresponding\x20to\x20the\x20start\x20of\x20this\
    \x20link\n\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\xe7\x03\x02\x1a\n\r\n\x05\
    \x04\x15\x02\0\x01\x12\x04\xe7\x03\x1b%\n\r\n\x05\x04\x15\x02\0\x03\x12\
    \x04\xe7\x03()\nE\n\x04\x04\x15\x02\x01\x12\x04\xea\x03\x02(\x1a7\x20Dur\
    ation\x20of\x20the\x20current\x20link\x20in\x20the\x20confusion\x20netwo\
    rk\n\n\r\n\x05\x04\x15\x02\x01\x06\x12\x04\xea\x03\x02\x1a\n\r\n\x05\x04\
    \x15\x02\x01\x01\x12\x04\xea\x03\x1b#\n\r\n\x05\x04\x15\x02\x01\x03\x12\
    \x04\xea\x03&'\n&\n\x04\x04\x15\x02\x02\x12\x04\xed\x03\x02(\x1a\x18\x20\
    Arcs\x20between\x20this\x20link\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\
    \xed\x03\x02\n\n\r\n\x05\x04\x15\x02\x02\x06\x12\x04\xed\x03\x0b\x1e\n\r\
    \n\x05\x04\x15\x02\x02\x01\x12\x04\xed\x03\x1f#\n\r\n\x05\x04\x15\x02\
    \x02\x03\x12\x04\xed\x03&'\n6\n\x02\x04\x16\x12\x06\xf1\x03\0\xf8\x03\
    \x01\x1a(\x20An\x20Arc\x20inside\x20a\x20Confusion\x20Network\x20Link\n\
    \n\x0b\n\x03\x04\x16\x01\x12\x04\xf1\x03\x08\x1b\n1\n\x04\x04\x16\x02\0\
    \x12\x04\xf3\x03\x02\x12\x1a#\x20Word\x20in\x20the\x20recognized\x20tran\
    script\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xf3\x03\x02\x08\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\xf3\x03\t\r\n\r\n\x05\x04\x16\x02\0\x03\x12\
    \x04\xf3\x03\x10\x11\n\x8d\x01\n\x04\x04\x16\x02\x01\x12\x04\xf7\x03\x02\
    \x18\x1a\x7f\x20Confidence\x20estimate\x20between\x200\x20and\x201.\x20\
    \x20A\x20higher\x20number\x20represents\x20a\x20higher\n\x20likelihood\
    \x20that\x20the\x20word\x20was\x20correctly\x20recognized.\n\n\r\n\x05\
    \x04\x16\x02\x01\x05\x12\x04\xf7\x03\x02\x08\n\r\n\x05\x04\x16\x02\x01\
    \x01\x12\x04\xf7\x03\t\x13\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xf7\x03\
    \x16\x17b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
