// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cubic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (2019) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The top-level message sent by the client for the `ListModels` method.
public struct Cobaltspeech_Cubic_ListModelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The top-level message sent by the client for the `Recognize` method.  Both
/// the `RecognitionConfig` and `RecognitionAudio` fields are required.  The
/// entire audio data must be sent in one request.  If your audio data is larger,
/// please use the `StreamingRecognize` call..
public struct Cobaltspeech_Cubic_RecognizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Provides configuration to create the recognizer.
  public var config: Cobaltspeech_Cubic_RecognitionConfig {
    get {return _config ?? Cobaltspeech_Cubic_RecognitionConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// The audio data to be recognized
  public var audio: Cobaltspeech_Cubic_RecognitionAudio {
    get {return _audio ?? Cobaltspeech_Cubic_RecognitionAudio()}
    set {_audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return self._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {self._audio = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Cobaltspeech_Cubic_RecognitionConfig? = nil
  fileprivate var _audio: Cobaltspeech_Cubic_RecognitionAudio? = nil
}

/// The top-level message sent by the client for the `StreamingRecognize`
/// request.  Multiple `StreamingRecognizeRequest` messages are sent. The first
/// message must contain a `RecognitionConfig` message only, and all subsequent
/// messages must contain `RecognitionAudio` only.  All `RecognitionAudio`
/// messages must contain non-empty audio.  If audio content is empty, the server
/// may interpret it as end of stream and stop accepting any further messages.
public struct Cobaltspeech_Cubic_StreamingRecognizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Cobaltspeech_Cubic_StreamingRecognizeRequest.OneOf_Request? = nil

  public var config: Cobaltspeech_Cubic_RecognitionConfig {
    get {
      if case .config(let v)? = request {return v}
      return Cobaltspeech_Cubic_RecognitionConfig()
    }
    set {request = .config(newValue)}
  }

  public var audio: Cobaltspeech_Cubic_RecognitionAudio {
    get {
      if case .audio(let v)? = request {return v}
      return Cobaltspeech_Cubic_RecognitionAudio()
    }
    set {request = .audio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case config(Cobaltspeech_Cubic_RecognitionConfig)
    case audio(Cobaltspeech_Cubic_RecognitionAudio)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Cubic_StreamingRecognizeRequest.OneOf_Request, rhs: Cobaltspeech_Cubic_StreamingRecognizeRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.config, .config): return {
        guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The top-level message sent by the client for the `CompileContext` request. It
/// contains a list of phrases or words, paired with a context token included in
/// the model being used. The token specifies a category such as "menu_item",
/// "airport", "contact", "product_name" etc. The context token is used to
/// determine the places in the recognition output where the provided list of
/// phrases or words may appear. The allowed context tokens for a given model can
/// be found in its `ModelAttributes.ContextInfo` obtained via the `ListModels`
/// method.
public struct Cobaltspeech_Cubic_CompileContextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the model to compile the context information for. The
  /// model chosen needs to support context which can be verified by checking its
  /// `ModelAttributes.ContextInfo` obtained via `ListModels`.
  public var modelID: String = String()

  /// The token that is associated with the provided list of phrases or words
  /// (e.g "menu_item", "airport" etc.). Must be one of the tokens included in
  /// the model being used, which can be retrieved by calling the `ListModels`
  /// method.
  public var token: String = String()

  /// List of phrases and/or words to be compiled.
  public var phrases: [Cobaltspeech_Cubic_ContextPhrase] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message sent by the server for the `Version` method.
public struct Cobaltspeech_Cubic_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// version of the cubic library handling the recognition
  public var cubic: String = String()

  /// version of the server handling these requests
  public var server: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message returned to the client by the `ListModels` method.
public struct Cobaltspeech_Cubic_ListModelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of models available for use that match the request.
  public var models: [Cobaltspeech_Cubic_Model] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Collection of sequence of recognition results in a portion of audio.  When
/// transcribing a single audio channel (e.g. RAW_LINEAR16 input, or a mono
/// file), results will be ordered chronologically.  When transcribing multiple
/// channels, the results of all channels will be interleaved.  Results of each
/// individual channel will be chronological.  No such promise is made for the
/// ordering of results of different channels, as results are returned for each
/// channel individually as soon as they are ready.
public struct Cobaltspeech_Cubic_RecognitionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var results: [Cobaltspeech_Cubic_RecognitionResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message returned to the client by the `CompileContext` method.
public struct Cobaltspeech_Cubic_CompileContextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Context information in a compact form that is efficient for use in
  /// subsequent recognition requests. The size of the compiled form will depend
  /// on the amount of text that was sent for compilation. For 1000 words it's
  /// generally less than 100 kilobytes.
  public var context: Cobaltspeech_Cubic_CompiledContext {
    get {return _context ?? Cobaltspeech_Cubic_CompiledContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _context: Cobaltspeech_Cubic_CompiledContext? = nil
}

/// Configuration for setting up a Recognizer
public struct Cobaltspeech_Cubic_RecognitionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the model to use, as obtained from a `Model` message.
  public var modelID: String = String()

  /// Encoding of audio data sent/streamed through the `RecognitionAudio`
  /// messages.  For encodings like WAV/MP3 that have headers, the headers are
  /// expected to be sent at the beginning of the stream, not in every
  /// `RecognitionAudio` message.
  ///
  /// If not specified, the default encoding is RAW_LINEAR16.
  ///
  /// Depending on how they are configured, server instances of this service may
  /// not support all the encodings enumerated above. They are always required to
  /// accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
  /// available on the server being used, the recognition request will result in
  /// an appropriate error message.
  public var audioEncoding: Cobaltspeech_Cubic_RecognitionConfig.Encoding = .rawLinear16

  /// Idle Timeout of the created Recognizer.  If no audio data is received by
  /// the recognizer for this duration, ongoing rpc calls will result in an
  /// error, the recognizer will be destroyed and thus more audio may not be sent
  /// to the same recognizer.  The server may impose a limit on the maximum idle
  /// timeout that can be specified, and if the value in this message exceeds
  /// that serverside value, creating of the recognizer will fail with an error.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return self._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {self._idleTimeout = nil}

  /// This is an optional field.  If this is set to true, each result will
  /// include a list of words and the start time offset (timestamp) and the
  /// duration for each of those words.  If set to `false`, no word-level
  /// timestamps will be returned.  The default is `false`.
  public var enableWordTimeOffsets: Bool = false

  /// This is an optional field.  If this is set to true, each result will
  /// include a list of words and the confidence for those words.  If `false`, no
  /// word-level confidence information is returned.  The default is `false`.
  public var enableWordConfidence: Bool = false

  /// This is an optional field.  If this is set to true, the field
  /// `RecognitionAlternative.raw_transcript` will be populated with the raw
  /// transcripts output from the recognizer will be exposed without any
  /// formatting rules applied.  If this is set to false, that field will not
  /// be set in the results.  The RecognitionAlternative.transcript will
  /// always be populated with text formatted according to the server's settings.
  public var enableRawTranscript: Bool = false

  /// This is an optional field.  If this is set to true, the results will
  /// include a confusion network.  If set to `false`, no confusion network will
  /// be returned.  The default is `false`.  If the model being used does not
  /// support a confusion network, results may be returned without a confusion
  /// network available.  If this field is set to `true`, then
  /// `enable_raw_transcript` is also forced to be true.
  public var enableConfusionNetwork: Bool = false

  /// This is an optional field.  If the audio has multiple channels, this field
  /// should be configured with the list of channel indices that should be
  /// transcribed.  Channels are 0-indexed.
  ///
  /// Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
  ///
  /// If this field is not set, a mono file will be assumed by default and only
  /// channel-0 will be transcribed even if the file actually has additional
  /// channels.
  ///
  /// Channels that are present in the audio may be omitted, but it is an error
  /// to include a channel index in this field that is not present in the audio.
  /// Channels may be listed in any order but the same index may not be repeated
  /// in this list.
  ///
  /// BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
  public var audioChannels: [UInt32] = []

  /// This is an optional field.  If there is any metadata associated with the
  /// audio being sent, use this field to provide it to cubic.  The server may
  /// record this metadata when processing the request.  The server does not use
  /// this field for any other purpose.
  public var metadata: Cobaltspeech_Cubic_RecognitionMetadata {
    get {return _metadata ?? Cobaltspeech_Cubic_RecognitionMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// This is an optional field for providing any additional context information
  /// that may aid speech recognition.  This can also be used to add
  /// out-of-vocabulary words to the model or boost recognition of specific
  /// proper names or commands. Context information must be pre-compiled via the
  /// `CompileContext()` method.
  public var context: Cobaltspeech_Cubic_RecognitionContext {
    get {return _context ?? Cobaltspeech_Cubic_RecognitionContext()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The encoding of the audio data to be sent for recognition.
  ///
  /// For best results, the audio source should be captured and transmitted using
  /// the RAW_LINEAR16 encoding.
  public enum Encoding: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Raw (headerless) Uncompressed 16-bit signed little endian samples (linear
    /// PCM), single channel, sampled at the rate expected by the chosen `Model`.
    case rawLinear16 // = 0

    /// WAV (data with RIFF headers), with data sampled at a rate equal to or
    /// higher than the sample rate expected by the chosen Model.
    case wav // = 1

    /// MP3 data, sampled at a rate equal to or higher than the sampling rate
    /// expected by the chosen Model.
    case mp3 // = 2

    /// FLAC data, sampled at a rate equal to or higher than the sample rate
    /// expected by the chosen Model.
    case flac // = 3

    /// VOX data (Dialogic ADPCM), sampled at 8 KHz.
    case vox8000 // = 4

    /// μ-law (8-bit) encoded RAW data, single channel, sampled at 8 KHz.
    case ulaw8000 // = 5

    /// A-law (8-bit) encoded RAW data, single channel, sampled at 8 KHz.
    case alaw8000 // = 6

    /// Opus (16-bit) encoded RAW data, sampled at a rate equal to or higher than the sample rate expected by the chosen Model.
    case opus // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .rawLinear16
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .rawLinear16
      case 1: self = .wav
      case 2: self = .mp3
      case 3: self = .flac
      case 4: self = .vox8000
      case 5: self = .ulaw8000
      case 6: self = .alaw8000
      case 7: self = .opus
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .rawLinear16: return 0
      case .wav: return 1
      case .mp3: return 2
      case .flac: return 3
      case .vox8000: return 4
      case .ulaw8000: return 5
      case .alaw8000: return 6
      case .opus: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _metadata: Cobaltspeech_Cubic_RecognitionMetadata? = nil
  fileprivate var _context: Cobaltspeech_Cubic_RecognitionContext? = nil
}

#if swift(>=4.2)

extension Cobaltspeech_Cubic_RecognitionConfig.Encoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cobaltspeech_Cubic_RecognitionConfig.Encoding] = [
    .rawLinear16,
    .wav,
    .mp3,
    .flac,
    .vox8000,
    .ulaw8000,
    .alaw8000,
    .opus,
  ]
}

#endif  // swift(>=4.2)

/// Metadata associated with the audio to be recognized.
public struct Cobaltspeech_Cubic_RecognitionMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Any custom metadata that the client wants to associate with the recording.
  /// This could be a simple string (e.g. a tracing ID) or structured data
  /// (e.g. JSON)
  public var customMetadata: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of additional context information that may aid speech
/// recognition.  This can be used to add out-of-vocabulary words to  
/// the model or to boost recognition of specific proper names or commands. 
public struct Cobaltspeech_Cubic_RecognitionContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of compiled context information, with each entry being compiled from a
  /// list of words or phrases using the `CompileContext` method.
  public var compiled: [Cobaltspeech_Cubic_CompiledContext] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Context information in a compact form that is efficient for use in subsequent
/// recognition requests. The size of the compiled form will depend on the amount
/// of text that was sent for compilation. For 1000 words it's generally less
/// than 100 kilobytes.
public struct Cobaltspeech_Cubic_CompiledContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The context information compiled by the `CompileContext` method. 
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A phrase or word that is to be compiled into context information that can be
/// later used to improve speech recognition during a `Recognize` or
/// `StreamingRecognize` call. Along with the phrase or word itself, there is an
/// optional boost parameter that can be used to boost the likelihood of the
/// phrase or word in the recognition output.
public struct Cobaltspeech_Cubic_ContextPhrase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actual phrase or word.
  public var text: String = String()

  /// This is an optional field. The boost value is a positive number which is
  /// used to increase the probability of the phrase or word appearing in the
  /// output. This setting can be used to differentiate between similar sounding
  /// words, with the desired word given a bigger boost value.
  ///
  /// By default, all phrases or words are given an equal probability of 1/N
  /// (where N = total number of phrases or words). If a boost value is provided,
  /// the new probability is (boost + 1) * 1/N. We normalize the boosted
  /// probabilities for all the phrases or words so that they sum to one. This
  /// means that the boost value only has an effect if there are relative
  /// differences in the values for different phrases or words. That is, if all
  /// phrases or words have the same boost value, after normalization they will
  /// all still have the same probability. This also means that the boost value
  /// can be any positive value, but it is best to stick between 0 to 20.
  ///
  /// Negative values are not supported and will be treated as 0 values.
  public var boost: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Audio to be sent to the recognizer
public struct Cobaltspeech_Cubic_RecognitionAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Description of a Cubic Model
public struct Cobaltspeech_Cubic_Model {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the model.  This identifier is used to choose the
  /// model that should be used for recognition, and is specified in the
  /// `RecognitionConfig` message.
  public var id: String = String()

  /// Model name.  This is a concise name describing the model, and maybe
  /// presented to the end-user, for example, to help choose which model to use
  /// for their recognition task.
  public var name: String = String()

  /// Model attributes
  public var attributes: Cobaltspeech_Cubic_ModelAttributes {
    get {return _attributes ?? Cobaltspeech_Cubic_ModelAttributes()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  public var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  public mutating func clearAttributes() {self._attributes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attributes: Cobaltspeech_Cubic_ModelAttributes? = nil
}

/// Attributes of a Cubic Model
public struct Cobaltspeech_Cubic_ModelAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Audio sample rate supported by the model
  public var sampleRate: UInt32 = 0

  /// Attributes specifc to supporting recognition context.
  public var contextInfo: Cobaltspeech_Cubic_ContextInfo {
    get {return _contextInfo ?? Cobaltspeech_Cubic_ContextInfo()}
    set {_contextInfo = newValue}
  }
  /// Returns true if `contextInfo` has been explicitly set.
  public var hasContextInfo: Bool {return self._contextInfo != nil}
  /// Clears the value of `contextInfo`. Subsequent reads from it will return its default value.
  public mutating func clearContextInfo() {self._contextInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contextInfo: Cobaltspeech_Cubic_ContextInfo? = nil
}

/// Model information specifc to supporting recognition context.
public struct Cobaltspeech_Cubic_ContextInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If this is set to true, the model supports taking context information into
  /// account to aid speech recognition. The information may be sent with with
  /// recognition requests via RecognitionContext inside RecognitionConfig.
  public var supportsContext: Bool = false

  /// A list of tokens (e.g "name", "airport" etc.) that serve has placeholders
  /// in the model where a client provided list of phrases or words may be used
  /// to aid speech recognition and produce the exact desired recognition output.
  public var allowedContextTokens: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A recognition result corresponding to a portion of audio.
public struct Cobaltspeech_Cubic_RecognitionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An n-best list of recognition hypotheses alternatives
  public var alternatives: [Cobaltspeech_Cubic_RecognitionAlternative] = []

  /// If this is set to true, it denotes that the result is an interim partial
  /// result, and could change after more audio is processed.  If unset, or set
  /// to false, it denotes that this is a final result and will not change.
  ///
  /// Servers are not required to implement support for returning partial
  /// results, and clients should generally not depend on their availability.
  public var isPartial: Bool = false

  /// If `enable_confusion_network` was set to true in the `RecognitionConfig`,
  /// and if the model supports it, a confusion network will be available in the
  /// results.
  public var cnet: Cobaltspeech_Cubic_RecognitionConfusionNetwork {
    get {return _cnet ?? Cobaltspeech_Cubic_RecognitionConfusionNetwork()}
    set {_cnet = newValue}
  }
  /// Returns true if `cnet` has been explicitly set.
  public var hasCnet: Bool {return self._cnet != nil}
  /// Clears the value of `cnet`. Subsequent reads from it will return its default value.
  public mutating func clearCnet() {self._cnet = nil}

  /// Channel of the audio file that this result was transcribed from.  For a
  /// mono file, or RAW_LINEAR16 input, this will be set to 0.
  public var audioChannel: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cnet: Cobaltspeech_Cubic_RecognitionConfusionNetwork? = nil
}

/// A recognition hypothesis
public struct Cobaltspeech_Cubic_RecognitionAlternative {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text representing the transcription of the words that the user spoke.
  ///
  /// The transcript will be formatted according to the servers formatting
  /// configuration. If you want the raw transcript, please see the field
  /// `raw_transcript`.  If the server is configured to not use any formatting,
  /// then this field will contain the raw transcript.
  ///
  /// As an example, if the spoken utterance was "four people", and the
  /// server was configured to format numbers, this field would be set to
  /// "4 people".
  public var transcript: String = String()

  /// Text representing the transcription of the words that the user spoke,
  /// without any formatting.  This field will be populated only the config
  /// `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
  /// field will be an empty string. If you want the formatted transcript, please
  /// see the field `transcript`.
  ///
  /// As an example, if the spoken utterance was `here are four words`,
  /// this field would be set to "HERE ARE FOUR WORDS".
  public var rawTranscript: String = String()

  /// Confidence estimate between 0 and 1. A higher number represents a higher
  /// likelihood of the output being correct.
  public var confidence: Double = 0

  /// A list of word-specific information for each recognized word in the
  /// `transcript` field. This is available only if `enable_word_confidence` or
  /// `enable_word_time_offsets` was set to `true` in the `RecognitionConfig`.
  public var words: [Cobaltspeech_Cubic_WordInfo] = []

  /// A list of word-specific information for each recognized word in the
  /// `raw_transcript` field. This is available only if `enable_word_confidence`
  /// or `enable_word_time_offsets` was set to `true` _and_
  /// `enable_raw_transcript` is also set to `true` in the `RecognitionConfig`.
  public var rawWords: [Cobaltspeech_Cubic_WordInfo] = []

  /// Time offset relative to the beginning of audio received by the recognizer
  /// and corresponding to the start of this utterance.
  public var startTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Duration of the current utterance in the spoken audio.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Word-specific information for recognized words
public struct Cobaltspeech_Cubic_WordInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actual word in the text
  public var word: String = String()

  /// Confidence estimate between 0 and 1.  A higher number represents a
  /// higher likelihood that the word was correctly recognized.
  public var confidence: Double = 0

  /// Time offset relative to the beginning of audio received by the recognizer
  /// and corresponding to the start of this spoken word.
  public var startTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Duration of the current word in the spoken audio.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Confusion network in recognition output
public struct Cobaltspeech_Cubic_RecognitionConfusionNetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var links: [Cobaltspeech_Cubic_ConfusionNetworkLink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Link inside a confusion network
public struct Cobaltspeech_Cubic_ConfusionNetworkLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time offset relative to the beginning of audio received by the recognizer
  /// and corresponding to the start of this link
  public var startTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Duration of the current link in the confusion network
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// Arcs between this link
  public var arcs: [Cobaltspeech_Cubic_ConfusionNetworkArc] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// An Arc inside a Confusion Network Link
public struct Cobaltspeech_Cubic_ConfusionNetworkArc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Word in the recognized transcript
  public var word: String = String()

  /// Confidence estimate between 0 and 1.  A higher number represents a higher
  /// likelihood that the word was correctly recognized.
  public var confidence: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cobaltspeech.cubic"

extension Cobaltspeech_Cubic_ListModelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ListModelsRequest, rhs: Cobaltspeech_Cubic_ListModelsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognizeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognizeRequest, rhs: Cobaltspeech_Cubic_RecognizeRequest) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_StreamingRecognizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingRecognizeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cobaltspeech_Cubic_RecognitionConfig?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .config(v)
        }
      }()
      case 2: try {
        var v: Cobaltspeech_Cubic_RecognitionAudio?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .audio(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .config?: try {
      guard case .config(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_StreamingRecognizeRequest, rhs: Cobaltspeech_Cubic_StreamingRecognizeRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_CompileContextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompileContextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_id"),
    2: .same(proto: "token"),
    3: .same(proto: "phrases"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.phrases) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    if !self.phrases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phrases, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_CompileContextRequest, rhs: Cobaltspeech_Cubic_CompileContextRequest) -> Bool {
    if lhs.modelID != rhs.modelID {return false}
    if lhs.token != rhs.token {return false}
    if lhs.phrases != rhs.phrases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cubic"),
    2: .same(proto: "server"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cubic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.server) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cubic.isEmpty {
      try visitor.visitSingularStringField(value: self.cubic, fieldNumber: 1)
    }
    if !self.server.isEmpty {
      try visitor.visitSingularStringField(value: self.server, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_VersionResponse, rhs: Cobaltspeech_Cubic_VersionResponse) -> Bool {
    if lhs.cubic != rhs.cubic {return false}
    if lhs.server != rhs.server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ListModelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "models"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.models) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.models, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ListModelsResponse, rhs: Cobaltspeech_Cubic_ListModelsResponse) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionResponse, rhs: Cobaltspeech_Cubic_RecognitionResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_CompileContextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompileContextResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_CompileContextResponse, rhs: Cobaltspeech_Cubic_CompileContextResponse) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_id"),
    2: .standard(proto: "audio_encoding"),
    3: .standard(proto: "idle_timeout"),
    4: .standard(proto: "enable_word_time_offsets"),
    5: .standard(proto: "enable_word_confidence"),
    6: .standard(proto: "enable_raw_transcript"),
    7: .standard(proto: "enable_confusion_network"),
    8: .standard(proto: "audio_channels"),
    9: .same(proto: "metadata"),
    10: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.modelID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.audioEncoding) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._idleTimeout) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableWordTimeOffsets) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableWordConfidence) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.enableRawTranscript) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.enableConfusionNetwork) }()
      case 8: try { try decoder.decodeRepeatedUInt32Field(value: &self.audioChannels) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelID.isEmpty {
      try visitor.visitSingularStringField(value: self.modelID, fieldNumber: 1)
    }
    if self.audioEncoding != .rawLinear16 {
      try visitor.visitSingularEnumField(value: self.audioEncoding, fieldNumber: 2)
    }
    if let v = self._idleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.enableWordTimeOffsets != false {
      try visitor.visitSingularBoolField(value: self.enableWordTimeOffsets, fieldNumber: 4)
    }
    if self.enableWordConfidence != false {
      try visitor.visitSingularBoolField(value: self.enableWordConfidence, fieldNumber: 5)
    }
    if self.enableRawTranscript != false {
      try visitor.visitSingularBoolField(value: self.enableRawTranscript, fieldNumber: 6)
    }
    if self.enableConfusionNetwork != false {
      try visitor.visitSingularBoolField(value: self.enableConfusionNetwork, fieldNumber: 7)
    }
    if !self.audioChannels.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.audioChannels, fieldNumber: 8)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionConfig, rhs: Cobaltspeech_Cubic_RecognitionConfig) -> Bool {
    if lhs.modelID != rhs.modelID {return false}
    if lhs.audioEncoding != rhs.audioEncoding {return false}
    if lhs._idleTimeout != rhs._idleTimeout {return false}
    if lhs.enableWordTimeOffsets != rhs.enableWordTimeOffsets {return false}
    if lhs.enableWordConfidence != rhs.enableWordConfidence {return false}
    if lhs.enableRawTranscript != rhs.enableRawTranscript {return false}
    if lhs.enableConfusionNetwork != rhs.enableConfusionNetwork {return false}
    if lhs.audioChannels != rhs.audioChannels {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionConfig.Encoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RAW_LINEAR16"),
    1: .same(proto: "WAV"),
    2: .same(proto: "MP3"),
    3: .same(proto: "FLAC"),
    4: .same(proto: "VOX8000"),
    5: .same(proto: "ULAW8000"),
    6: .same(proto: "ALAW8000"),
    7: .same(proto: "OPUS"),
  ]
}

extension Cobaltspeech_Cubic_RecognitionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "custom_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.customMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.customMetadata.isEmpty {
      try visitor.visitSingularStringField(value: self.customMetadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionMetadata, rhs: Cobaltspeech_Cubic_RecognitionMetadata) -> Bool {
    if lhs.customMetadata != rhs.customMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "compiled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.compiled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.compiled.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.compiled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionContext, rhs: Cobaltspeech_Cubic_RecognitionContext) -> Bool {
    if lhs.compiled != rhs.compiled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_CompiledContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompiledContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_CompiledContext, rhs: Cobaltspeech_Cubic_CompiledContext) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ContextPhrase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContextPhrase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "boost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.boost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.boost != 0 {
      try visitor.visitSingularFloatField(value: self.boost, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ContextPhrase, rhs: Cobaltspeech_Cubic_ContextPhrase) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.boost != rhs.boost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionAudio, rhs: Cobaltspeech_Cubic_RecognitionAudio) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Model"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_Model, rhs: Cobaltspeech_Cubic_Model) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ModelAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelAttributes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_rate"),
    2: .standard(proto: "context_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sampleRate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contextInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleRate, fieldNumber: 1)
    }
    if let v = self._contextInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ModelAttributes, rhs: Cobaltspeech_Cubic_ModelAttributes) -> Bool {
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs._contextInfo != rhs._contextInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ContextInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContextInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supports_context"),
    2: .standard(proto: "allowed_context_tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.supportsContext) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedContextTokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.supportsContext != false {
      try visitor.visitSingularBoolField(value: self.supportsContext, fieldNumber: 1)
    }
    if !self.allowedContextTokens.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedContextTokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ContextInfo, rhs: Cobaltspeech_Cubic_ContextInfo) -> Bool {
    if lhs.supportsContext != rhs.supportsContext {return false}
    if lhs.allowedContextTokens != rhs.allowedContextTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alternatives"),
    2: .standard(proto: "is_partial"),
    3: .same(proto: "cnet"),
    4: .standard(proto: "audio_channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alternatives) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isPartial) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cnet) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.audioChannel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alternatives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alternatives, fieldNumber: 1)
    }
    if self.isPartial != false {
      try visitor.visitSingularBoolField(value: self.isPartial, fieldNumber: 2)
    }
    if let v = self._cnet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.audioChannel != 0 {
      try visitor.visitSingularUInt32Field(value: self.audioChannel, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionResult, rhs: Cobaltspeech_Cubic_RecognitionResult) -> Bool {
    if lhs.alternatives != rhs.alternatives {return false}
    if lhs.isPartial != rhs.isPartial {return false}
    if lhs._cnet != rhs._cnet {return false}
    if lhs.audioChannel != rhs.audioChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionAlternative: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionAlternative"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transcript"),
    6: .standard(proto: "raw_transcript"),
    2: .same(proto: "confidence"),
    3: .same(proto: "words"),
    7: .standard(proto: "raw_words"),
    4: .standard(proto: "start_time"),
    5: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transcript) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.words) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.rawTranscript) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.rawWords) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transcript.isEmpty {
      try visitor.visitSingularStringField(value: self.transcript, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 2)
    }
    if !self.words.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.words, fieldNumber: 3)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.rawTranscript.isEmpty {
      try visitor.visitSingularStringField(value: self.rawTranscript, fieldNumber: 6)
    }
    if !self.rawWords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawWords, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionAlternative, rhs: Cobaltspeech_Cubic_RecognitionAlternative) -> Bool {
    if lhs.transcript != rhs.transcript {return false}
    if lhs.rawTranscript != rhs.rawTranscript {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.words != rhs.words {return false}
    if lhs.rawWords != rhs.rawWords {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_WordInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "confidence"),
    3: .standard(proto: "start_time"),
    4: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 2)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_WordInfo, rhs: Cobaltspeech_Cubic_WordInfo) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionConfusionNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionConfusionNetwork"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionConfusionNetwork, rhs: Cobaltspeech_Cubic_RecognitionConfusionNetwork) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ConfusionNetworkLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionNetworkLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .same(proto: "duration"),
    3: .same(proto: "arcs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.arcs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.arcs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arcs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ConfusionNetworkLink, rhs: Cobaltspeech_Cubic_ConfusionNetworkLink) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.arcs != rhs.arcs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ConfusionNetworkArc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionNetworkArc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.confidence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ConfusionNetworkArc, rhs: Cobaltspeech_Cubic_ConfusionNetworkArc) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
