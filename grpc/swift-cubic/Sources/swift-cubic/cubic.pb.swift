// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: swift-gen/cubic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (2019) Cobalt Speech and Language Inc.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The top-level message sent by the client for the `ListModels` method.
public struct Cobaltspeech_Cubic_ListModelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The top-level message sent by the client for the `Recognize` method.  Both
/// the `RecognitionConfig` and `RecognitionAudio` fields are required.  The
/// entire audio data must be sent in one request.  If your audio data is larger,
/// please use the `StreamingRecognize` call..
public struct Cobaltspeech_Cubic_RecognizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Provides configuration to create the recognizer.
  public var config: Cobaltspeech_Cubic_RecognitionConfig {
    get {return _storage._config ?? Cobaltspeech_Cubic_RecognitionConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {_uniqueStorage()._config = nil}

  /// The audio data to be recognized
  public var audio: Cobaltspeech_Cubic_RecognitionAudio {
    get {return _storage._audio ?? Cobaltspeech_Cubic_RecognitionAudio()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {_uniqueStorage()._audio = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The top-level message sent by the client for the `StreamingRecognize`
/// request.  Multiple `StreamingRecognizeRequest` messages are sent. The first
/// message must contain a `RecognitionConfig` message only, and all subsequent
/// messages must contain `RecognitionAudio` only.  All `RecognitionAudio`
/// messages must contain non-empty audio.  If audio content is empty, the server
/// may interpret it as end of stream and stop accepting any further messages.
public struct Cobaltspeech_Cubic_StreamingRecognizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: OneOf_Request? {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  public var config: Cobaltspeech_Cubic_RecognitionConfig {
    get {
      if case .config(let v)? = _storage._request {return v}
      return Cobaltspeech_Cubic_RecognitionConfig()
    }
    set {_uniqueStorage()._request = .config(newValue)}
  }

  public var audio: Cobaltspeech_Cubic_RecognitionAudio {
    get {
      if case .audio(let v)? = _storage._request {return v}
      return Cobaltspeech_Cubic_RecognitionAudio()
    }
    set {_uniqueStorage()._request = .audio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case config(Cobaltspeech_Cubic_RecognitionConfig)
    case audio(Cobaltspeech_Cubic_RecognitionAudio)

  #if !swift(>=4.1)
    public static func ==(lhs: Cobaltspeech_Cubic_StreamingRecognizeRequest.OneOf_Request, rhs: Cobaltspeech_Cubic_StreamingRecognizeRequest.OneOf_Request) -> Bool {
      switch (lhs, rhs) {
      case (.config(let l), .config(let r)): return l == r
      case (.audio(let l), .audio(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The message sent by the server for the `Version` method.
public struct Cobaltspeech_Cubic_VersionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// version of the cubic library handling the recognition
  public var cubic: String = String()

  /// version of the server handling these requests
  public var server: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message returned to the client by the `ListModels` method.
public struct Cobaltspeech_Cubic_ListModelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of models available for use that match the request.
  public var models: [Cobaltspeech_Cubic_Model] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Collection of sequence of recognition results in a portion of audio.  When
/// transcribing a single audio channel (e.g. RAW_LINEAR16 input, or a mono
/// file), results will be ordered chronologically.  When transcribing multiple
/// channels, the results of all channels will be interleaved.  Results of each
/// individual channel will be chronological.  No such promise is made for the
/// ordering of results of different channels, as results are returned for each
/// channel individually as soon as they are ready.
public struct Cobaltspeech_Cubic_RecognitionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var results: [Cobaltspeech_Cubic_RecognitionResult] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for setting up a Recognizer
public struct Cobaltspeech_Cubic_RecognitionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the model to use, as obtained from a `Model` message.
  public var modelID: String {
    get {return _storage._modelID}
    set {_uniqueStorage()._modelID = newValue}
  }

  /// Encoding of audio data sent/streamed through the `RecognitionAudio`
  /// messages.  For encodings like WAV/MP3 that have headers, the headers are
  /// expected to be sent at the beginning of the stream, not in every
  /// `RecognitionAudio` message.
  ///
  /// If not specified, the default encoding is RAW_LINEAR16.
  ///
  /// Depending on how they are configured, server instances of this service may
  /// not support all the encodings enumerated above. They are always required to
  /// accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
  /// available on the server being used, the recognition request will result in
  /// an appropriate error message.
  public var audioEncoding: Cobaltspeech_Cubic_RecognitionConfig.Encoding {
    get {return _storage._audioEncoding}
    set {_uniqueStorage()._audioEncoding = newValue}
  }

  /// Idle Timeout of the created Recognizer.  If no audio data is received by
  /// the recognizer for this duration, ongoing rpc calls will result in an
  /// error, the recognizer will be destroyed and thus more audio may not be sent
  /// to the same recognizer.  The server may impose a limit on the maximum idle
  /// timeout that can be specified, and if the value in this message exceeds
  /// that serverside value, creating of the recognizer will fail with an error.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return _storage._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {_uniqueStorage()._idleTimeout = nil}

  /// This is an optional field.  If this is set to true, each result will
  /// include a list of words and the start time offset (timestamp) and the
  /// duration for each of those words.  If set to `false`, no word-level
  /// timestamps will be returned.  The default is `false`.
  public var enableWordTimeOffsets: Bool {
    get {return _storage._enableWordTimeOffsets}
    set {_uniqueStorage()._enableWordTimeOffsets = newValue}
  }

  /// This is an optional field.  If this is set to true, each result will
  /// include a list of words and the confidence for those words.  If `false`, no
  /// word-level confidence information is returned.  The default is `false`.
  public var enableWordConfidence: Bool {
    get {return _storage._enableWordConfidence}
    set {_uniqueStorage()._enableWordConfidence = newValue}
  }

  /// This is an optional field.  If this is set to true, the field
  /// `RecognitionAlternative.raw_transcript` will be populated with the raw
  /// transcripts output from the recognizer will be exposed without any
  /// formatting rules applied.  If this is set to false, that field will not
  /// be set in the results.  The RecognitionAlternative.transcript will
  /// always be populated with text formatted according to the server's settings.
  public var enableRawTranscript: Bool {
    get {return _storage._enableRawTranscript}
    set {_uniqueStorage()._enableRawTranscript = newValue}
  }

  /// This is an optional field.  If this is set to true, the results will
  /// include a confusion network.  If set to `false`, no confusion network will
  /// be returned.  The default is `false`.  If the model being used does not
  /// support a confusion network, results may be returned without a confusion
  /// network available.  If this field is set to `true`, then
  /// `enable_raw_transcript` is also forced to be true.
  public var enableConfusionNetwork: Bool {
    get {return _storage._enableConfusionNetwork}
    set {_uniqueStorage()._enableConfusionNetwork = newValue}
  }

  /// This is an optional field.  If the audio has multiple channels, this field
  /// should be configured with the list of channel indices that should be
  /// transcribed.  Channels are 0-indexed.
  ///
  /// Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
  ///
  /// If this field is not set, a mono file will be assumed by default and only
  /// channel-0 will be transcribed even if the file actually has additional
  /// channels.
  ///
  /// Channels that are present in the audio may be omitted, but it is an error
  /// to include a channel index in this field that is not present in the audio.
  /// Channels may be listed in any order but the same index may not be repeated
  /// in this list.
  ///
  /// BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
  public var audioChannels: [UInt32] {
    get {return _storage._audioChannels}
    set {_uniqueStorage()._audioChannels = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The encoding of the audio data to be sent for recognition.
  ///
  /// For best results, the audio source should be captured and transmitted using
  /// the RAW_LINEAR16 encoding.
  public enum Encoding: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Raw (headerless) Uncompressed 16-bit signed little endian samples (linear
    /// PCM), single channel, sampled at the rate expected by the chosen `Model`.
    case rawLinear16 // = 0

    /// WAV (data with RIFF headers), with data sampled at a rate equal to or
    /// higher than the sample rate expected by the chosen Model.
    case wav // = 1

    /// MP3 data, sampled at a rate equal to or higher than the sampling rate
    /// expected by the chosen Model.
    case mp3 // = 2

    /// FLAC data, sampled at a rate equal to or higher than the sample rate
    /// expected by the chosen Model.
    case flac // = 3

    /// VOX data (Dialogic ADPCM), sampled at 8 KHz.
    case vox8000 // = 4

    /// Î¼-law (8-bit) encoded RAW data, single channel, sampled at 8 KHz.
    case ulaw8000 // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .rawLinear16
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .rawLinear16
      case 1: self = .wav
      case 2: self = .mp3
      case 3: self = .flac
      case 4: self = .vox8000
      case 5: self = .ulaw8000
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .rawLinear16: return 0
      case .wav: return 1
      case .mp3: return 2
      case .flac: return 3
      case .vox8000: return 4
      case .ulaw8000: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Cobaltspeech_Cubic_RecognitionConfig.Encoding: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Cobaltspeech_Cubic_RecognitionConfig.Encoding] = [
    .rawLinear16,
    .wav,
    .mp3,
    .flac,
    .vox8000,
    .ulaw8000,
  ]
}

#endif  // swift(>=4.2)

/// Audio to be sent to the recognizer
public struct Cobaltspeech_Cubic_RecognitionAudio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Description of a Cubic Model
public struct Cobaltspeech_Cubic_Model {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier of the model.  This identifier is used to choose the
  /// model that should be used for recognition, and is specified in the
  /// `RecognitionConfig` message.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Model name.  This is a concise name describing the model, and maybe
  /// presented to the end-user, for example, to help choose which model to use
  /// for their recognition task.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Model attributes
  public var attributes: Cobaltspeech_Cubic_ModelAttributes {
    get {return _storage._attributes ?? Cobaltspeech_Cubic_ModelAttributes()}
    set {_uniqueStorage()._attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  public var hasAttributes: Bool {return _storage._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  public mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Attributes of a Cubic Model
public struct Cobaltspeech_Cubic_ModelAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Audio sample rate supported by the model
  public var sampleRate: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A recognition result corresponding to a portion of audio.
public struct Cobaltspeech_Cubic_RecognitionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An n-best list of recognition hypotheses alternatives
  public var alternatives: [Cobaltspeech_Cubic_RecognitionAlternative] {
    get {return _storage._alternatives}
    set {_uniqueStorage()._alternatives = newValue}
  }

  /// If this is set to true, it denotes that the result is an interim partial
  /// result, and could change after more audio is processed.  If unset, or set
  /// to false, it denotes that this is a final result and will not change.
  ///
  /// Servers are not required to implement support for returning partial
  /// results, and clients should generally not depend on their availability.
  public var isPartial: Bool {
    get {return _storage._isPartial}
    set {_uniqueStorage()._isPartial = newValue}
  }

  /// If `enable_confusion_network` was set to true in the `RecognitionConfig`,
  /// and if the model supports it, a confusion network will be available in the
  /// results.
  public var cnet: Cobaltspeech_Cubic_RecognitionConfusionNetwork {
    get {return _storage._cnet ?? Cobaltspeech_Cubic_RecognitionConfusionNetwork()}
    set {_uniqueStorage()._cnet = newValue}
  }
  /// Returns true if `cnet` has been explicitly set.
  public var hasCnet: Bool {return _storage._cnet != nil}
  /// Clears the value of `cnet`. Subsequent reads from it will return its default value.
  public mutating func clearCnet() {_uniqueStorage()._cnet = nil}

  /// Channel of the audio file that this result was transcribed from.  For a
  /// mono file, or RAW_LINEAR16 input, this will be set to 0.
  public var audioChannel: UInt32 {
    get {return _storage._audioChannel}
    set {_uniqueStorage()._audioChannel = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A recognition hypothesis
public struct Cobaltspeech_Cubic_RecognitionAlternative {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Text representing the transcription of the words that the user spoke.
  ///
  /// The transcript will be formatted according to the servers formatting
  /// configuration. If you want the raw transcript, please see the field
  /// `raw_transcript`.  If the server is configured to not use any formatting,
  /// then this field will contain the raw transcript.
  ///
  /// As an example, if the spoken utterance was "four people", and the
  /// server was configured to format numbers, this field would be set to
  /// "4 people".
  public var transcript: String {
    get {return _storage._transcript}
    set {_uniqueStorage()._transcript = newValue}
  }

  /// Text representing the transcription of the words that the user spoke,
  /// without any formatting.  This field will be populated only the config
  /// `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
  /// field will be an empty string. If you want the formatted transcript, please
  /// see the field `transcript`.
  ///
  /// As an example, if the spoken utterance was `here are four words`,
  /// this field would be set to "HERE ARE FOUR WORDS".
  public var rawTranscript: String {
    get {return _storage._rawTranscript}
    set {_uniqueStorage()._rawTranscript = newValue}
  }

  /// Confidence estimate between 0 and 1. A higher number represents a higher
  /// likelihood of the output being correct.
  public var confidence: Double {
    get {return _storage._confidence}
    set {_uniqueStorage()._confidence = newValue}
  }

  /// A list of word-specific information for each recognized word.  This is
  /// available only if `enable_word_confidence` or `enable_word_time_offsets`
  /// was set to `true` in the `RecognitionConfig`.
  public var words: [Cobaltspeech_Cubic_WordInfo] {
    get {return _storage._words}
    set {_uniqueStorage()._words = newValue}
  }

  /// Time offset relative to the beginning of audio received by the recognizer
  /// and corresponding to the start of this utterance.
  public var startTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Duration of the current utterance in the spoken audio.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {_uniqueStorage()._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Word-specific information for recognized words
public struct Cobaltspeech_Cubic_WordInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actual word in the text
  public var word: String {
    get {return _storage._word}
    set {_uniqueStorage()._word = newValue}
  }

  /// Confidence estimate between 0 and 1.  A higher number represents a
  /// higher likelihood that the word was correctly recognized.
  public var confidence: Double {
    get {return _storage._confidence}
    set {_uniqueStorage()._confidence = newValue}
  }

  /// Time offset relative to the beginning of audio received by the recognizer
  /// and corresponding to the start of this spoken word.
  public var startTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Duration of the current word in the spoken audio.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {_uniqueStorage()._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Confusion network in recognition output
public struct Cobaltspeech_Cubic_RecognitionConfusionNetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var links: [Cobaltspeech_Cubic_ConfusionNetworkLink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Link inside a confusion network
public struct Cobaltspeech_Cubic_ConfusionNetworkLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time offset relative to the beginning of audio received by the recognizer
  /// and corresponding to the start of this link
  public var startTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Duration of the current link in the confusion network
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {_uniqueStorage()._duration = nil}

  /// Arcs between this link
  public var arcs: [Cobaltspeech_Cubic_ConfusionNetworkArc] {
    get {return _storage._arcs}
    set {_uniqueStorage()._arcs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An Arc inside a Confusion Network Link
public struct Cobaltspeech_Cubic_ConfusionNetworkArc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Word in the recognized transcript
  public var word: String = String()

  /// Confidence estimate between 0 and 1.  A higher number represents a higher
  /// likelihood that the word was correctly recognized.
  public var confidence: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cobaltspeech.cubic"

extension Cobaltspeech_Cubic_ListModelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ListModelsRequest, rhs: Cobaltspeech_Cubic_ListModelsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognizeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "audio"),
  ]

  fileprivate class _StorageClass {
    var _config: Cobaltspeech_Cubic_RecognitionConfig? = nil
    var _audio: Cobaltspeech_Cubic_RecognitionAudio? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _config = source._config
      _audio = source._audio
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._config)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._audio)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognizeRequest, rhs: Cobaltspeech_Cubic_RecognizeRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._config != rhs_storage._config {return false}
        if _storage._audio != rhs_storage._audio {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_StreamingRecognizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingRecognizeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "audio"),
  ]

  fileprivate class _StorageClass {
    var _request: Cobaltspeech_Cubic_StreamingRecognizeRequest.OneOf_Request?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _request = source._request
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Cobaltspeech_Cubic_RecognitionConfig?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .config(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .config(v)}
        case 2:
          var v: Cobaltspeech_Cubic_RecognitionAudio?
          if let current = _storage._request {
            try decoder.handleConflictingOneOf()
            if case .audio(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._request = .audio(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._request {
      case .config(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .audio(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_StreamingRecognizeRequest, rhs: Cobaltspeech_Cubic_StreamingRecognizeRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._request != rhs_storage._request {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_VersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cubic"),
    2: .same(proto: "server"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cubic)
      case 2: try decoder.decodeSingularStringField(value: &self.server)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cubic.isEmpty {
      try visitor.visitSingularStringField(value: self.cubic, fieldNumber: 1)
    }
    if !self.server.isEmpty {
      try visitor.visitSingularStringField(value: self.server, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_VersionResponse, rhs: Cobaltspeech_Cubic_VersionResponse) -> Bool {
    if lhs.cubic != rhs.cubic {return false}
    if lhs.server != rhs.server {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ListModelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListModelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "models"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.models)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.models, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ListModelsResponse, rhs: Cobaltspeech_Cubic_ListModelsResponse) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.results)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionResponse, rhs: Cobaltspeech_Cubic_RecognitionResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_id"),
    2: .standard(proto: "audio_encoding"),
    3: .standard(proto: "idle_timeout"),
    4: .standard(proto: "enable_word_time_offsets"),
    5: .standard(proto: "enable_word_confidence"),
    6: .standard(proto: "enable_raw_transcript"),
    7: .standard(proto: "enable_confusion_network"),
    8: .standard(proto: "audio_channels"),
  ]

  fileprivate class _StorageClass {
    var _modelID: String = String()
    var _audioEncoding: Cobaltspeech_Cubic_RecognitionConfig.Encoding = .rawLinear16
    var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _enableWordTimeOffsets: Bool = false
    var _enableWordConfidence: Bool = false
    var _enableRawTranscript: Bool = false
    var _enableConfusionNetwork: Bool = false
    var _audioChannels: [UInt32] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _modelID = source._modelID
      _audioEncoding = source._audioEncoding
      _idleTimeout = source._idleTimeout
      _enableWordTimeOffsets = source._enableWordTimeOffsets
      _enableWordConfidence = source._enableWordConfidence
      _enableRawTranscript = source._enableRawTranscript
      _enableConfusionNetwork = source._enableConfusionNetwork
      _audioChannels = source._audioChannels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._modelID)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._audioEncoding)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._idleTimeout)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._enableWordTimeOffsets)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._enableWordConfidence)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._enableRawTranscript)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._enableConfusionNetwork)
        case 8: try decoder.decodeRepeatedUInt32Field(value: &_storage._audioChannels)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._modelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._modelID, fieldNumber: 1)
      }
      if _storage._audioEncoding != .rawLinear16 {
        try visitor.visitSingularEnumField(value: _storage._audioEncoding, fieldNumber: 2)
      }
      if let v = _storage._idleTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._enableWordTimeOffsets != false {
        try visitor.visitSingularBoolField(value: _storage._enableWordTimeOffsets, fieldNumber: 4)
      }
      if _storage._enableWordConfidence != false {
        try visitor.visitSingularBoolField(value: _storage._enableWordConfidence, fieldNumber: 5)
      }
      if _storage._enableRawTranscript != false {
        try visitor.visitSingularBoolField(value: _storage._enableRawTranscript, fieldNumber: 6)
      }
      if _storage._enableConfusionNetwork != false {
        try visitor.visitSingularBoolField(value: _storage._enableConfusionNetwork, fieldNumber: 7)
      }
      if !_storage._audioChannels.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._audioChannels, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionConfig, rhs: Cobaltspeech_Cubic_RecognitionConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._modelID != rhs_storage._modelID {return false}
        if _storage._audioEncoding != rhs_storage._audioEncoding {return false}
        if _storage._idleTimeout != rhs_storage._idleTimeout {return false}
        if _storage._enableWordTimeOffsets != rhs_storage._enableWordTimeOffsets {return false}
        if _storage._enableWordConfidence != rhs_storage._enableWordConfidence {return false}
        if _storage._enableRawTranscript != rhs_storage._enableRawTranscript {return false}
        if _storage._enableConfusionNetwork != rhs_storage._enableConfusionNetwork {return false}
        if _storage._audioChannels != rhs_storage._audioChannels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionConfig.Encoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RAW_LINEAR16"),
    1: .same(proto: "WAV"),
    2: .same(proto: "MP3"),
    3: .same(proto: "FLAC"),
    4: .same(proto: "VOX8000"),
    5: .same(proto: "ULAW8000"),
  ]
}

extension Cobaltspeech_Cubic_RecognitionAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionAudio, rhs: Cobaltspeech_Cubic_RecognitionAudio) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Model"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "attributes"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _attributes: Cobaltspeech_Cubic_ModelAttributes? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _attributes = source._attributes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._attributes)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_Model, rhs: Cobaltspeech_Cubic_Model) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ModelAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelAttributes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.sampleRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleRate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ModelAttributes, rhs: Cobaltspeech_Cubic_ModelAttributes) -> Bool {
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alternatives"),
    2: .standard(proto: "is_partial"),
    3: .same(proto: "cnet"),
    4: .standard(proto: "audio_channel"),
  ]

  fileprivate class _StorageClass {
    var _alternatives: [Cobaltspeech_Cubic_RecognitionAlternative] = []
    var _isPartial: Bool = false
    var _cnet: Cobaltspeech_Cubic_RecognitionConfusionNetwork? = nil
    var _audioChannel: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _alternatives = source._alternatives
      _isPartial = source._isPartial
      _cnet = source._cnet
      _audioChannel = source._audioChannel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._alternatives)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._isPartial)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._cnet)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._audioChannel)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._alternatives.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._alternatives, fieldNumber: 1)
      }
      if _storage._isPartial != false {
        try visitor.visitSingularBoolField(value: _storage._isPartial, fieldNumber: 2)
      }
      if let v = _storage._cnet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._audioChannel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._audioChannel, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionResult, rhs: Cobaltspeech_Cubic_RecognitionResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._alternatives != rhs_storage._alternatives {return false}
        if _storage._isPartial != rhs_storage._isPartial {return false}
        if _storage._cnet != rhs_storage._cnet {return false}
        if _storage._audioChannel != rhs_storage._audioChannel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionAlternative: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionAlternative"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transcript"),
    6: .standard(proto: "raw_transcript"),
    2: .same(proto: "confidence"),
    3: .same(proto: "words"),
    4: .standard(proto: "start_time"),
    5: .same(proto: "duration"),
  ]

  fileprivate class _StorageClass {
    var _transcript: String = String()
    var _rawTranscript: String = String()
    var _confidence: Double = 0
    var _words: [Cobaltspeech_Cubic_WordInfo] = []
    var _startTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transcript = source._transcript
      _rawTranscript = source._rawTranscript
      _confidence = source._confidence
      _words = source._words
      _startTime = source._startTime
      _duration = source._duration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._transcript)
        case 2: try decoder.decodeSingularDoubleField(value: &_storage._confidence)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._words)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._startTime)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._duration)
        case 6: try decoder.decodeSingularStringField(value: &_storage._rawTranscript)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transcript.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transcript, fieldNumber: 1)
      }
      if _storage._confidence != 0 {
        try visitor.visitSingularDoubleField(value: _storage._confidence, fieldNumber: 2)
      }
      if !_storage._words.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._words, fieldNumber: 3)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._rawTranscript.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rawTranscript, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionAlternative, rhs: Cobaltspeech_Cubic_RecognitionAlternative) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transcript != rhs_storage._transcript {return false}
        if _storage._rawTranscript != rhs_storage._rawTranscript {return false}
        if _storage._confidence != rhs_storage._confidence {return false}
        if _storage._words != rhs_storage._words {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._duration != rhs_storage._duration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_WordInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "confidence"),
    3: .standard(proto: "start_time"),
    4: .same(proto: "duration"),
  ]

  fileprivate class _StorageClass {
    var _word: String = String()
    var _confidence: Double = 0
    var _startTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _word = source._word
      _confidence = source._confidence
      _startTime = source._startTime
      _duration = source._duration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._word)
        case 2: try decoder.decodeSingularDoubleField(value: &_storage._confidence)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._startTime)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._duration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._word.isEmpty {
        try visitor.visitSingularStringField(value: _storage._word, fieldNumber: 1)
      }
      if _storage._confidence != 0 {
        try visitor.visitSingularDoubleField(value: _storage._confidence, fieldNumber: 2)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_WordInfo, rhs: Cobaltspeech_Cubic_WordInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._word != rhs_storage._word {return false}
        if _storage._confidence != rhs_storage._confidence {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._duration != rhs_storage._duration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_RecognitionConfusionNetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecognitionConfusionNetwork"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.links)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_RecognitionConfusionNetwork, rhs: Cobaltspeech_Cubic_RecognitionConfusionNetwork) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ConfusionNetworkLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionNetworkLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .same(proto: "duration"),
    3: .same(proto: "arcs"),
  ]

  fileprivate class _StorageClass {
    var _startTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _arcs: [Cobaltspeech_Cubic_ConfusionNetworkArc] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startTime = source._startTime
      _duration = source._duration
      _arcs = source._arcs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._startTime)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._duration)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._arcs)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._arcs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arcs, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ConfusionNetworkLink, rhs: Cobaltspeech_Cubic_ConfusionNetworkLink) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._arcs != rhs_storage._arcs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cobaltspeech_Cubic_ConfusionNetworkArc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionNetworkArc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.word)
      case 2: try decoder.decodeSingularDoubleField(value: &self.confidence)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularDoubleField(value: self.confidence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Cobaltspeech_Cubic_ConfusionNetworkArc, rhs: Cobaltspeech_Cubic_ConfusionNetworkArc) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
