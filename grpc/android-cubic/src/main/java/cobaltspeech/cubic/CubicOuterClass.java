// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cubic.proto

package cobaltspeech.cubic;

public final class CubicOuterClass {
  private CubicOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface ListModelsRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.ListModelsRequest)
      com.google.protobuf.MessageLiteOrBuilder {
  }
  /**
   * <pre>
   * The top-level message sent by the client for the `ListModels` method.
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.ListModelsRequest}
   */
  public  static final class ListModelsRequest extends
      com.google.protobuf.GeneratedMessageLite<
          ListModelsRequest, ListModelsRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.ListModelsRequest)
      ListModelsRequestOrBuilder {
    private ListModelsRequest() {
    }
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.ListModelsRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * The top-level message sent by the client for the `ListModels` method.
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.ListModelsRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.ListModelsRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.ListModelsRequest)
        cobaltspeech.cubic.CubicOuterClass.ListModelsRequestOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.ListModelsRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.ListModelsRequest)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.ListModelsRequest();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.ListModelsRequest other = (cobaltspeech.cubic.CubicOuterClass.ListModelsRequest) arg1;
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.ListModelsRequest.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.ListModelsRequest)
    private static final cobaltspeech.cubic.CubicOuterClass.ListModelsRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ListModelsRequest();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.ListModelsRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListModelsRequest> PARSER;

    public static com.google.protobuf.Parser<ListModelsRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognizeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognizeRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    boolean hasConfig();
    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionConfig getConfig();

    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    boolean hasAudio();
    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionAudio getAudio();
  }
  /**
   * <pre>
   * The top-level message sent by the client for the `Recognize` method.  Both
   * the `RecognitionConfig` and `RecognitionAudio` fields are required.  The
   * entire audio data must be sent in one request.  If your audio data is larger,
   * please use the `StreamingRecognize` call..
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognizeRequest}
   */
  public  static final class RecognizeRequest extends
      com.google.protobuf.GeneratedMessageLite<
          RecognizeRequest, RecognizeRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognizeRequest)
      RecognizeRequestOrBuilder {
    private RecognizeRequest() {
    }
    public static final int CONFIG_FIELD_NUMBER = 1;
    private cobaltspeech.cubic.CubicOuterClass.RecognitionConfig config_;
    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    public boolean hasConfig() {
      return config_ != null;
    }
    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionConfig getConfig() {
      return config_ == null ? cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.getDefaultInstance() : config_;
    }
    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void setConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
      if (value == null) {
        throw new NullPointerException();
      }
      config_ = value;
      
      }
    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void setConfig(
        cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Builder builderForValue) {
      config_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void mergeConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
      if (config_ != null &&
          config_ != cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.getDefaultInstance()) {
        config_ =
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.newBuilder(config_).mergeFrom(value).buildPartial();
      } else {
        config_ = value;
      }
      
    }
    /**
     * <pre>
     * Provides configuration to create the recognizer.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void clearConfig() {  config_ = null;
      
    }

    public static final int AUDIO_FIELD_NUMBER = 2;
    private cobaltspeech.cubic.CubicOuterClass.RecognitionAudio audio_;
    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    public boolean hasAudio() {
      return audio_ != null;
    }
    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionAudio getAudio() {
      return audio_ == null ? cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.getDefaultInstance() : audio_;
    }
    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void setAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
      if (value == null) {
        throw new NullPointerException();
      }
      audio_ = value;
      
      }
    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void setAudio(
        cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.Builder builderForValue) {
      audio_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void mergeAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
      if (audio_ != null &&
          audio_ != cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.getDefaultInstance()) {
        audio_ =
          cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.newBuilder(audio_).mergeFrom(value).buildPartial();
      } else {
        audio_ = value;
      }
      
    }
    /**
     * <pre>
     * The audio data to be recognized
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void clearAudio() {  audio_ = null;
      
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (config_ != null) {
        output.writeMessage(1, getConfig());
      }
      if (audio_ != null) {
        output.writeMessage(2, getAudio());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (config_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getConfig());
      }
      if (audio_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getAudio());
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognizeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * The top-level message sent by the client for the `Recognize` method.  Both
     * the `RecognitionConfig` and `RecognitionAudio` fields are required.  The
     * entire audio data must be sent in one request.  If your audio data is larger,
     * please use the `StreamingRecognize` call..
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognizeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognizeRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognizeRequest)
        cobaltspeech.cubic.CubicOuterClass.RecognizeRequestOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognizeRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Provides configuration to create the recognizer.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public boolean hasConfig() {
        return instance.hasConfig();
      }
      /**
       * <pre>
       * Provides configuration to create the recognizer.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionConfig getConfig() {
        return instance.getConfig();
      }
      /**
       * <pre>
       * Provides configuration to create the recognizer.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder setConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
        copyOnWrite();
        instance.setConfig(value);
        return this;
        }
      /**
       * <pre>
       * Provides configuration to create the recognizer.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder setConfig(
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Builder builderForValue) {
        copyOnWrite();
        instance.setConfig(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Provides configuration to create the recognizer.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder mergeConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
        copyOnWrite();
        instance.mergeConfig(value);
        return this;
      }
      /**
       * <pre>
       * Provides configuration to create the recognizer.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder clearConfig() {  copyOnWrite();
        instance.clearConfig();
        return this;
      }

      /**
       * <pre>
       * The audio data to be recognized
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public boolean hasAudio() {
        return instance.hasAudio();
      }
      /**
       * <pre>
       * The audio data to be recognized
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionAudio getAudio() {
        return instance.getAudio();
      }
      /**
       * <pre>
       * The audio data to be recognized
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder setAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
        copyOnWrite();
        instance.setAudio(value);
        return this;
        }
      /**
       * <pre>
       * The audio data to be recognized
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder setAudio(
          cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.Builder builderForValue) {
        copyOnWrite();
        instance.setAudio(builderForValue);
        return this;
      }
      /**
       * <pre>
       * The audio data to be recognized
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder mergeAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
        copyOnWrite();
        instance.mergeAudio(value);
        return this;
      }
      /**
       * <pre>
       * The audio data to be recognized
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder clearAudio() {  copyOnWrite();
        instance.clearAudio();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognizeRequest)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognizeRequest();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognizeRequest other = (cobaltspeech.cubic.CubicOuterClass.RecognizeRequest) arg1;
          config_ = visitor.visitMessage(config_, other.config_);
          audio_ = visitor.visitMessage(audio_, other.audio_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Builder subBuilder = null;
                  if (config_ != null) {
                    subBuilder = config_.toBuilder();
                  }
                  config_ = input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(config_);
                    config_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 18: {
                  cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.Builder subBuilder = null;
                  if (audio_ != null) {
                    subBuilder = audio_.toBuilder();
                  }
                  audio_ = input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(audio_);
                    audio_ = subBuilder.buildPartial();
                  }

                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognizeRequest.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognizeRequest)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognizeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognizeRequest();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognizeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognizeRequest> PARSER;

    public static com.google.protobuf.Parser<RecognizeRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface StreamingRecognizeRequestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.StreamingRecognizeRequest)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionConfig getConfig();

    /**
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionAudio getAudio();

    public cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest.RequestCase getRequestCase();
  }
  /**
   * <pre>
   * The top-level message sent by the client for the `StreamingRecognize`
   * request.  Multiple `StreamingRecognizeRequest` messages are sent. The first
   * message must contain a `RecognitionConfig` message only, and all subsequent
   * messages must contain `RecognitionAudio` only.  All `RecognitionAudio`
   * messages must contain non-empty audio.  If audio content is empty, the server
   * may interpret it as end of stream and stop accepting any further messages.
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.StreamingRecognizeRequest}
   */
  public  static final class StreamingRecognizeRequest extends
      com.google.protobuf.GeneratedMessageLite<
          StreamingRecognizeRequest, StreamingRecognizeRequest.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.StreamingRecognizeRequest)
      StreamingRecognizeRequestOrBuilder {
    private StreamingRecognizeRequest() {
    }
    private int requestCase_ = 0;
    private Object request_;
    public enum RequestCase
        implements com.google.protobuf.Internal.EnumLite {
      CONFIG(1),
      AUDIO(2),
      REQUEST_NOT_SET(0);
      private final int value;
      private RequestCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @Deprecated
      public static RequestCase valueOf(int value) {
        return forNumber(value);
      }

      public static RequestCase forNumber(int value) {
        switch (value) {
          case 1: return CONFIG;
          case 2: return AUDIO;
          case 0: return REQUEST_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public RequestCase
    getRequestCase() {
      return RequestCase.forNumber(
          requestCase_);
    }

    private void clearRequest() {
      requestCase_ = 0;
      request_ = null;
    }

    public static final int CONFIG_FIELD_NUMBER = 1;
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionConfig getConfig() {
      if (requestCase_ == 1) {
         return (cobaltspeech.cubic.CubicOuterClass.RecognitionConfig) request_;
      }
      return cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.getDefaultInstance();
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void setConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
      if (value == null) {
        throw new NullPointerException();
      }
      request_ = value;
      requestCase_ = 1;
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void setConfig(
        cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Builder builderForValue) {
      request_ = builderForValue.build();
      requestCase_ = 1;
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void mergeConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
      if (requestCase_ == 1 &&
          request_ != cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.getDefaultInstance()) {
        request_ = cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.newBuilder((cobaltspeech.cubic.CubicOuterClass.RecognitionConfig) request_)
            .mergeFrom(value).buildPartial();
      } else {
        request_ = value;
      }
      requestCase_ = 1;
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
     */
    private void clearConfig() {
      if (requestCase_ == 1) {
        requestCase_ = 0;
        request_ = null;
      }
    }

    public static final int AUDIO_FIELD_NUMBER = 2;
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionAudio getAudio() {
      if (requestCase_ == 2) {
         return (cobaltspeech.cubic.CubicOuterClass.RecognitionAudio) request_;
      }
      return cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.getDefaultInstance();
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void setAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
      if (value == null) {
        throw new NullPointerException();
      }
      request_ = value;
      requestCase_ = 2;
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void setAudio(
        cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.Builder builderForValue) {
      request_ = builderForValue.build();
      requestCase_ = 2;
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void mergeAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
      if (requestCase_ == 2 &&
          request_ != cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.getDefaultInstance()) {
        request_ = cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.newBuilder((cobaltspeech.cubic.CubicOuterClass.RecognitionAudio) request_)
            .mergeFrom(value).buildPartial();
      } else {
        request_ = value;
      }
      requestCase_ = 2;
    }
    /**
     * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
     */
    private void clearAudio() {
      if (requestCase_ == 2) {
        requestCase_ = 0;
        request_ = null;
      }
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (requestCase_ == 1) {
        output.writeMessage(1, (cobaltspeech.cubic.CubicOuterClass.RecognitionConfig) request_);
      }
      if (requestCase_ == 2) {
        output.writeMessage(2, (cobaltspeech.cubic.CubicOuterClass.RecognitionAudio) request_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (requestCase_ == 1) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, (cobaltspeech.cubic.CubicOuterClass.RecognitionConfig) request_);
      }
      if (requestCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (cobaltspeech.cubic.CubicOuterClass.RecognitionAudio) request_);
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * The top-level message sent by the client for the `StreamingRecognize`
     * request.  Multiple `StreamingRecognizeRequest` messages are sent. The first
     * message must contain a `RecognitionConfig` message only, and all subsequent
     * messages must contain `RecognitionAudio` only.  All `RecognitionAudio`
     * messages must contain non-empty audio.  If audio content is empty, the server
     * may interpret it as end of stream and stop accepting any further messages.
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.StreamingRecognizeRequest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.StreamingRecognizeRequest)
        cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequestOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }

      public RequestCase
          getRequestCase() {
        return instance.getRequestCase();
      }

      public Builder clearRequest() {
        copyOnWrite();
        instance.clearRequest();
        return this;
      }


      /**
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionConfig getConfig() {
        return instance.getConfig();
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder setConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
        copyOnWrite();
        instance.setConfig(value);
        return this;
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder setConfig(
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Builder builderForValue) {
        copyOnWrite();
        instance.setConfig(builderForValue);
        return this;
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder mergeConfig(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig value) {
        copyOnWrite();
        instance.mergeConfig(value);
        return this;
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionConfig config = 1;</code>
       */
      public Builder clearConfig() {
        copyOnWrite();
        instance.clearConfig();
        return this;
      }

      /**
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionAudio getAudio() {
        return instance.getAudio();
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder setAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
        copyOnWrite();
        instance.setAudio(value);
        return this;
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder setAudio(
          cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.Builder builderForValue) {
        copyOnWrite();
        instance.setAudio(builderForValue);
        return this;
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder mergeAudio(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio value) {
        copyOnWrite();
        instance.mergeAudio(value);
        return this;
      }
      /**
       * <code>optional .cobaltspeech.cubic.RecognitionAudio audio = 2;</code>
       */
      public Builder clearAudio() {
        copyOnWrite();
        instance.clearAudio();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.StreamingRecognizeRequest)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest other = (cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest) arg1;
          switch (other.getRequestCase()) {
            case CONFIG: {
              request_ = visitor.visitOneofMessage(
                  requestCase_ == 1,
                  request_,
                  other.request_);
              break;
            }
            case AUDIO: {
              request_ = visitor.visitOneofMessage(
                  requestCase_ == 2,
                  request_,
                  other.request_);
              break;
            }
            case REQUEST_NOT_SET: {
              visitor.visitOneofNotSet(requestCase_ != 0);
              break;
            }
          }
          if (visitor == MergeFromVisitor
              .INSTANCE) {
            if (other.requestCase_ != 0) {
              requestCase_ = other.requestCase_;
            }
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Builder subBuilder = null;
                  if (requestCase_ == 1) {
                    subBuilder = ((cobaltspeech.cubic.CubicOuterClass.RecognitionConfig) request_).toBuilder();
                  }
                  request_ =
                       input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom((cobaltspeech.cubic.CubicOuterClass.RecognitionConfig) request_);
                    request_ = subBuilder.buildPartial();
                  }
                  requestCase_ = 1;
                  break;
                }
                case 18: {
                  cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.Builder subBuilder = null;
                  if (requestCase_ == 2) {
                    subBuilder = ((cobaltspeech.cubic.CubicOuterClass.RecognitionAudio) request_).toBuilder();
                  }
                  request_ =
                       input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom((cobaltspeech.cubic.CubicOuterClass.RecognitionAudio) request_);
                    request_ = subBuilder.buildPartial();
                  }
                  requestCase_ = 2;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.StreamingRecognizeRequest)
    private static final cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new StreamingRecognizeRequest();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.StreamingRecognizeRequest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<StreamingRecognizeRequest> PARSER;

    public static com.google.protobuf.Parser<StreamingRecognizeRequest> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface VersionResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.VersionResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * version of the cubic library handling the recognition
     * </pre>
     *
     * <code>optional string cubic = 1;</code>
     */
    String getCubic();
    /**
     * <pre>
     * version of the cubic library handling the recognition
     * </pre>
     *
     * <code>optional string cubic = 1;</code>
     */
    com.google.protobuf.ByteString
        getCubicBytes();

    /**
     * <pre>
     * version of the server handling these requests
     * </pre>
     *
     * <code>optional string server = 2;</code>
     */
    String getServer();
    /**
     * <pre>
     * version of the server handling these requests
     * </pre>
     *
     * <code>optional string server = 2;</code>
     */
    com.google.protobuf.ByteString
        getServerBytes();
  }
  /**
   * <pre>
   * The message sent by the server for the `Version` method.
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.VersionResponse}
   */
  public  static final class VersionResponse extends
      com.google.protobuf.GeneratedMessageLite<
          VersionResponse, VersionResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.VersionResponse)
      VersionResponseOrBuilder {
    private VersionResponse() {
      cubic_ = "";
      server_ = "";
    }
    public static final int CUBIC_FIELD_NUMBER = 1;
    private String cubic_;
    /**
     * <pre>
     * version of the cubic library handling the recognition
     * </pre>
     *
     * <code>optional string cubic = 1;</code>
     */
    public String getCubic() {
      return cubic_;
    }
    /**
     * <pre>
     * version of the cubic library handling the recognition
     * </pre>
     *
     * <code>optional string cubic = 1;</code>
     */
    public com.google.protobuf.ByteString
        getCubicBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(cubic_);
    }
    /**
     * <pre>
     * version of the cubic library handling the recognition
     * </pre>
     *
     * <code>optional string cubic = 1;</code>
     */
    private void setCubic(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      cubic_ = value;
    }
    /**
     * <pre>
     * version of the cubic library handling the recognition
     * </pre>
     *
     * <code>optional string cubic = 1;</code>
     */
    private void clearCubic() {
      
      cubic_ = getDefaultInstance().getCubic();
    }
    /**
     * <pre>
     * version of the cubic library handling the recognition
     * </pre>
     *
     * <code>optional string cubic = 1;</code>
     */
    private void setCubicBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      cubic_ = value.toStringUtf8();
    }

    public static final int SERVER_FIELD_NUMBER = 2;
    private String server_;
    /**
     * <pre>
     * version of the server handling these requests
     * </pre>
     *
     * <code>optional string server = 2;</code>
     */
    public String getServer() {
      return server_;
    }
    /**
     * <pre>
     * version of the server handling these requests
     * </pre>
     *
     * <code>optional string server = 2;</code>
     */
    public com.google.protobuf.ByteString
        getServerBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(server_);
    }
    /**
     * <pre>
     * version of the server handling these requests
     * </pre>
     *
     * <code>optional string server = 2;</code>
     */
    private void setServer(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      server_ = value;
    }
    /**
     * <pre>
     * version of the server handling these requests
     * </pre>
     *
     * <code>optional string server = 2;</code>
     */
    private void clearServer() {
      
      server_ = getDefaultInstance().getServer();
    }
    /**
     * <pre>
     * version of the server handling these requests
     * </pre>
     *
     * <code>optional string server = 2;</code>
     */
    private void setServerBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      server_ = value.toStringUtf8();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!cubic_.isEmpty()) {
        output.writeString(1, getCubic());
      }
      if (!server_.isEmpty()) {
        output.writeString(2, getServer());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!cubic_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getCubic());
      }
      if (!server_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(2, getServer());
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.VersionResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * The message sent by the server for the `Version` method.
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.VersionResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.VersionResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.VersionResponse)
        cobaltspeech.cubic.CubicOuterClass.VersionResponseOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.VersionResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * version of the cubic library handling the recognition
       * </pre>
       *
       * <code>optional string cubic = 1;</code>
       */
      public String getCubic() {
        return instance.getCubic();
      }
      /**
       * <pre>
       * version of the cubic library handling the recognition
       * </pre>
       *
       * <code>optional string cubic = 1;</code>
       */
      public com.google.protobuf.ByteString
          getCubicBytes() {
        return instance.getCubicBytes();
      }
      /**
       * <pre>
       * version of the cubic library handling the recognition
       * </pre>
       *
       * <code>optional string cubic = 1;</code>
       */
      public Builder setCubic(
          String value) {
        copyOnWrite();
        instance.setCubic(value);
        return this;
      }
      /**
       * <pre>
       * version of the cubic library handling the recognition
       * </pre>
       *
       * <code>optional string cubic = 1;</code>
       */
      public Builder clearCubic() {
        copyOnWrite();
        instance.clearCubic();
        return this;
      }
      /**
       * <pre>
       * version of the cubic library handling the recognition
       * </pre>
       *
       * <code>optional string cubic = 1;</code>
       */
      public Builder setCubicBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCubicBytes(value);
        return this;
      }

      /**
       * <pre>
       * version of the server handling these requests
       * </pre>
       *
       * <code>optional string server = 2;</code>
       */
      public String getServer() {
        return instance.getServer();
      }
      /**
       * <pre>
       * version of the server handling these requests
       * </pre>
       *
       * <code>optional string server = 2;</code>
       */
      public com.google.protobuf.ByteString
          getServerBytes() {
        return instance.getServerBytes();
      }
      /**
       * <pre>
       * version of the server handling these requests
       * </pre>
       *
       * <code>optional string server = 2;</code>
       */
      public Builder setServer(
          String value) {
        copyOnWrite();
        instance.setServer(value);
        return this;
      }
      /**
       * <pre>
       * version of the server handling these requests
       * </pre>
       *
       * <code>optional string server = 2;</code>
       */
      public Builder clearServer() {
        copyOnWrite();
        instance.clearServer();
        return this;
      }
      /**
       * <pre>
       * version of the server handling these requests
       * </pre>
       *
       * <code>optional string server = 2;</code>
       */
      public Builder setServerBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setServerBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.VersionResponse)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.VersionResponse();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.VersionResponse other = (cobaltspeech.cubic.CubicOuterClass.VersionResponse) arg1;
          cubic_ = visitor.visitString(!cubic_.isEmpty(), cubic_,
              !other.cubic_.isEmpty(), other.cubic_);
          server_ = visitor.visitString(!server_.isEmpty(), server_,
              !other.server_.isEmpty(), other.server_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readStringRequireUtf8();

                  cubic_ = s;
                  break;
                }
                case 18: {
                  String s = input.readStringRequireUtf8();

                  server_ = s;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.VersionResponse.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.VersionResponse)
    private static final cobaltspeech.cubic.CubicOuterClass.VersionResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new VersionResponse();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.VersionResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<VersionResponse> PARSER;

    public static com.google.protobuf.Parser<VersionResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ListModelsResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.ListModelsResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    java.util.List<cobaltspeech.cubic.CubicOuterClass.Model> 
        getModelsList();
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.Model getModels(int index);
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    int getModelsCount();
  }
  /**
   * <pre>
   * The message returned to the client by the `ListModels` method.
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.ListModelsResponse}
   */
  public  static final class ListModelsResponse extends
      com.google.protobuf.GeneratedMessageLite<
          ListModelsResponse, ListModelsResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.ListModelsResponse)
      ListModelsResponseOrBuilder {
    private ListModelsResponse() {
      models_ = emptyProtobufList();
    }
    public static final int MODELS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<cobaltspeech.cubic.CubicOuterClass.Model> models_;
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    public java.util.List<cobaltspeech.cubic.CubicOuterClass.Model> getModelsList() {
      return models_;
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    public java.util.List<? extends cobaltspeech.cubic.CubicOuterClass.ModelOrBuilder> 
        getModelsOrBuilderList() {
      return models_;
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    public int getModelsCount() {
      return models_.size();
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.Model getModels(int index) {
      return models_.get(index);
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.ModelOrBuilder getModelsOrBuilder(
        int index) {
      return models_.get(index);
    }
    private void ensureModelsIsMutable() {
      if (!models_.isModifiable()) {
        models_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(models_);
       }
    }

    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void setModels(
        int index, cobaltspeech.cubic.CubicOuterClass.Model value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureModelsIsMutable();
      models_.set(index, value);
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void setModels(
        int index, cobaltspeech.cubic.CubicOuterClass.Model.Builder builderForValue) {
      ensureModelsIsMutable();
      models_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void addModels(cobaltspeech.cubic.CubicOuterClass.Model value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureModelsIsMutable();
      models_.add(value);
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void addModels(
        int index, cobaltspeech.cubic.CubicOuterClass.Model value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureModelsIsMutable();
      models_.add(index, value);
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void addModels(
        cobaltspeech.cubic.CubicOuterClass.Model.Builder builderForValue) {
      ensureModelsIsMutable();
      models_.add(builderForValue.build());
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void addModels(
        int index, cobaltspeech.cubic.CubicOuterClass.Model.Builder builderForValue) {
      ensureModelsIsMutable();
      models_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void addAllModels(
        Iterable<? extends cobaltspeech.cubic.CubicOuterClass.Model> values) {
      ensureModelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, models_);
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void clearModels() {
      models_ = emptyProtobufList();
    }
    /**
     * <pre>
     * List of models available for use that match the request.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
     */
    private void removeModels(int index) {
      ensureModelsIsMutable();
      models_.remove(index);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < models_.size(); i++) {
        output.writeMessage(1, models_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < models_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, models_.get(i));
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.ListModelsResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * The message returned to the client by the `ListModels` method.
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.ListModelsResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.ListModelsResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.ListModelsResponse)
        cobaltspeech.cubic.CubicOuterClass.ListModelsResponseOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.ListModelsResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public java.util.List<cobaltspeech.cubic.CubicOuterClass.Model> getModelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getModelsList());
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public int getModelsCount() {
        return instance.getModelsCount();
      }/**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.Model getModels(int index) {
        return instance.getModels(index);
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder setModels(
          int index, cobaltspeech.cubic.CubicOuterClass.Model value) {
        copyOnWrite();
        instance.setModels(index, value);
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder setModels(
          int index, cobaltspeech.cubic.CubicOuterClass.Model.Builder builderForValue) {
        copyOnWrite();
        instance.setModels(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder addModels(cobaltspeech.cubic.CubicOuterClass.Model value) {
        copyOnWrite();
        instance.addModels(value);
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder addModels(
          int index, cobaltspeech.cubic.CubicOuterClass.Model value) {
        copyOnWrite();
        instance.addModels(index, value);
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder addModels(
          cobaltspeech.cubic.CubicOuterClass.Model.Builder builderForValue) {
        copyOnWrite();
        instance.addModels(builderForValue);
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder addModels(
          int index, cobaltspeech.cubic.CubicOuterClass.Model.Builder builderForValue) {
        copyOnWrite();
        instance.addModels(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder addAllModels(
          Iterable<? extends cobaltspeech.cubic.CubicOuterClass.Model> values) {
        copyOnWrite();
        instance.addAllModels(values);
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder clearModels() {
        copyOnWrite();
        instance.clearModels();
        return this;
      }
      /**
       * <pre>
       * List of models available for use that match the request.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.Model models = 1;</code>
       */
      public Builder removeModels(int index) {
        copyOnWrite();
        instance.removeModels(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.ListModelsResponse)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.ListModelsResponse();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          models_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.ListModelsResponse other = (cobaltspeech.cubic.CubicOuterClass.ListModelsResponse) arg1;
          models_= visitor.visitList(models_, other.models_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  if (!models_.isModifiable()) {
                    models_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(models_);
                  }
                  models_.add(
                      input.readMessage(cobaltspeech.cubic.CubicOuterClass.Model.parser(), extensionRegistry));
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.ListModelsResponse.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.ListModelsResponse)
    private static final cobaltspeech.cubic.CubicOuterClass.ListModelsResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ListModelsResponse();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.ListModelsResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ListModelsResponse> PARSER;

    public static com.google.protobuf.Parser<ListModelsResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognitionResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognitionResponse)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    java.util.List<cobaltspeech.cubic.CubicOuterClass.RecognitionResult> 
        getResultsList();
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionResult getResults(int index);
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    int getResultsCount();
  }
  /**
   * <pre>
   * Collection of sequence of recognition results in a portion of audio.  When
   * transcribing a single audio channel (e.g. RAW_LINEAR16 input, or a mono
   * file), results will be ordered chronologically.  When transcribing multiple
   * channels, the results of all channels will be interleaved.  Results of each
   * individual channel will be chronological.  No such promise is made for the
   * ordering of results of different channels, as results are returned for each
   * channel individually as soon as they are ready.
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognitionResponse}
   */
  public  static final class RecognitionResponse extends
      com.google.protobuf.GeneratedMessageLite<
          RecognitionResponse, RecognitionResponse.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognitionResponse)
      RecognitionResponseOrBuilder {
    private RecognitionResponse() {
      results_ = emptyProtobufList();
    }
    public static final int RESULTS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<cobaltspeech.cubic.CubicOuterClass.RecognitionResult> results_;
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    public java.util.List<cobaltspeech.cubic.CubicOuterClass.RecognitionResult> getResultsList() {
      return results_;
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    public java.util.List<? extends cobaltspeech.cubic.CubicOuterClass.RecognitionResultOrBuilder> 
        getResultsOrBuilderList() {
      return results_;
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    public int getResultsCount() {
      return results_.size();
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionResult getResults(int index) {
      return results_.get(index);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionResultOrBuilder getResultsOrBuilder(
        int index) {
      return results_.get(index);
    }
    private void ensureResultsIsMutable() {
      if (!results_.isModifiable()) {
        results_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(results_);
       }
    }

    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void setResults(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureResultsIsMutable();
      results_.set(index, value);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void setResults(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult.Builder builderForValue) {
      ensureResultsIsMutable();
      results_.set(index, builderForValue.build());
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void addResults(cobaltspeech.cubic.CubicOuterClass.RecognitionResult value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureResultsIsMutable();
      results_.add(value);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void addResults(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureResultsIsMutable();
      results_.add(index, value);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void addResults(
        cobaltspeech.cubic.CubicOuterClass.RecognitionResult.Builder builderForValue) {
      ensureResultsIsMutable();
      results_.add(builderForValue.build());
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void addResults(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult.Builder builderForValue) {
      ensureResultsIsMutable();
      results_.add(index, builderForValue.build());
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void addAllResults(
        Iterable<? extends cobaltspeech.cubic.CubicOuterClass.RecognitionResult> values) {
      ensureResultsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, results_);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void clearResults() {
      results_ = emptyProtobufList();
    }
    /**
     * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
     */
    private void removeResults(int index) {
      ensureResultsIsMutable();
      results_.remove(index);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < results_.size(); i++) {
        output.writeMessage(1, results_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < results_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, results_.get(i));
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognitionResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Collection of sequence of recognition results in a portion of audio.  When
     * transcribing a single audio channel (e.g. RAW_LINEAR16 input, or a mono
     * file), results will be ordered chronologically.  When transcribing multiple
     * channels, the results of all channels will be interleaved.  Results of each
     * individual channel will be chronological.  No such promise is made for the
     * ordering of results of different channels, as results are returned for each
     * channel individually as soon as they are ready.
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognitionResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognitionResponse, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognitionResponse)
        cobaltspeech.cubic.CubicOuterClass.RecognitionResponseOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognitionResponse.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public java.util.List<cobaltspeech.cubic.CubicOuterClass.RecognitionResult> getResultsList() {
        return java.util.Collections.unmodifiableList(
            instance.getResultsList());
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public int getResultsCount() {
        return instance.getResultsCount();
      }/**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionResult getResults(int index) {
        return instance.getResults(index);
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder setResults(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult value) {
        copyOnWrite();
        instance.setResults(index, value);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder setResults(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult.Builder builderForValue) {
        copyOnWrite();
        instance.setResults(index, builderForValue);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder addResults(cobaltspeech.cubic.CubicOuterClass.RecognitionResult value) {
        copyOnWrite();
        instance.addResults(value);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder addResults(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult value) {
        copyOnWrite();
        instance.addResults(index, value);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder addResults(
          cobaltspeech.cubic.CubicOuterClass.RecognitionResult.Builder builderForValue) {
        copyOnWrite();
        instance.addResults(builderForValue);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder addResults(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionResult.Builder builderForValue) {
        copyOnWrite();
        instance.addResults(index, builderForValue);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder addAllResults(
          Iterable<? extends cobaltspeech.cubic.CubicOuterClass.RecognitionResult> values) {
        copyOnWrite();
        instance.addAllResults(values);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder clearResults() {
        copyOnWrite();
        instance.clearResults();
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.RecognitionResult results = 1;</code>
       */
      public Builder removeResults(int index) {
        copyOnWrite();
        instance.removeResults(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognitionResponse)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognitionResponse();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          results_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognitionResponse other = (cobaltspeech.cubic.CubicOuterClass.RecognitionResponse) arg1;
          results_= visitor.visitList(results_, other.results_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  if (!results_.isModifiable()) {
                    results_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(results_);
                  }
                  results_.add(
                      input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionResult.parser(), extensionRegistry));
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognitionResponse.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognitionResponse)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognitionResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognitionResponse();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognitionResponse> PARSER;

    public static com.google.protobuf.Parser<RecognitionResponse> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognitionConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognitionConfig)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Unique identifier of the model to use, as obtained from a `Model` message.
     * </pre>
     *
     * <code>optional string model_id = 1;</code>
     */
    String getModelId();
    /**
     * <pre>
     * Unique identifier of the model to use, as obtained from a `Model` message.
     * </pre>
     *
     * <code>optional string model_id = 1;</code>
     */
    com.google.protobuf.ByteString
        getModelIdBytes();

    /**
     * <pre>
     * Encoding of audio data sent/streamed through the `RecognitionAudio`
     * messages.  For encodings like WAV/MP3 that have headers, the headers are
     * expected to be sent at the beginning of the stream, not in every
     * `RecognitionAudio` message.
     * If not specified, the default encoding is RAW_LINEAR16.
     * Depending on how they are configured, server instances of this service may
     * not support all the encodings enumerated above. They are always required to
     * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
     * available on the server being used, the recognition request will result in
     * an appropriate error message.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
     */
    int getAudioEncodingValue();
    /**
     * <pre>
     * Encoding of audio data sent/streamed through the `RecognitionAudio`
     * messages.  For encodings like WAV/MP3 that have headers, the headers are
     * expected to be sent at the beginning of the stream, not in every
     * `RecognitionAudio` message.
     * If not specified, the default encoding is RAW_LINEAR16.
     * Depending on how they are configured, server instances of this service may
     * not support all the encodings enumerated above. They are always required to
     * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
     * available on the server being used, the recognition request will result in
     * an appropriate error message.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding getAudioEncoding();

    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    boolean hasIdleTimeout();
    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    com.google.protobuf.Duration getIdleTimeout();

    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the start time offset (timestamp) and the
     * duration for each of those words.  If set to `false`, no word-level
     * timestamps will be returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_time_offsets = 4;</code>
     */
    boolean getEnableWordTimeOffsets();

    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the confidence for those words.  If `false`, no
     * word-level confidence information is returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_confidence = 5;</code>
     */
    boolean getEnableWordConfidence();

    /**
     * <pre>
     * This is an optional field.  If this is set to true, the field
     * `RecognitionAlternative.raw_transcript` will be populated with the raw
     * transcripts output from the recognizer will be exposed without any
     * formatting rules applied.  If this is set to false, that field will not
     * be set in the results.  The RecognitionAlternative.transcript will
     * always be populated with text formatted according to the server's settings.
     * </pre>
     *
     * <code>optional bool enable_raw_transcript = 6;</code>
     */
    boolean getEnableRawTranscript();

    /**
     * <pre>
     * This is an optional field.  If this is set to true, the results will
     * include a confusion network.  If set to `false`, no confusion network will
     * be returned.  The default is `false`.  If the model being used does not
     * support a confusion network, results may be returned without a confusion
     * network available.  If this field is set to `true`, then
     * `enable_raw_transcript` is also forced to be true.
     * </pre>
     *
     * <code>optional bool enable_confusion_network = 7;</code>
     */
    boolean getEnableConfusionNetwork();

    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    java.util.List<Integer> getAudioChannelsList();
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    int getAudioChannelsCount();
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    int getAudioChannels(int index);

    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata getMetadata();
  }
  /**
   * <pre>
   * Configuration for setting up a Recognizer
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognitionConfig}
   */
  public  static final class RecognitionConfig extends
      com.google.protobuf.GeneratedMessageLite<
          RecognitionConfig, RecognitionConfig.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognitionConfig)
      RecognitionConfigOrBuilder {
    private RecognitionConfig() {
      modelId_ = "";
      audioChannels_ = emptyIntList();
    }
    /**
     * <pre>
     * The encoding of the audio data to be sent for recognition.
     * For best results, the audio source should be captured and transmitted using
     * the RAW_LINEAR16 encoding.
     * </pre>
     *
     * Protobuf enum {@code cobaltspeech.cubic.RecognitionConfig.Encoding}
     */
    public enum Encoding
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Raw (headerless) Uncompressed 16-bit signed little endian samples (linear
       * PCM), single channel, sampled at the rate expected by the chosen `Model`.
       * </pre>
       *
       * <code>RAW_LINEAR16 = 0;</code>
       */
      RAW_LINEAR16(0),
      /**
       * <pre>
       * WAV (data with RIFF headers), with data sampled at a rate equal to or
       * higher than the sample rate expected by the chosen Model.
       * </pre>
       *
       * <code>WAV = 1;</code>
       */
      WAV(1),
      /**
       * <pre>
       * MP3 data, sampled at a rate equal to or higher than the sampling rate
       * expected by the chosen Model.
       * </pre>
       *
       * <code>MP3 = 2;</code>
       */
      MP3(2),
      /**
       * <pre>
       * FLAC data, sampled at a rate equal to or higher than the sample rate
       * expected by the chosen Model.
       * </pre>
       *
       * <code>FLAC = 3;</code>
       */
      FLAC(3),
      /**
       * <pre>
       * VOX data (Dialogic ADPCM), sampled at 8 KHz.
       * </pre>
       *
       * <code>VOX8000 = 4;</code>
       */
      VOX8000(4),
      /**
       * <pre>
       * -law (8-bit) encoded RAW data, single channel, sampled at 8 KHz.
       * </pre>
       *
       * <code>ULAW8000 = 5;</code>
       */
      ULAW8000(5),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * Raw (headerless) Uncompressed 16-bit signed little endian samples (linear
       * PCM), single channel, sampled at the rate expected by the chosen `Model`.
       * </pre>
       *
       * <code>RAW_LINEAR16 = 0;</code>
       */
      public static final int RAW_LINEAR16_VALUE = 0;
      /**
       * <pre>
       * WAV (data with RIFF headers), with data sampled at a rate equal to or
       * higher than the sample rate expected by the chosen Model.
       * </pre>
       *
       * <code>WAV = 1;</code>
       */
      public static final int WAV_VALUE = 1;
      /**
       * <pre>
       * MP3 data, sampled at a rate equal to or higher than the sampling rate
       * expected by the chosen Model.
       * </pre>
       *
       * <code>MP3 = 2;</code>
       */
      public static final int MP3_VALUE = 2;
      /**
       * <pre>
       * FLAC data, sampled at a rate equal to or higher than the sample rate
       * expected by the chosen Model.
       * </pre>
       *
       * <code>FLAC = 3;</code>
       */
      public static final int FLAC_VALUE = 3;
      /**
       * <pre>
       * VOX data (Dialogic ADPCM), sampled at 8 KHz.
       * </pre>
       *
       * <code>VOX8000 = 4;</code>
       */
      public static final int VOX8000_VALUE = 4;
      /**
       * <pre>
       * -law (8-bit) encoded RAW data, single channel, sampled at 8 KHz.
       * </pre>
       *
       * <code>ULAW8000 = 5;</code>
       */
      public static final int ULAW8000_VALUE = 5;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @Deprecated
      public static Encoding valueOf(int value) {
        return forNumber(value);
      }

      public static Encoding forNumber(int value) {
        switch (value) {
          case 0: return RAW_LINEAR16;
          case 1: return WAV;
          case 2: return MP3;
          case 3: return FLAC;
          case 4: return VOX8000;
          case 5: return ULAW8000;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Encoding>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Encoding> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Encoding>() {
              public Encoding findValueByNumber(int number) {
                return Encoding.forNumber(number);
              }
            };

      private final int value;

      private Encoding(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:cobaltspeech.cubic.RecognitionConfig.Encoding)
    }

    private int bitField0_;
    public static final int MODEL_ID_FIELD_NUMBER = 1;
    private String modelId_;
    /**
     * <pre>
     * Unique identifier of the model to use, as obtained from a `Model` message.
     * </pre>
     *
     * <code>optional string model_id = 1;</code>
     */
    public String getModelId() {
      return modelId_;
    }
    /**
     * <pre>
     * Unique identifier of the model to use, as obtained from a `Model` message.
     * </pre>
     *
     * <code>optional string model_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getModelIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(modelId_);
    }
    /**
     * <pre>
     * Unique identifier of the model to use, as obtained from a `Model` message.
     * </pre>
     *
     * <code>optional string model_id = 1;</code>
     */
    private void setModelId(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      modelId_ = value;
    }
    /**
     * <pre>
     * Unique identifier of the model to use, as obtained from a `Model` message.
     * </pre>
     *
     * <code>optional string model_id = 1;</code>
     */
    private void clearModelId() {
      
      modelId_ = getDefaultInstance().getModelId();
    }
    /**
     * <pre>
     * Unique identifier of the model to use, as obtained from a `Model` message.
     * </pre>
     *
     * <code>optional string model_id = 1;</code>
     */
    private void setModelIdBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      modelId_ = value.toStringUtf8();
    }

    public static final int AUDIO_ENCODING_FIELD_NUMBER = 2;
    private int audioEncoding_;
    /**
     * <pre>
     * Encoding of audio data sent/streamed through the `RecognitionAudio`
     * messages.  For encodings like WAV/MP3 that have headers, the headers are
     * expected to be sent at the beginning of the stream, not in every
     * `RecognitionAudio` message.
     * If not specified, the default encoding is RAW_LINEAR16.
     * Depending on how they are configured, server instances of this service may
     * not support all the encodings enumerated above. They are always required to
     * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
     * available on the server being used, the recognition request will result in
     * an appropriate error message.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
     */
    public int getAudioEncodingValue() {
      return audioEncoding_;
    }
    /**
     * <pre>
     * Encoding of audio data sent/streamed through the `RecognitionAudio`
     * messages.  For encodings like WAV/MP3 that have headers, the headers are
     * expected to be sent at the beginning of the stream, not in every
     * `RecognitionAudio` message.
     * If not specified, the default encoding is RAW_LINEAR16.
     * Depending on how they are configured, server instances of this service may
     * not support all the encodings enumerated above. They are always required to
     * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
     * available on the server being used, the recognition request will result in
     * an appropriate error message.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding getAudioEncoding() {
      cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding result = cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding.forNumber(audioEncoding_);
      return result == null ? cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Encoding of audio data sent/streamed through the `RecognitionAudio`
     * messages.  For encodings like WAV/MP3 that have headers, the headers are
     * expected to be sent at the beginning of the stream, not in every
     * `RecognitionAudio` message.
     * If not specified, the default encoding is RAW_LINEAR16.
     * Depending on how they are configured, server instances of this service may
     * not support all the encodings enumerated above. They are always required to
     * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
     * available on the server being used, the recognition request will result in
     * an appropriate error message.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
     */
    private void setAudioEncodingValue(int value) {
        audioEncoding_ = value;
    }
    /**
     * <pre>
     * Encoding of audio data sent/streamed through the `RecognitionAudio`
     * messages.  For encodings like WAV/MP3 that have headers, the headers are
     * expected to be sent at the beginning of the stream, not in every
     * `RecognitionAudio` message.
     * If not specified, the default encoding is RAW_LINEAR16.
     * Depending on how they are configured, server instances of this service may
     * not support all the encodings enumerated above. They are always required to
     * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
     * available on the server being used, the recognition request will result in
     * an appropriate error message.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
     */
    private void setAudioEncoding(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      audioEncoding_ = value.getNumber();
    }
    /**
     * <pre>
     * Encoding of audio data sent/streamed through the `RecognitionAudio`
     * messages.  For encodings like WAV/MP3 that have headers, the headers are
     * expected to be sent at the beginning of the stream, not in every
     * `RecognitionAudio` message.
     * If not specified, the default encoding is RAW_LINEAR16.
     * Depending on how they are configured, server instances of this service may
     * not support all the encodings enumerated above. They are always required to
     * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
     * available on the server being used, the recognition request will result in
     * an appropriate error message.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
     */
    private void clearAudioEncoding() {
      
      audioEncoding_ = 0;
    }

    public static final int IDLE_TIMEOUT_FIELD_NUMBER = 3;
    private com.google.protobuf.Duration idleTimeout_;
    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    public boolean hasIdleTimeout() {
      return idleTimeout_ != null;
    }
    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    public com.google.protobuf.Duration getIdleTimeout() {
      return idleTimeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : idleTimeout_;
    }
    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    private void setIdleTimeout(com.google.protobuf.Duration value) {
      if (value == null) {
        throw new NullPointerException();
      }
      idleTimeout_ = value;
      
      }
    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    private void setIdleTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      idleTimeout_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    private void mergeIdleTimeout(com.google.protobuf.Duration value) {
      if (idleTimeout_ != null &&
          idleTimeout_ != com.google.protobuf.Duration.getDefaultInstance()) {
        idleTimeout_ =
          com.google.protobuf.Duration.newBuilder(idleTimeout_).mergeFrom(value).buildPartial();
      } else {
        idleTimeout_ = value;
      }
      
    }
    /**
     * <pre>
     * Idle Timeout of the created Recognizer.  If no audio data is received by
     * the recognizer for this duration, ongoing rpc calls will result in an
     * error, the recognizer will be destroyed and thus more audio may not be sent
     * to the same recognizer.  The server may impose a limit on the maximum idle
     * timeout that can be specified, and if the value in this message exceeds
     * that serverside value, creating of the recognizer will fail with an error.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
     */
    private void clearIdleTimeout() {  idleTimeout_ = null;
      
    }

    public static final int ENABLE_WORD_TIME_OFFSETS_FIELD_NUMBER = 4;
    private boolean enableWordTimeOffsets_;
    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the start time offset (timestamp) and the
     * duration for each of those words.  If set to `false`, no word-level
     * timestamps will be returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_time_offsets = 4;</code>
     */
    public boolean getEnableWordTimeOffsets() {
      return enableWordTimeOffsets_;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the start time offset (timestamp) and the
     * duration for each of those words.  If set to `false`, no word-level
     * timestamps will be returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_time_offsets = 4;</code>
     */
    private void setEnableWordTimeOffsets(boolean value) {
      
      enableWordTimeOffsets_ = value;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the start time offset (timestamp) and the
     * duration for each of those words.  If set to `false`, no word-level
     * timestamps will be returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_time_offsets = 4;</code>
     */
    private void clearEnableWordTimeOffsets() {
      
      enableWordTimeOffsets_ = false;
    }

    public static final int ENABLE_WORD_CONFIDENCE_FIELD_NUMBER = 5;
    private boolean enableWordConfidence_;
    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the confidence for those words.  If `false`, no
     * word-level confidence information is returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_confidence = 5;</code>
     */
    public boolean getEnableWordConfidence() {
      return enableWordConfidence_;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the confidence for those words.  If `false`, no
     * word-level confidence information is returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_confidence = 5;</code>
     */
    private void setEnableWordConfidence(boolean value) {
      
      enableWordConfidence_ = value;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, each result will
     * include a list of words and the confidence for those words.  If `false`, no
     * word-level confidence information is returned.  The default is `false`.
     * </pre>
     *
     * <code>optional bool enable_word_confidence = 5;</code>
     */
    private void clearEnableWordConfidence() {
      
      enableWordConfidence_ = false;
    }

    public static final int ENABLE_RAW_TRANSCRIPT_FIELD_NUMBER = 6;
    private boolean enableRawTranscript_;
    /**
     * <pre>
     * This is an optional field.  If this is set to true, the field
     * `RecognitionAlternative.raw_transcript` will be populated with the raw
     * transcripts output from the recognizer will be exposed without any
     * formatting rules applied.  If this is set to false, that field will not
     * be set in the results.  The RecognitionAlternative.transcript will
     * always be populated with text formatted according to the server's settings.
     * </pre>
     *
     * <code>optional bool enable_raw_transcript = 6;</code>
     */
    public boolean getEnableRawTranscript() {
      return enableRawTranscript_;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, the field
     * `RecognitionAlternative.raw_transcript` will be populated with the raw
     * transcripts output from the recognizer will be exposed without any
     * formatting rules applied.  If this is set to false, that field will not
     * be set in the results.  The RecognitionAlternative.transcript will
     * always be populated with text formatted according to the server's settings.
     * </pre>
     *
     * <code>optional bool enable_raw_transcript = 6;</code>
     */
    private void setEnableRawTranscript(boolean value) {
      
      enableRawTranscript_ = value;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, the field
     * `RecognitionAlternative.raw_transcript` will be populated with the raw
     * transcripts output from the recognizer will be exposed without any
     * formatting rules applied.  If this is set to false, that field will not
     * be set in the results.  The RecognitionAlternative.transcript will
     * always be populated with text formatted according to the server's settings.
     * </pre>
     *
     * <code>optional bool enable_raw_transcript = 6;</code>
     */
    private void clearEnableRawTranscript() {
      
      enableRawTranscript_ = false;
    }

    public static final int ENABLE_CONFUSION_NETWORK_FIELD_NUMBER = 7;
    private boolean enableConfusionNetwork_;
    /**
     * <pre>
     * This is an optional field.  If this is set to true, the results will
     * include a confusion network.  If set to `false`, no confusion network will
     * be returned.  The default is `false`.  If the model being used does not
     * support a confusion network, results may be returned without a confusion
     * network available.  If this field is set to `true`, then
     * `enable_raw_transcript` is also forced to be true.
     * </pre>
     *
     * <code>optional bool enable_confusion_network = 7;</code>
     */
    public boolean getEnableConfusionNetwork() {
      return enableConfusionNetwork_;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, the results will
     * include a confusion network.  If set to `false`, no confusion network will
     * be returned.  The default is `false`.  If the model being used does not
     * support a confusion network, results may be returned without a confusion
     * network available.  If this field is set to `true`, then
     * `enable_raw_transcript` is also forced to be true.
     * </pre>
     *
     * <code>optional bool enable_confusion_network = 7;</code>
     */
    private void setEnableConfusionNetwork(boolean value) {
      
      enableConfusionNetwork_ = value;
    }
    /**
     * <pre>
     * This is an optional field.  If this is set to true, the results will
     * include a confusion network.  If set to `false`, no confusion network will
     * be returned.  The default is `false`.  If the model being used does not
     * support a confusion network, results may be returned without a confusion
     * network available.  If this field is set to `true`, then
     * `enable_raw_transcript` is also forced to be true.
     * </pre>
     *
     * <code>optional bool enable_confusion_network = 7;</code>
     */
    private void clearEnableConfusionNetwork() {
      
      enableConfusionNetwork_ = false;
    }

    public static final int AUDIO_CHANNELS_FIELD_NUMBER = 8;
    private com.google.protobuf.Internal.IntList audioChannels_;
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    public java.util.List<Integer>
        getAudioChannelsList() {
      return audioChannels_;
    }
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    public int getAudioChannelsCount() {
      return audioChannels_.size();
    }
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    public int getAudioChannels(int index) {
      return audioChannels_.getInt(index);
    }
    private void ensureAudioChannelsIsMutable() {
      if (!audioChannels_.isModifiable()) {
        audioChannels_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(audioChannels_);
       }
    }
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    private void setAudioChannels(
        int index, int value) {
      ensureAudioChannelsIsMutable();
      audioChannels_.setInt(index, value);
    }
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    private void addAudioChannels(int value) {
      ensureAudioChannelsIsMutable();
      audioChannels_.addInt(value);
    }
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    private void addAllAudioChannels(
        Iterable<? extends Integer> values) {
      ensureAudioChannelsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, audioChannels_);
    }
    /**
     * <pre>
     * This is an optional field.  If the audio has multiple channels, this field
     * should be configured with the list of channel indices that should be
     * transcribed.  Channels are 0-indexed.
     * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
     * If this field is not set, a mono file will be assumed by default and only
     * channel-0 will be transcribed even if the file actually has additional
     * channels.
     * Channels that are present in the audio may be omitted, but it is an error
     * to include a channel index in this field that is not present in the audio.
     * Channels may be listed in any order but the same index may not be repeated
     * in this list.
     * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
     * </pre>
     *
     * <code>repeated uint32 audio_channels = 8;</code>
     */
    private void clearAudioChannels() {
      audioChannels_ = emptyIntList();
    }

    public static final int METADATA_FIELD_NUMBER = 9;
    private cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata metadata_;
    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    public boolean hasMetadata() {
      return metadata_ != null;
    }
    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata getMetadata() {
      return metadata_ == null ? cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    private void setMetadata(cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata value) {
      if (value == null) {
        throw new NullPointerException();
      }
      metadata_ = value;
      
      }
    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    private void setMetadata(
        cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.Builder builderForValue) {
      metadata_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    private void mergeMetadata(cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata value) {
      if (metadata_ != null &&
          metadata_ != cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.getDefaultInstance()) {
        metadata_ =
          cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.newBuilder(metadata_).mergeFrom(value).buildPartial();
      } else {
        metadata_ = value;
      }
      
    }
    /**
     * <pre>
     * This is an optional field.  If there is any metadata associated with the
     * audio being sent, use this field to provide it to cubic.  The server may
     * record this metadata when processing the request.  The server does not use
     * this field for any other purpose.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
     */
    private void clearMetadata() {  metadata_ = null;
      
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (!modelId_.isEmpty()) {
        output.writeString(1, getModelId());
      }
      if (audioEncoding_ != cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding.RAW_LINEAR16.getNumber()) {
        output.writeEnum(2, audioEncoding_);
      }
      if (idleTimeout_ != null) {
        output.writeMessage(3, getIdleTimeout());
      }
      if (enableWordTimeOffsets_ != false) {
        output.writeBool(4, enableWordTimeOffsets_);
      }
      if (enableWordConfidence_ != false) {
        output.writeBool(5, enableWordConfidence_);
      }
      if (enableRawTranscript_ != false) {
        output.writeBool(6, enableRawTranscript_);
      }
      if (enableConfusionNetwork_ != false) {
        output.writeBool(7, enableConfusionNetwork_);
      }
      for (int i = 0; i < audioChannels_.size(); i++) {
        output.writeUInt32(8, audioChannels_.getInt(i));
      }
      if (metadata_ != null) {
        output.writeMessage(9, getMetadata());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!modelId_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getModelId());
      }
      if (audioEncoding_ != cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding.RAW_LINEAR16.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, audioEncoding_);
      }
      if (idleTimeout_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getIdleTimeout());
      }
      if (enableWordTimeOffsets_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, enableWordTimeOffsets_);
      }
      if (enableWordConfidence_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(5, enableWordConfidence_);
      }
      if (enableRawTranscript_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, enableRawTranscript_);
      }
      if (enableConfusionNetwork_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(7, enableConfusionNetwork_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < audioChannels_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(audioChannels_.getInt(i));
        }
        size += dataSize;
        size += 1 * getAudioChannelsList().size();
      }
      if (metadata_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getMetadata());
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Configuration for setting up a Recognizer
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognitionConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfig, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognitionConfig)
        cobaltspeech.cubic.CubicOuterClass.RecognitionConfigOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Unique identifier of the model to use, as obtained from a `Model` message.
       * </pre>
       *
       * <code>optional string model_id = 1;</code>
       */
      public String getModelId() {
        return instance.getModelId();
      }
      /**
       * <pre>
       * Unique identifier of the model to use, as obtained from a `Model` message.
       * </pre>
       *
       * <code>optional string model_id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getModelIdBytes() {
        return instance.getModelIdBytes();
      }
      /**
       * <pre>
       * Unique identifier of the model to use, as obtained from a `Model` message.
       * </pre>
       *
       * <code>optional string model_id = 1;</code>
       */
      public Builder setModelId(
          String value) {
        copyOnWrite();
        instance.setModelId(value);
        return this;
      }
      /**
       * <pre>
       * Unique identifier of the model to use, as obtained from a `Model` message.
       * </pre>
       *
       * <code>optional string model_id = 1;</code>
       */
      public Builder clearModelId() {
        copyOnWrite();
        instance.clearModelId();
        return this;
      }
      /**
       * <pre>
       * Unique identifier of the model to use, as obtained from a `Model` message.
       * </pre>
       *
       * <code>optional string model_id = 1;</code>
       */
      public Builder setModelIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setModelIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * Encoding of audio data sent/streamed through the `RecognitionAudio`
       * messages.  For encodings like WAV/MP3 that have headers, the headers are
       * expected to be sent at the beginning of the stream, not in every
       * `RecognitionAudio` message.
       * If not specified, the default encoding is RAW_LINEAR16.
       * Depending on how they are configured, server instances of this service may
       * not support all the encodings enumerated above. They are always required to
       * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
       * available on the server being used, the recognition request will result in
       * an appropriate error message.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
       */
      public int getAudioEncodingValue() {
        return instance.getAudioEncodingValue();
      }
      /**
       * <pre>
       * Encoding of audio data sent/streamed through the `RecognitionAudio`
       * messages.  For encodings like WAV/MP3 that have headers, the headers are
       * expected to be sent at the beginning of the stream, not in every
       * `RecognitionAudio` message.
       * If not specified, the default encoding is RAW_LINEAR16.
       * Depending on how they are configured, server instances of this service may
       * not support all the encodings enumerated above. They are always required to
       * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
       * available on the server being used, the recognition request will result in
       * an appropriate error message.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
       */
      public Builder setAudioEncodingValue(int value) {
        copyOnWrite();
        instance.setAudioEncodingValue(value);
        return this;
      }
      /**
       * <pre>
       * Encoding of audio data sent/streamed through the `RecognitionAudio`
       * messages.  For encodings like WAV/MP3 that have headers, the headers are
       * expected to be sent at the beginning of the stream, not in every
       * `RecognitionAudio` message.
       * If not specified, the default encoding is RAW_LINEAR16.
       * Depending on how they are configured, server instances of this service may
       * not support all the encodings enumerated above. They are always required to
       * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
       * available on the server being used, the recognition request will result in
       * an appropriate error message.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding getAudioEncoding() {
        return instance.getAudioEncoding();
      }
      /**
       * <pre>
       * Encoding of audio data sent/streamed through the `RecognitionAudio`
       * messages.  For encodings like WAV/MP3 that have headers, the headers are
       * expected to be sent at the beginning of the stream, not in every
       * `RecognitionAudio` message.
       * If not specified, the default encoding is RAW_LINEAR16.
       * Depending on how they are configured, server instances of this service may
       * not support all the encodings enumerated above. They are always required to
       * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
       * available on the server being used, the recognition request will result in
       * an appropriate error message.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
       */
      public Builder setAudioEncoding(cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.Encoding value) {
        copyOnWrite();
        instance.setAudioEncoding(value);
        return this;
      }
      /**
       * <pre>
       * Encoding of audio data sent/streamed through the `RecognitionAudio`
       * messages.  For encodings like WAV/MP3 that have headers, the headers are
       * expected to be sent at the beginning of the stream, not in every
       * `RecognitionAudio` message.
       * If not specified, the default encoding is RAW_LINEAR16.
       * Depending on how they are configured, server instances of this service may
       * not support all the encodings enumerated above. They are always required to
       * accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
       * available on the server being used, the recognition request will result in
       * an appropriate error message.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfig.Encoding audio_encoding = 2;</code>
       */
      public Builder clearAudioEncoding() {
        copyOnWrite();
        instance.clearAudioEncoding();
        return this;
      }

      /**
       * <pre>
       * Idle Timeout of the created Recognizer.  If no audio data is received by
       * the recognizer for this duration, ongoing rpc calls will result in an
       * error, the recognizer will be destroyed and thus more audio may not be sent
       * to the same recognizer.  The server may impose a limit on the maximum idle
       * timeout that can be specified, and if the value in this message exceeds
       * that serverside value, creating of the recognizer will fail with an error.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
       */
      public boolean hasIdleTimeout() {
        return instance.hasIdleTimeout();
      }
      /**
       * <pre>
       * Idle Timeout of the created Recognizer.  If no audio data is received by
       * the recognizer for this duration, ongoing rpc calls will result in an
       * error, the recognizer will be destroyed and thus more audio may not be sent
       * to the same recognizer.  The server may impose a limit on the maximum idle
       * timeout that can be specified, and if the value in this message exceeds
       * that serverside value, creating of the recognizer will fail with an error.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
       */
      public com.google.protobuf.Duration getIdleTimeout() {
        return instance.getIdleTimeout();
      }
      /**
       * <pre>
       * Idle Timeout of the created Recognizer.  If no audio data is received by
       * the recognizer for this duration, ongoing rpc calls will result in an
       * error, the recognizer will be destroyed and thus more audio may not be sent
       * to the same recognizer.  The server may impose a limit on the maximum idle
       * timeout that can be specified, and if the value in this message exceeds
       * that serverside value, creating of the recognizer will fail with an error.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
       */
      public Builder setIdleTimeout(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.setIdleTimeout(value);
        return this;
        }
      /**
       * <pre>
       * Idle Timeout of the created Recognizer.  If no audio data is received by
       * the recognizer for this duration, ongoing rpc calls will result in an
       * error, the recognizer will be destroyed and thus more audio may not be sent
       * to the same recognizer.  The server may impose a limit on the maximum idle
       * timeout that can be specified, and if the value in this message exceeds
       * that serverside value, creating of the recognizer will fail with an error.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
       */
      public Builder setIdleTimeout(
          com.google.protobuf.Duration.Builder builderForValue) {
        copyOnWrite();
        instance.setIdleTimeout(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Idle Timeout of the created Recognizer.  If no audio data is received by
       * the recognizer for this duration, ongoing rpc calls will result in an
       * error, the recognizer will be destroyed and thus more audio may not be sent
       * to the same recognizer.  The server may impose a limit on the maximum idle
       * timeout that can be specified, and if the value in this message exceeds
       * that serverside value, creating of the recognizer will fail with an error.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
       */
      public Builder mergeIdleTimeout(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.mergeIdleTimeout(value);
        return this;
      }
      /**
       * <pre>
       * Idle Timeout of the created Recognizer.  If no audio data is received by
       * the recognizer for this duration, ongoing rpc calls will result in an
       * error, the recognizer will be destroyed and thus more audio may not be sent
       * to the same recognizer.  The server may impose a limit on the maximum idle
       * timeout that can be specified, and if the value in this message exceeds
       * that serverside value, creating of the recognizer will fail with an error.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration idle_timeout = 3;</code>
       */
      public Builder clearIdleTimeout() {  copyOnWrite();
        instance.clearIdleTimeout();
        return this;
      }

      /**
       * <pre>
       * This is an optional field.  If this is set to true, each result will
       * include a list of words and the start time offset (timestamp) and the
       * duration for each of those words.  If set to `false`, no word-level
       * timestamps will be returned.  The default is `false`.
       * </pre>
       *
       * <code>optional bool enable_word_time_offsets = 4;</code>
       */
      public boolean getEnableWordTimeOffsets() {
        return instance.getEnableWordTimeOffsets();
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, each result will
       * include a list of words and the start time offset (timestamp) and the
       * duration for each of those words.  If set to `false`, no word-level
       * timestamps will be returned.  The default is `false`.
       * </pre>
       *
       * <code>optional bool enable_word_time_offsets = 4;</code>
       */
      public Builder setEnableWordTimeOffsets(boolean value) {
        copyOnWrite();
        instance.setEnableWordTimeOffsets(value);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, each result will
       * include a list of words and the start time offset (timestamp) and the
       * duration for each of those words.  If set to `false`, no word-level
       * timestamps will be returned.  The default is `false`.
       * </pre>
       *
       * <code>optional bool enable_word_time_offsets = 4;</code>
       */
      public Builder clearEnableWordTimeOffsets() {
        copyOnWrite();
        instance.clearEnableWordTimeOffsets();
        return this;
      }

      /**
       * <pre>
       * This is an optional field.  If this is set to true, each result will
       * include a list of words and the confidence for those words.  If `false`, no
       * word-level confidence information is returned.  The default is `false`.
       * </pre>
       *
       * <code>optional bool enable_word_confidence = 5;</code>
       */
      public boolean getEnableWordConfidence() {
        return instance.getEnableWordConfidence();
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, each result will
       * include a list of words and the confidence for those words.  If `false`, no
       * word-level confidence information is returned.  The default is `false`.
       * </pre>
       *
       * <code>optional bool enable_word_confidence = 5;</code>
       */
      public Builder setEnableWordConfidence(boolean value) {
        copyOnWrite();
        instance.setEnableWordConfidence(value);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, each result will
       * include a list of words and the confidence for those words.  If `false`, no
       * word-level confidence information is returned.  The default is `false`.
       * </pre>
       *
       * <code>optional bool enable_word_confidence = 5;</code>
       */
      public Builder clearEnableWordConfidence() {
        copyOnWrite();
        instance.clearEnableWordConfidence();
        return this;
      }

      /**
       * <pre>
       * This is an optional field.  If this is set to true, the field
       * `RecognitionAlternative.raw_transcript` will be populated with the raw
       * transcripts output from the recognizer will be exposed without any
       * formatting rules applied.  If this is set to false, that field will not
       * be set in the results.  The RecognitionAlternative.transcript will
       * always be populated with text formatted according to the server's settings.
       * </pre>
       *
       * <code>optional bool enable_raw_transcript = 6;</code>
       */
      public boolean getEnableRawTranscript() {
        return instance.getEnableRawTranscript();
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, the field
       * `RecognitionAlternative.raw_transcript` will be populated with the raw
       * transcripts output from the recognizer will be exposed without any
       * formatting rules applied.  If this is set to false, that field will not
       * be set in the results.  The RecognitionAlternative.transcript will
       * always be populated with text formatted according to the server's settings.
       * </pre>
       *
       * <code>optional bool enable_raw_transcript = 6;</code>
       */
      public Builder setEnableRawTranscript(boolean value) {
        copyOnWrite();
        instance.setEnableRawTranscript(value);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, the field
       * `RecognitionAlternative.raw_transcript` will be populated with the raw
       * transcripts output from the recognizer will be exposed without any
       * formatting rules applied.  If this is set to false, that field will not
       * be set in the results.  The RecognitionAlternative.transcript will
       * always be populated with text formatted according to the server's settings.
       * </pre>
       *
       * <code>optional bool enable_raw_transcript = 6;</code>
       */
      public Builder clearEnableRawTranscript() {
        copyOnWrite();
        instance.clearEnableRawTranscript();
        return this;
      }

      /**
       * <pre>
       * This is an optional field.  If this is set to true, the results will
       * include a confusion network.  If set to `false`, no confusion network will
       * be returned.  The default is `false`.  If the model being used does not
       * support a confusion network, results may be returned without a confusion
       * network available.  If this field is set to `true`, then
       * `enable_raw_transcript` is also forced to be true.
       * </pre>
       *
       * <code>optional bool enable_confusion_network = 7;</code>
       */
      public boolean getEnableConfusionNetwork() {
        return instance.getEnableConfusionNetwork();
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, the results will
       * include a confusion network.  If set to `false`, no confusion network will
       * be returned.  The default is `false`.  If the model being used does not
       * support a confusion network, results may be returned without a confusion
       * network available.  If this field is set to `true`, then
       * `enable_raw_transcript` is also forced to be true.
       * </pre>
       *
       * <code>optional bool enable_confusion_network = 7;</code>
       */
      public Builder setEnableConfusionNetwork(boolean value) {
        copyOnWrite();
        instance.setEnableConfusionNetwork(value);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If this is set to true, the results will
       * include a confusion network.  If set to `false`, no confusion network will
       * be returned.  The default is `false`.  If the model being used does not
       * support a confusion network, results may be returned without a confusion
       * network available.  If this field is set to `true`, then
       * `enable_raw_transcript` is also forced to be true.
       * </pre>
       *
       * <code>optional bool enable_confusion_network = 7;</code>
       */
      public Builder clearEnableConfusionNetwork() {
        copyOnWrite();
        instance.clearEnableConfusionNetwork();
        return this;
      }

      /**
       * <pre>
       * This is an optional field.  If the audio has multiple channels, this field
       * should be configured with the list of channel indices that should be
       * transcribed.  Channels are 0-indexed.
       * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
       * If this field is not set, a mono file will be assumed by default and only
       * channel-0 will be transcribed even if the file actually has additional
       * channels.
       * Channels that are present in the audio may be omitted, but it is an error
       * to include a channel index in this field that is not present in the audio.
       * Channels may be listed in any order but the same index may not be repeated
       * in this list.
       * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
       * </pre>
       *
       * <code>repeated uint32 audio_channels = 8;</code>
       */
      public java.util.List<Integer>
          getAudioChannelsList() {
        return java.util.Collections.unmodifiableList(
            instance.getAudioChannelsList());
      }
      /**
       * <pre>
       * This is an optional field.  If the audio has multiple channels, this field
       * should be configured with the list of channel indices that should be
       * transcribed.  Channels are 0-indexed.
       * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
       * If this field is not set, a mono file will be assumed by default and only
       * channel-0 will be transcribed even if the file actually has additional
       * channels.
       * Channels that are present in the audio may be omitted, but it is an error
       * to include a channel index in this field that is not present in the audio.
       * Channels may be listed in any order but the same index may not be repeated
       * in this list.
       * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
       * </pre>
       *
       * <code>repeated uint32 audio_channels = 8;</code>
       */
      public int getAudioChannelsCount() {
        return instance.getAudioChannelsCount();
      }
      /**
       * <pre>
       * This is an optional field.  If the audio has multiple channels, this field
       * should be configured with the list of channel indices that should be
       * transcribed.  Channels are 0-indexed.
       * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
       * If this field is not set, a mono file will be assumed by default and only
       * channel-0 will be transcribed even if the file actually has additional
       * channels.
       * Channels that are present in the audio may be omitted, but it is an error
       * to include a channel index in this field that is not present in the audio.
       * Channels may be listed in any order but the same index may not be repeated
       * in this list.
       * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
       * </pre>
       *
       * <code>repeated uint32 audio_channels = 8;</code>
       */
      public int getAudioChannels(int index) {
        return instance.getAudioChannels(index);
      }
      /**
       * <pre>
       * This is an optional field.  If the audio has multiple channels, this field
       * should be configured with the list of channel indices that should be
       * transcribed.  Channels are 0-indexed.
       * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
       * If this field is not set, a mono file will be assumed by default and only
       * channel-0 will be transcribed even if the file actually has additional
       * channels.
       * Channels that are present in the audio may be omitted, but it is an error
       * to include a channel index in this field that is not present in the audio.
       * Channels may be listed in any order but the same index may not be repeated
       * in this list.
       * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
       * </pre>
       *
       * <code>repeated uint32 audio_channels = 8;</code>
       */
      public Builder setAudioChannels(
          int index, int value) {
        copyOnWrite();
        instance.setAudioChannels(index, value);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If the audio has multiple channels, this field
       * should be configured with the list of channel indices that should be
       * transcribed.  Channels are 0-indexed.
       * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
       * If this field is not set, a mono file will be assumed by default and only
       * channel-0 will be transcribed even if the file actually has additional
       * channels.
       * Channels that are present in the audio may be omitted, but it is an error
       * to include a channel index in this field that is not present in the audio.
       * Channels may be listed in any order but the same index may not be repeated
       * in this list.
       * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
       * </pre>
       *
       * <code>repeated uint32 audio_channels = 8;</code>
       */
      public Builder addAudioChannels(int value) {
        copyOnWrite();
        instance.addAudioChannels(value);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If the audio has multiple channels, this field
       * should be configured with the list of channel indices that should be
       * transcribed.  Channels are 0-indexed.
       * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
       * If this field is not set, a mono file will be assumed by default and only
       * channel-0 will be transcribed even if the file actually has additional
       * channels.
       * Channels that are present in the audio may be omitted, but it is an error
       * to include a channel index in this field that is not present in the audio.
       * Channels may be listed in any order but the same index may not be repeated
       * in this list.
       * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
       * </pre>
       *
       * <code>repeated uint32 audio_channels = 8;</code>
       */
      public Builder addAllAudioChannels(
          Iterable<? extends Integer> values) {
        copyOnWrite();
        instance.addAllAudioChannels(values);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If the audio has multiple channels, this field
       * should be configured with the list of channel indices that should be
       * transcribed.  Channels are 0-indexed.
       * Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
       * If this field is not set, a mono file will be assumed by default and only
       * channel-0 will be transcribed even if the file actually has additional
       * channels.
       * Channels that are present in the audio may be omitted, but it is an error
       * to include a channel index in this field that is not present in the audio.
       * Channels may be listed in any order but the same index may not be repeated
       * in this list.
       * BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
       * </pre>
       *
       * <code>repeated uint32 audio_channels = 8;</code>
       */
      public Builder clearAudioChannels() {
        copyOnWrite();
        instance.clearAudioChannels();
        return this;
      }

      /**
       * <pre>
       * This is an optional field.  If there is any metadata associated with the
       * audio being sent, use this field to provide it to cubic.  The server may
       * record this metadata when processing the request.  The server does not use
       * this field for any other purpose.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
       */
      public boolean hasMetadata() {
        return instance.hasMetadata();
      }
      /**
       * <pre>
       * This is an optional field.  If there is any metadata associated with the
       * audio being sent, use this field to provide it to cubic.  The server may
       * record this metadata when processing the request.  The server does not use
       * this field for any other purpose.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata getMetadata() {
        return instance.getMetadata();
      }
      /**
       * <pre>
       * This is an optional field.  If there is any metadata associated with the
       * audio being sent, use this field to provide it to cubic.  The server may
       * record this metadata when processing the request.  The server does not use
       * this field for any other purpose.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
       */
      public Builder setMetadata(cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata value) {
        copyOnWrite();
        instance.setMetadata(value);
        return this;
        }
      /**
       * <pre>
       * This is an optional field.  If there is any metadata associated with the
       * audio being sent, use this field to provide it to cubic.  The server may
       * record this metadata when processing the request.  The server does not use
       * this field for any other purpose.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
       */
      public Builder setMetadata(
          cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.Builder builderForValue) {
        copyOnWrite();
        instance.setMetadata(builderForValue);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If there is any metadata associated with the
       * audio being sent, use this field to provide it to cubic.  The server may
       * record this metadata when processing the request.  The server does not use
       * this field for any other purpose.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
       */
      public Builder mergeMetadata(cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata value) {
        copyOnWrite();
        instance.mergeMetadata(value);
        return this;
      }
      /**
       * <pre>
       * This is an optional field.  If there is any metadata associated with the
       * audio being sent, use this field to provide it to cubic.  The server may
       * record this metadata when processing the request.  The server does not use
       * this field for any other purpose.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionMetadata metadata = 9;</code>
       */
      public Builder clearMetadata() {  copyOnWrite();
        instance.clearMetadata();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognitionConfig)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognitionConfig();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          audioChannels_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfig other = (cobaltspeech.cubic.CubicOuterClass.RecognitionConfig) arg1;
          modelId_ = visitor.visitString(!modelId_.isEmpty(), modelId_,
              !other.modelId_.isEmpty(), other.modelId_);
          audioEncoding_ = visitor.visitInt(audioEncoding_ != 0, audioEncoding_,    other.audioEncoding_ != 0, other.audioEncoding_);
          idleTimeout_ = visitor.visitMessage(idleTimeout_, other.idleTimeout_);
          enableWordTimeOffsets_ = visitor.visitBoolean(enableWordTimeOffsets_ != false, enableWordTimeOffsets_,
              other.enableWordTimeOffsets_ != false, other.enableWordTimeOffsets_);
          enableWordConfidence_ = visitor.visitBoolean(enableWordConfidence_ != false, enableWordConfidence_,
              other.enableWordConfidence_ != false, other.enableWordConfidence_);
          enableRawTranscript_ = visitor.visitBoolean(enableRawTranscript_ != false, enableRawTranscript_,
              other.enableRawTranscript_ != false, other.enableRawTranscript_);
          enableConfusionNetwork_ = visitor.visitBoolean(enableConfusionNetwork_ != false, enableConfusionNetwork_,
              other.enableConfusionNetwork_ != false, other.enableConfusionNetwork_);
          audioChannels_= visitor.visitIntList(audioChannels_, other.audioChannels_);
          metadata_ = visitor.visitMessage(metadata_, other.metadata_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readStringRequireUtf8();

                  modelId_ = s;
                  break;
                }
                case 16: {
                  int rawValue = input.readEnum();

                  audioEncoding_ = rawValue;
                  break;
                }
                case 26: {
                  com.google.protobuf.Duration.Builder subBuilder = null;
                  if (idleTimeout_ != null) {
                    subBuilder = idleTimeout_.toBuilder();
                  }
                  idleTimeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(idleTimeout_);
                    idleTimeout_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 32: {

                  enableWordTimeOffsets_ = input.readBool();
                  break;
                }
                case 40: {

                  enableWordConfidence_ = input.readBool();
                  break;
                }
                case 48: {

                  enableRawTranscript_ = input.readBool();
                  break;
                }
                case 56: {

                  enableConfusionNetwork_ = input.readBool();
                  break;
                }
                case 64: {
                  if (!audioChannels_.isModifiable()) {
                    audioChannels_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(audioChannels_);
                  }
                  audioChannels_.addInt(input.readUInt32());
                  break;
                }
                case 66: {
                  int length = input.readRawVarint32();
                  int limit = input.pushLimit(length);
                  if (!audioChannels_.isModifiable() && input.getBytesUntilLimit() > 0) {
                    audioChannels_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(audioChannels_);
                  }
                  while (input.getBytesUntilLimit() > 0) {
                    audioChannels_.addInt(input.readUInt32());
                  }
                  input.popLimit(limit);
                  break;
                }
                case 74: {
                  cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.Builder subBuilder = null;
                  if (metadata_ != null) {
                    subBuilder = metadata_.toBuilder();
                  }
                  metadata_ = input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(metadata_);
                    metadata_ = subBuilder.buildPartial();
                  }

                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognitionConfig.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognitionConfig)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognitionConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognitionConfig();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognitionConfig> PARSER;

    public static com.google.protobuf.Parser<RecognitionConfig> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognitionMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognitionMetadata)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Any custom metadata that the client wants to associate with the recording.
     * This could be a simple string (e.g. a tracing ID) or structured data
     * (e.g. JSON)
     * </pre>
     *
     * <code>optional string custom_metadata = 1;</code>
     */
    String getCustomMetadata();
    /**
     * <pre>
     * Any custom metadata that the client wants to associate with the recording.
     * This could be a simple string (e.g. a tracing ID) or structured data
     * (e.g. JSON)
     * </pre>
     *
     * <code>optional string custom_metadata = 1;</code>
     */
    com.google.protobuf.ByteString
        getCustomMetadataBytes();
  }
  /**
   * <pre>
   * Metadata associated with the audio to be recognized
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognitionMetadata}
   */
  public  static final class RecognitionMetadata extends
      com.google.protobuf.GeneratedMessageLite<
          RecognitionMetadata, RecognitionMetadata.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognitionMetadata)
      RecognitionMetadataOrBuilder {
    private RecognitionMetadata() {
      customMetadata_ = "";
    }
    public static final int CUSTOM_METADATA_FIELD_NUMBER = 1;
    private String customMetadata_;
    /**
     * <pre>
     * Any custom metadata that the client wants to associate with the recording.
     * This could be a simple string (e.g. a tracing ID) or structured data
     * (e.g. JSON)
     * </pre>
     *
     * <code>optional string custom_metadata = 1;</code>
     */
    public String getCustomMetadata() {
      return customMetadata_;
    }
    /**
     * <pre>
     * Any custom metadata that the client wants to associate with the recording.
     * This could be a simple string (e.g. a tracing ID) or structured data
     * (e.g. JSON)
     * </pre>
     *
     * <code>optional string custom_metadata = 1;</code>
     */
    public com.google.protobuf.ByteString
        getCustomMetadataBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(customMetadata_);
    }
    /**
     * <pre>
     * Any custom metadata that the client wants to associate with the recording.
     * This could be a simple string (e.g. a tracing ID) or structured data
     * (e.g. JSON)
     * </pre>
     *
     * <code>optional string custom_metadata = 1;</code>
     */
    private void setCustomMetadata(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      customMetadata_ = value;
    }
    /**
     * <pre>
     * Any custom metadata that the client wants to associate with the recording.
     * This could be a simple string (e.g. a tracing ID) or structured data
     * (e.g. JSON)
     * </pre>
     *
     * <code>optional string custom_metadata = 1;</code>
     */
    private void clearCustomMetadata() {
      
      customMetadata_ = getDefaultInstance().getCustomMetadata();
    }
    /**
     * <pre>
     * Any custom metadata that the client wants to associate with the recording.
     * This could be a simple string (e.g. a tracing ID) or structured data
     * (e.g. JSON)
     * </pre>
     *
     * <code>optional string custom_metadata = 1;</code>
     */
    private void setCustomMetadataBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      customMetadata_ = value.toStringUtf8();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!customMetadata_.isEmpty()) {
        output.writeString(1, getCustomMetadata());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!customMetadata_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getCustomMetadata());
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Metadata associated with the audio to be recognized
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognitionMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognitionMetadata)
        cobaltspeech.cubic.CubicOuterClass.RecognitionMetadataOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Any custom metadata that the client wants to associate with the recording.
       * This could be a simple string (e.g. a tracing ID) or structured data
       * (e.g. JSON)
       * </pre>
       *
       * <code>optional string custom_metadata = 1;</code>
       */
      public String getCustomMetadata() {
        return instance.getCustomMetadata();
      }
      /**
       * <pre>
       * Any custom metadata that the client wants to associate with the recording.
       * This could be a simple string (e.g. a tracing ID) or structured data
       * (e.g. JSON)
       * </pre>
       *
       * <code>optional string custom_metadata = 1;</code>
       */
      public com.google.protobuf.ByteString
          getCustomMetadataBytes() {
        return instance.getCustomMetadataBytes();
      }
      /**
       * <pre>
       * Any custom metadata that the client wants to associate with the recording.
       * This could be a simple string (e.g. a tracing ID) or structured data
       * (e.g. JSON)
       * </pre>
       *
       * <code>optional string custom_metadata = 1;</code>
       */
      public Builder setCustomMetadata(
          String value) {
        copyOnWrite();
        instance.setCustomMetadata(value);
        return this;
      }
      /**
       * <pre>
       * Any custom metadata that the client wants to associate with the recording.
       * This could be a simple string (e.g. a tracing ID) or structured data
       * (e.g. JSON)
       * </pre>
       *
       * <code>optional string custom_metadata = 1;</code>
       */
      public Builder clearCustomMetadata() {
        copyOnWrite();
        instance.clearCustomMetadata();
        return this;
      }
      /**
       * <pre>
       * Any custom metadata that the client wants to associate with the recording.
       * This could be a simple string (e.g. a tracing ID) or structured data
       * (e.g. JSON)
       * </pre>
       *
       * <code>optional string custom_metadata = 1;</code>
       */
      public Builder setCustomMetadataBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setCustomMetadataBytes(value);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognitionMetadata)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata other = (cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata) arg1;
          customMetadata_ = visitor.visitString(!customMetadata_.isEmpty(), customMetadata_,
              !other.customMetadata_.isEmpty(), other.customMetadata_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readStringRequireUtf8();

                  customMetadata_ = s;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognitionMetadata)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognitionMetadata();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognitionMetadata> PARSER;

    public static com.google.protobuf.Parser<RecognitionMetadata> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognitionAudioOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognitionAudio)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional bytes data = 1;</code>
     */
    com.google.protobuf.ByteString getData();
  }
  /**
   * <pre>
   * Audio to be sent to the recognizer
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognitionAudio}
   */
  public  static final class RecognitionAudio extends
      com.google.protobuf.GeneratedMessageLite<
          RecognitionAudio, RecognitionAudio.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognitionAudio)
      RecognitionAudioOrBuilder {
    private RecognitionAudio() {
      data_ = com.google.protobuf.ByteString.EMPTY;
    }
    public static final int DATA_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString data_;
    /**
     * <code>optional bytes data = 1;</code>
     */
    public com.google.protobuf.ByteString getData() {
      return data_;
    }
    /**
     * <code>optional bytes data = 1;</code>
     */
    private void setData(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      data_ = value;
    }
    /**
     * <code>optional bytes data = 1;</code>
     */
    private void clearData() {
      
      data_ = getDefaultInstance().getData();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!data_.isEmpty()) {
        output.writeBytes(1, data_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!data_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, data_);
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognitionAudio prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Audio to be sent to the recognizer
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognitionAudio}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognitionAudio, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognitionAudio)
        cobaltspeech.cubic.CubicOuterClass.RecognitionAudioOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional bytes data = 1;</code>
       */
      public com.google.protobuf.ByteString getData() {
        return instance.getData();
      }
      /**
       * <code>optional bytes data = 1;</code>
       */
      public Builder setData(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setData(value);
        return this;
      }
      /**
       * <code>optional bytes data = 1;</code>
       */
      public Builder clearData() {
        copyOnWrite();
        instance.clearData();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognitionAudio)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognitionAudio();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognitionAudio other = (cobaltspeech.cubic.CubicOuterClass.RecognitionAudio) arg1;
          data_ = visitor.visitByteString(data_ != com.google.protobuf.ByteString.EMPTY, data_,
              other.data_ != com.google.protobuf.ByteString.EMPTY, other.data_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {

                  data_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognitionAudio.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognitionAudio)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognitionAudio DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognitionAudio();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAudio getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognitionAudio> PARSER;

    public static com.google.protobuf.Parser<RecognitionAudio> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ModelOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.Model)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Unique identifier of the model.  This identifier is used to choose the
     * model that should be used for recognition, and is specified in the
     * `RecognitionConfig` message.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    String getId();
    /**
     * <pre>
     * Unique identifier of the model.  This identifier is used to choose the
     * model that should be used for recognition, and is specified in the
     * `RecognitionConfig` message.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <pre>
     * Model name.  This is a concise name describing the model, and maybe
     * presented to the end-user, for example, to help choose which model to use
     * for their recognition task.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    String getName();
    /**
     * <pre>
     * Model name.  This is a concise name describing the model, and maybe
     * presented to the end-user, for example, to help choose which model to use
     * for their recognition task.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    boolean hasAttributes();
    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.ModelAttributes getAttributes();
  }
  /**
   * <pre>
   * Description of a Cubic Model
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.Model}
   */
  public  static final class Model extends
      com.google.protobuf.GeneratedMessageLite<
          Model, Model.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.Model)
      ModelOrBuilder {
    private Model() {
      id_ = "";
      name_ = "";
    }
    public static final int ID_FIELD_NUMBER = 1;
    private String id_;
    /**
     * <pre>
     * Unique identifier of the model.  This identifier is used to choose the
     * model that should be used for recognition, and is specified in the
     * `RecognitionConfig` message.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    public String getId() {
      return id_;
    }
    /**
     * <pre>
     * Unique identifier of the model.  This identifier is used to choose the
     * model that should be used for recognition, and is specified in the
     * `RecognitionConfig` message.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getIdBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(id_);
    }
    /**
     * <pre>
     * Unique identifier of the model.  This identifier is used to choose the
     * model that should be used for recognition, and is specified in the
     * `RecognitionConfig` message.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    private void setId(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      id_ = value;
    }
    /**
     * <pre>
     * Unique identifier of the model.  This identifier is used to choose the
     * model that should be used for recognition, and is specified in the
     * `RecognitionConfig` message.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    private void clearId() {
      
      id_ = getDefaultInstance().getId();
    }
    /**
     * <pre>
     * Unique identifier of the model.  This identifier is used to choose the
     * model that should be used for recognition, and is specified in the
     * `RecognitionConfig` message.
     * </pre>
     *
     * <code>optional string id = 1;</code>
     */
    private void setIdBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      id_ = value.toStringUtf8();
    }

    public static final int NAME_FIELD_NUMBER = 2;
    private String name_;
    /**
     * <pre>
     * Model name.  This is a concise name describing the model, and maybe
     * presented to the end-user, for example, to help choose which model to use
     * for their recognition task.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public String getName() {
      return name_;
    }
    /**
     * <pre>
     * Model name.  This is a concise name describing the model, and maybe
     * presented to the end-user, for example, to help choose which model to use
     * for their recognition task.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(name_);
    }
    /**
     * <pre>
     * Model name.  This is a concise name describing the model, and maybe
     * presented to the end-user, for example, to help choose which model to use
     * for their recognition task.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    private void setName(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      name_ = value;
    }
    /**
     * <pre>
     * Model name.  This is a concise name describing the model, and maybe
     * presented to the end-user, for example, to help choose which model to use
     * for their recognition task.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    private void clearName() {
      
      name_ = getDefaultInstance().getName();
    }
    /**
     * <pre>
     * Model name.  This is a concise name describing the model, and maybe
     * presented to the end-user, for example, to help choose which model to use
     * for their recognition task.
     * </pre>
     *
     * <code>optional string name = 2;</code>
     */
    private void setNameBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      name_ = value.toStringUtf8();
    }

    public static final int ATTRIBUTES_FIELD_NUMBER = 3;
    private cobaltspeech.cubic.CubicOuterClass.ModelAttributes attributes_;
    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    public boolean hasAttributes() {
      return attributes_ != null;
    }
    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.ModelAttributes getAttributes() {
      return attributes_ == null ? cobaltspeech.cubic.CubicOuterClass.ModelAttributes.getDefaultInstance() : attributes_;
    }
    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    private void setAttributes(cobaltspeech.cubic.CubicOuterClass.ModelAttributes value) {
      if (value == null) {
        throw new NullPointerException();
      }
      attributes_ = value;
      
      }
    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    private void setAttributes(
        cobaltspeech.cubic.CubicOuterClass.ModelAttributes.Builder builderForValue) {
      attributes_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    private void mergeAttributes(cobaltspeech.cubic.CubicOuterClass.ModelAttributes value) {
      if (attributes_ != null &&
          attributes_ != cobaltspeech.cubic.CubicOuterClass.ModelAttributes.getDefaultInstance()) {
        attributes_ =
          cobaltspeech.cubic.CubicOuterClass.ModelAttributes.newBuilder(attributes_).mergeFrom(value).buildPartial();
      } else {
        attributes_ = value;
      }
      
    }
    /**
     * <pre>
     * Model attributes
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
     */
    private void clearAttributes() {  attributes_ = null;
      
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!id_.isEmpty()) {
        output.writeString(1, getId());
      }
      if (!name_.isEmpty()) {
        output.writeString(2, getName());
      }
      if (attributes_ != null) {
        output.writeMessage(3, getAttributes());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!id_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getId());
      }
      if (!name_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(2, getName());
      }
      if (attributes_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAttributes());
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.Model parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.Model prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Description of a Cubic Model
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.Model}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.Model, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.Model)
        cobaltspeech.cubic.CubicOuterClass.ModelOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.Model.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Unique identifier of the model.  This identifier is used to choose the
       * model that should be used for recognition, and is specified in the
       * `RecognitionConfig` message.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public String getId() {
        return instance.getId();
      }
      /**
       * <pre>
       * Unique identifier of the model.  This identifier is used to choose the
       * model that should be used for recognition, and is specified in the
       * `RecognitionConfig` message.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        return instance.getIdBytes();
      }
      /**
       * <pre>
       * Unique identifier of the model.  This identifier is used to choose the
       * model that should be used for recognition, and is specified in the
       * `RecognitionConfig` message.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public Builder setId(
          String value) {
        copyOnWrite();
        instance.setId(value);
        return this;
      }
      /**
       * <pre>
       * Unique identifier of the model.  This identifier is used to choose the
       * model that should be used for recognition, and is specified in the
       * `RecognitionConfig` message.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public Builder clearId() {
        copyOnWrite();
        instance.clearId();
        return this;
      }
      /**
       * <pre>
       * Unique identifier of the model.  This identifier is used to choose the
       * model that should be used for recognition, and is specified in the
       * `RecognitionConfig` message.
       * </pre>
       *
       * <code>optional string id = 1;</code>
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setIdBytes(value);
        return this;
      }

      /**
       * <pre>
       * Model name.  This is a concise name describing the model, and maybe
       * presented to the end-user, for example, to help choose which model to use
       * for their recognition task.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public String getName() {
        return instance.getName();
      }
      /**
       * <pre>
       * Model name.  This is a concise name describing the model, and maybe
       * presented to the end-user, for example, to help choose which model to use
       * for their recognition task.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        return instance.getNameBytes();
      }
      /**
       * <pre>
       * Model name.  This is a concise name describing the model, and maybe
       * presented to the end-user, for example, to help choose which model to use
       * for their recognition task.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder setName(
          String value) {
        copyOnWrite();
        instance.setName(value);
        return this;
      }
      /**
       * <pre>
       * Model name.  This is a concise name describing the model, and maybe
       * presented to the end-user, for example, to help choose which model to use
       * for their recognition task.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder clearName() {
        copyOnWrite();
        instance.clearName();
        return this;
      }
      /**
       * <pre>
       * Model name.  This is a concise name describing the model, and maybe
       * presented to the end-user, for example, to help choose which model to use
       * for their recognition task.
       * </pre>
       *
       * <code>optional string name = 2;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setNameBytes(value);
        return this;
      }

      /**
       * <pre>
       * Model attributes
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
       */
      public boolean hasAttributes() {
        return instance.hasAttributes();
      }
      /**
       * <pre>
       * Model attributes
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.ModelAttributes getAttributes() {
        return instance.getAttributes();
      }
      /**
       * <pre>
       * Model attributes
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
       */
      public Builder setAttributes(cobaltspeech.cubic.CubicOuterClass.ModelAttributes value) {
        copyOnWrite();
        instance.setAttributes(value);
        return this;
        }
      /**
       * <pre>
       * Model attributes
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
       */
      public Builder setAttributes(
          cobaltspeech.cubic.CubicOuterClass.ModelAttributes.Builder builderForValue) {
        copyOnWrite();
        instance.setAttributes(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Model attributes
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
       */
      public Builder mergeAttributes(cobaltspeech.cubic.CubicOuterClass.ModelAttributes value) {
        copyOnWrite();
        instance.mergeAttributes(value);
        return this;
      }
      /**
       * <pre>
       * Model attributes
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.ModelAttributes attributes = 3;</code>
       */
      public Builder clearAttributes() {  copyOnWrite();
        instance.clearAttributes();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.Model)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.Model();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.Model other = (cobaltspeech.cubic.CubicOuterClass.Model) arg1;
          id_ = visitor.visitString(!id_.isEmpty(), id_,
              !other.id_.isEmpty(), other.id_);
          name_ = visitor.visitString(!name_.isEmpty(), name_,
              !other.name_.isEmpty(), other.name_);
          attributes_ = visitor.visitMessage(attributes_, other.attributes_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readStringRequireUtf8();

                  id_ = s;
                  break;
                }
                case 18: {
                  String s = input.readStringRequireUtf8();

                  name_ = s;
                  break;
                }
                case 26: {
                  cobaltspeech.cubic.CubicOuterClass.ModelAttributes.Builder subBuilder = null;
                  if (attributes_ != null) {
                    subBuilder = attributes_.toBuilder();
                  }
                  attributes_ = input.readMessage(cobaltspeech.cubic.CubicOuterClass.ModelAttributes.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(attributes_);
                    attributes_ = subBuilder.buildPartial();
                  }

                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.Model.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.Model)
    private static final cobaltspeech.cubic.CubicOuterClass.Model DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Model();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.Model getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Model> PARSER;

    public static com.google.protobuf.Parser<Model> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ModelAttributesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.ModelAttributes)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Audio sample rate supported by the model
     * </pre>
     *
     * <code>optional uint32 sample_rate = 1;</code>
     */
    int getSampleRate();
  }
  /**
   * <pre>
   * Attributes of a Cubic Model
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.ModelAttributes}
   */
  public  static final class ModelAttributes extends
      com.google.protobuf.GeneratedMessageLite<
          ModelAttributes, ModelAttributes.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.ModelAttributes)
      ModelAttributesOrBuilder {
    private ModelAttributes() {
    }
    public static final int SAMPLE_RATE_FIELD_NUMBER = 1;
    private int sampleRate_;
    /**
     * <pre>
     * Audio sample rate supported by the model
     * </pre>
     *
     * <code>optional uint32 sample_rate = 1;</code>
     */
    public int getSampleRate() {
      return sampleRate_;
    }
    /**
     * <pre>
     * Audio sample rate supported by the model
     * </pre>
     *
     * <code>optional uint32 sample_rate = 1;</code>
     */
    private void setSampleRate(int value) {
      
      sampleRate_ = value;
    }
    /**
     * <pre>
     * Audio sample rate supported by the model
     * </pre>
     *
     * <code>optional uint32 sample_rate = 1;</code>
     */
    private void clearSampleRate() {
      
      sampleRate_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (sampleRate_ != 0) {
        output.writeUInt32(1, sampleRate_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (sampleRate_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, sampleRate_);
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.ModelAttributes prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Attributes of a Cubic Model
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.ModelAttributes}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.ModelAttributes, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.ModelAttributes)
        cobaltspeech.cubic.CubicOuterClass.ModelAttributesOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.ModelAttributes.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Audio sample rate supported by the model
       * </pre>
       *
       * <code>optional uint32 sample_rate = 1;</code>
       */
      public int getSampleRate() {
        return instance.getSampleRate();
      }
      /**
       * <pre>
       * Audio sample rate supported by the model
       * </pre>
       *
       * <code>optional uint32 sample_rate = 1;</code>
       */
      public Builder setSampleRate(int value) {
        copyOnWrite();
        instance.setSampleRate(value);
        return this;
      }
      /**
       * <pre>
       * Audio sample rate supported by the model
       * </pre>
       *
       * <code>optional uint32 sample_rate = 1;</code>
       */
      public Builder clearSampleRate() {
        copyOnWrite();
        instance.clearSampleRate();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.ModelAttributes)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.ModelAttributes();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.ModelAttributes other = (cobaltspeech.cubic.CubicOuterClass.ModelAttributes) arg1;
          sampleRate_ = visitor.visitInt(sampleRate_ != 0, sampleRate_,
              other.sampleRate_ != 0, other.sampleRate_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 8: {

                  sampleRate_ = input.readUInt32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.ModelAttributes.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.ModelAttributes)
    private static final cobaltspeech.cubic.CubicOuterClass.ModelAttributes DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ModelAttributes();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.ModelAttributes getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ModelAttributes> PARSER;

    public static com.google.protobuf.Parser<ModelAttributes> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognitionResultOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognitionResult)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    java.util.List<cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative> 
        getAlternativesList();
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative getAlternatives(int index);
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    int getAlternativesCount();

    /**
     * <pre>
     * If this is set to true, it denotes that the result is an interim partial
     * result, and could change after more audio is processed.  If unset, or set
     * to false, it denotes that this is a final result and will not change.
     * Servers are not required to implement support for returning partial
     * results, and clients should generally not depend on their availability.
     * </pre>
     *
     * <code>optional bool is_partial = 2;</code>
     */
    boolean getIsPartial();

    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    boolean hasCnet();
    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork getCnet();

    /**
     * <pre>
     * Channel of the audio file that this result was transcribed from.  For a
     * mono file, or RAW_LINEAR16 input, this will be set to 0.
     * </pre>
     *
     * <code>optional uint32 audio_channel = 4;</code>
     */
    int getAudioChannel();
  }
  /**
   * <pre>
   * A recognition result corresponding to a portion of audio.
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognitionResult}
   */
  public  static final class RecognitionResult extends
      com.google.protobuf.GeneratedMessageLite<
          RecognitionResult, RecognitionResult.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognitionResult)
      RecognitionResultOrBuilder {
    private RecognitionResult() {
      alternatives_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int ALTERNATIVES_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative> alternatives_;
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    public java.util.List<cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative> getAlternativesList() {
      return alternatives_;
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    public java.util.List<? extends cobaltspeech.cubic.CubicOuterClass.RecognitionAlternativeOrBuilder> 
        getAlternativesOrBuilderList() {
      return alternatives_;
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    public int getAlternativesCount() {
      return alternatives_.size();
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative getAlternatives(int index) {
      return alternatives_.get(index);
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionAlternativeOrBuilder getAlternativesOrBuilder(
        int index) {
      return alternatives_.get(index);
    }
    private void ensureAlternativesIsMutable() {
      if (!alternatives_.isModifiable()) {
        alternatives_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(alternatives_);
       }
    }

    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void setAlternatives(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureAlternativesIsMutable();
      alternatives_.set(index, value);
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void setAlternatives(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.Builder builderForValue) {
      ensureAlternativesIsMutable();
      alternatives_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void addAlternatives(cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureAlternativesIsMutable();
      alternatives_.add(value);
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void addAlternatives(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureAlternativesIsMutable();
      alternatives_.add(index, value);
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void addAlternatives(
        cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.Builder builderForValue) {
      ensureAlternativesIsMutable();
      alternatives_.add(builderForValue.build());
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void addAlternatives(
        int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.Builder builderForValue) {
      ensureAlternativesIsMutable();
      alternatives_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void addAllAlternatives(
        Iterable<? extends cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative> values) {
      ensureAlternativesIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, alternatives_);
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void clearAlternatives() {
      alternatives_ = emptyProtobufList();
    }
    /**
     * <pre>
     * An n-best list of recognition hypotheses alternatives
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
     */
    private void removeAlternatives(int index) {
      ensureAlternativesIsMutable();
      alternatives_.remove(index);
    }

    public static final int IS_PARTIAL_FIELD_NUMBER = 2;
    private boolean isPartial_;
    /**
     * <pre>
     * If this is set to true, it denotes that the result is an interim partial
     * result, and could change after more audio is processed.  If unset, or set
     * to false, it denotes that this is a final result and will not change.
     * Servers are not required to implement support for returning partial
     * results, and clients should generally not depend on their availability.
     * </pre>
     *
     * <code>optional bool is_partial = 2;</code>
     */
    public boolean getIsPartial() {
      return isPartial_;
    }
    /**
     * <pre>
     * If this is set to true, it denotes that the result is an interim partial
     * result, and could change after more audio is processed.  If unset, or set
     * to false, it denotes that this is a final result and will not change.
     * Servers are not required to implement support for returning partial
     * results, and clients should generally not depend on their availability.
     * </pre>
     *
     * <code>optional bool is_partial = 2;</code>
     */
    private void setIsPartial(boolean value) {
      
      isPartial_ = value;
    }
    /**
     * <pre>
     * If this is set to true, it denotes that the result is an interim partial
     * result, and could change after more audio is processed.  If unset, or set
     * to false, it denotes that this is a final result and will not change.
     * Servers are not required to implement support for returning partial
     * results, and clients should generally not depend on their availability.
     * </pre>
     *
     * <code>optional bool is_partial = 2;</code>
     */
    private void clearIsPartial() {
      
      isPartial_ = false;
    }

    public static final int CNET_FIELD_NUMBER = 3;
    private cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork cnet_;
    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    public boolean hasCnet() {
      return cnet_ != null;
    }
    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork getCnet() {
      return cnet_ == null ? cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.getDefaultInstance() : cnet_;
    }
    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    private void setCnet(cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork value) {
      if (value == null) {
        throw new NullPointerException();
      }
      cnet_ = value;
      
      }
    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    private void setCnet(
        cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.Builder builderForValue) {
      cnet_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    private void mergeCnet(cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork value) {
      if (cnet_ != null &&
          cnet_ != cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.getDefaultInstance()) {
        cnet_ =
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.newBuilder(cnet_).mergeFrom(value).buildPartial();
      } else {
        cnet_ = value;
      }
      
    }
    /**
     * <pre>
     * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
     * and if the model supports it, a confusion network will be available in the
     * results.
     * </pre>
     *
     * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
     */
    private void clearCnet() {  cnet_ = null;
      
    }

    public static final int AUDIO_CHANNEL_FIELD_NUMBER = 4;
    private int audioChannel_;
    /**
     * <pre>
     * Channel of the audio file that this result was transcribed from.  For a
     * mono file, or RAW_LINEAR16 input, this will be set to 0.
     * </pre>
     *
     * <code>optional uint32 audio_channel = 4;</code>
     */
    public int getAudioChannel() {
      return audioChannel_;
    }
    /**
     * <pre>
     * Channel of the audio file that this result was transcribed from.  For a
     * mono file, or RAW_LINEAR16 input, this will be set to 0.
     * </pre>
     *
     * <code>optional uint32 audio_channel = 4;</code>
     */
    private void setAudioChannel(int value) {
      
      audioChannel_ = value;
    }
    /**
     * <pre>
     * Channel of the audio file that this result was transcribed from.  For a
     * mono file, or RAW_LINEAR16 input, this will be set to 0.
     * </pre>
     *
     * <code>optional uint32 audio_channel = 4;</code>
     */
    private void clearAudioChannel() {
      
      audioChannel_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < alternatives_.size(); i++) {
        output.writeMessage(1, alternatives_.get(i));
      }
      if (isPartial_ != false) {
        output.writeBool(2, isPartial_);
      }
      if (cnet_ != null) {
        output.writeMessage(3, getCnet());
      }
      if (audioChannel_ != 0) {
        output.writeUInt32(4, audioChannel_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < alternatives_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, alternatives_.get(i));
      }
      if (isPartial_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, isPartial_);
      }
      if (cnet_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getCnet());
      }
      if (audioChannel_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, audioChannel_);
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognitionResult prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A recognition result corresponding to a portion of audio.
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognitionResult}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognitionResult, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognitionResult)
        cobaltspeech.cubic.CubicOuterClass.RecognitionResultOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognitionResult.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public java.util.List<cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative> getAlternativesList() {
        return java.util.Collections.unmodifiableList(
            instance.getAlternativesList());
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public int getAlternativesCount() {
        return instance.getAlternativesCount();
      }/**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative getAlternatives(int index) {
        return instance.getAlternatives(index);
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder setAlternatives(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative value) {
        copyOnWrite();
        instance.setAlternatives(index, value);
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder setAlternatives(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.Builder builderForValue) {
        copyOnWrite();
        instance.setAlternatives(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder addAlternatives(cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative value) {
        copyOnWrite();
        instance.addAlternatives(value);
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder addAlternatives(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative value) {
        copyOnWrite();
        instance.addAlternatives(index, value);
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder addAlternatives(
          cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.Builder builderForValue) {
        copyOnWrite();
        instance.addAlternatives(builderForValue);
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder addAlternatives(
          int index, cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.Builder builderForValue) {
        copyOnWrite();
        instance.addAlternatives(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder addAllAlternatives(
          Iterable<? extends cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative> values) {
        copyOnWrite();
        instance.addAllAlternatives(values);
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder clearAlternatives() {
        copyOnWrite();
        instance.clearAlternatives();
        return this;
      }
      /**
       * <pre>
       * An n-best list of recognition hypotheses alternatives
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.RecognitionAlternative alternatives = 1;</code>
       */
      public Builder removeAlternatives(int index) {
        copyOnWrite();
        instance.removeAlternatives(index);
        return this;
      }

      /**
       * <pre>
       * If this is set to true, it denotes that the result is an interim partial
       * result, and could change after more audio is processed.  If unset, or set
       * to false, it denotes that this is a final result and will not change.
       * Servers are not required to implement support for returning partial
       * results, and clients should generally not depend on their availability.
       * </pre>
       *
       * <code>optional bool is_partial = 2;</code>
       */
      public boolean getIsPartial() {
        return instance.getIsPartial();
      }
      /**
       * <pre>
       * If this is set to true, it denotes that the result is an interim partial
       * result, and could change after more audio is processed.  If unset, or set
       * to false, it denotes that this is a final result and will not change.
       * Servers are not required to implement support for returning partial
       * results, and clients should generally not depend on their availability.
       * </pre>
       *
       * <code>optional bool is_partial = 2;</code>
       */
      public Builder setIsPartial(boolean value) {
        copyOnWrite();
        instance.setIsPartial(value);
        return this;
      }
      /**
       * <pre>
       * If this is set to true, it denotes that the result is an interim partial
       * result, and could change after more audio is processed.  If unset, or set
       * to false, it denotes that this is a final result and will not change.
       * Servers are not required to implement support for returning partial
       * results, and clients should generally not depend on their availability.
       * </pre>
       *
       * <code>optional bool is_partial = 2;</code>
       */
      public Builder clearIsPartial() {
        copyOnWrite();
        instance.clearIsPartial();
        return this;
      }

      /**
       * <pre>
       * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
       * and if the model supports it, a confusion network will be available in the
       * results.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
       */
      public boolean hasCnet() {
        return instance.hasCnet();
      }
      /**
       * <pre>
       * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
       * and if the model supports it, a confusion network will be available in the
       * results.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork getCnet() {
        return instance.getCnet();
      }
      /**
       * <pre>
       * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
       * and if the model supports it, a confusion network will be available in the
       * results.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
       */
      public Builder setCnet(cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork value) {
        copyOnWrite();
        instance.setCnet(value);
        return this;
        }
      /**
       * <pre>
       * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
       * and if the model supports it, a confusion network will be available in the
       * results.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
       */
      public Builder setCnet(
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.Builder builderForValue) {
        copyOnWrite();
        instance.setCnet(builderForValue);
        return this;
      }
      /**
       * <pre>
       * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
       * and if the model supports it, a confusion network will be available in the
       * results.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
       */
      public Builder mergeCnet(cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork value) {
        copyOnWrite();
        instance.mergeCnet(value);
        return this;
      }
      /**
       * <pre>
       * If `enable_confusion_network` was set to true in the `RecognitionConfig`,
       * and if the model supports it, a confusion network will be available in the
       * results.
       * </pre>
       *
       * <code>optional .cobaltspeech.cubic.RecognitionConfusionNetwork cnet = 3;</code>
       */
      public Builder clearCnet() {  copyOnWrite();
        instance.clearCnet();
        return this;
      }

      /**
       * <pre>
       * Channel of the audio file that this result was transcribed from.  For a
       * mono file, or RAW_LINEAR16 input, this will be set to 0.
       * </pre>
       *
       * <code>optional uint32 audio_channel = 4;</code>
       */
      public int getAudioChannel() {
        return instance.getAudioChannel();
      }
      /**
       * <pre>
       * Channel of the audio file that this result was transcribed from.  For a
       * mono file, or RAW_LINEAR16 input, this will be set to 0.
       * </pre>
       *
       * <code>optional uint32 audio_channel = 4;</code>
       */
      public Builder setAudioChannel(int value) {
        copyOnWrite();
        instance.setAudioChannel(value);
        return this;
      }
      /**
       * <pre>
       * Channel of the audio file that this result was transcribed from.  For a
       * mono file, or RAW_LINEAR16 input, this will be set to 0.
       * </pre>
       *
       * <code>optional uint32 audio_channel = 4;</code>
       */
      public Builder clearAudioChannel() {
        copyOnWrite();
        instance.clearAudioChannel();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognitionResult)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognitionResult();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          alternatives_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognitionResult other = (cobaltspeech.cubic.CubicOuterClass.RecognitionResult) arg1;
          alternatives_= visitor.visitList(alternatives_, other.alternatives_);
          isPartial_ = visitor.visitBoolean(isPartial_ != false, isPartial_,
              other.isPartial_ != false, other.isPartial_);
          cnet_ = visitor.visitMessage(cnet_, other.cnet_);
          audioChannel_ = visitor.visitInt(audioChannel_ != 0, audioChannel_,
              other.audioChannel_ != 0, other.audioChannel_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  if (!alternatives_.isModifiable()) {
                    alternatives_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(alternatives_);
                  }
                  alternatives_.add(
                      input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.parser(), extensionRegistry));
                  break;
                }
                case 16: {

                  isPartial_ = input.readBool();
                  break;
                }
                case 26: {
                  cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.Builder subBuilder = null;
                  if (cnet_ != null) {
                    subBuilder = cnet_.toBuilder();
                  }
                  cnet_ = input.readMessage(cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(cnet_);
                    cnet_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 32: {

                  audioChannel_ = input.readUInt32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognitionResult.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognitionResult)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognitionResult DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognitionResult();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionResult getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognitionResult> PARSER;

    public static com.google.protobuf.Parser<RecognitionResult> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognitionAlternativeOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognitionAlternative)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke.
     * The transcript will be formatted according to the servers formatting
     * configuration. If you want the raw transcript, please see the field
     * `raw_transcript`.  If the server is configured to not use any formatting,
     * then this field will contain the raw transcript.
     * As an example, if the spoken utterance was "four people", and the
     * server was configured to format numbers, this field would be set to
     * "4 people".
     * </pre>
     *
     * <code>optional string transcript = 1;</code>
     */
    String getTranscript();
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke.
     * The transcript will be formatted according to the servers formatting
     * configuration. If you want the raw transcript, please see the field
     * `raw_transcript`.  If the server is configured to not use any formatting,
     * then this field will contain the raw transcript.
     * As an example, if the spoken utterance was "four people", and the
     * server was configured to format numbers, this field would be set to
     * "4 people".
     * </pre>
     *
     * <code>optional string transcript = 1;</code>
     */
    com.google.protobuf.ByteString
        getTranscriptBytes();

    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke,
     * without any formatting.  This field will be populated only the config
     * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
     * field will be an empty string. If you want the formatted transcript, please
     * see the field `transcript`.
     * As an example, if the spoken utterance was `here are four words`,
     * this field would be set to "HERE ARE FOUR WORDS".
     * </pre>
     *
     * <code>optional string raw_transcript = 6;</code>
     */
    String getRawTranscript();
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke,
     * without any formatting.  This field will be populated only the config
     * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
     * field will be an empty string. If you want the formatted transcript, please
     * see the field `transcript`.
     * As an example, if the spoken utterance was `here are four words`,
     * this field would be set to "HERE ARE FOUR WORDS".
     * </pre>
     *
     * <code>optional string raw_transcript = 6;</code>
     */
    com.google.protobuf.ByteString
        getRawTranscriptBytes();

    /**
     * <pre>
     * Confidence estimate between 0 and 1. A higher number represents a higher
     * likelihood of the output being correct.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    double getConfidence();

    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    java.util.List<cobaltspeech.cubic.CubicOuterClass.WordInfo> 
        getWordsList();
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.WordInfo getWords(int index);
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    int getWordsCount();

    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    boolean hasStartTime();
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    com.google.protobuf.Duration getStartTime();

    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    boolean hasDuration();
    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    com.google.protobuf.Duration getDuration();
  }
  /**
   * <pre>
   * A recognition hypothesis
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognitionAlternative}
   */
  public  static final class RecognitionAlternative extends
      com.google.protobuf.GeneratedMessageLite<
          RecognitionAlternative, RecognitionAlternative.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognitionAlternative)
      RecognitionAlternativeOrBuilder {
    private RecognitionAlternative() {
      transcript_ = "";
      rawTranscript_ = "";
      words_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int TRANSCRIPT_FIELD_NUMBER = 1;
    private String transcript_;
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke.
     * The transcript will be formatted according to the servers formatting
     * configuration. If you want the raw transcript, please see the field
     * `raw_transcript`.  If the server is configured to not use any formatting,
     * then this field will contain the raw transcript.
     * As an example, if the spoken utterance was "four people", and the
     * server was configured to format numbers, this field would be set to
     * "4 people".
     * </pre>
     *
     * <code>optional string transcript = 1;</code>
     */
    public String getTranscript() {
      return transcript_;
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke.
     * The transcript will be formatted according to the servers formatting
     * configuration. If you want the raw transcript, please see the field
     * `raw_transcript`.  If the server is configured to not use any formatting,
     * then this field will contain the raw transcript.
     * As an example, if the spoken utterance was "four people", and the
     * server was configured to format numbers, this field would be set to
     * "4 people".
     * </pre>
     *
     * <code>optional string transcript = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTranscriptBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(transcript_);
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke.
     * The transcript will be formatted according to the servers formatting
     * configuration. If you want the raw transcript, please see the field
     * `raw_transcript`.  If the server is configured to not use any formatting,
     * then this field will contain the raw transcript.
     * As an example, if the spoken utterance was "four people", and the
     * server was configured to format numbers, this field would be set to
     * "4 people".
     * </pre>
     *
     * <code>optional string transcript = 1;</code>
     */
    private void setTranscript(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      transcript_ = value;
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke.
     * The transcript will be formatted according to the servers formatting
     * configuration. If you want the raw transcript, please see the field
     * `raw_transcript`.  If the server is configured to not use any formatting,
     * then this field will contain the raw transcript.
     * As an example, if the spoken utterance was "four people", and the
     * server was configured to format numbers, this field would be set to
     * "4 people".
     * </pre>
     *
     * <code>optional string transcript = 1;</code>
     */
    private void clearTranscript() {
      
      transcript_ = getDefaultInstance().getTranscript();
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke.
     * The transcript will be formatted according to the servers formatting
     * configuration. If you want the raw transcript, please see the field
     * `raw_transcript`.  If the server is configured to not use any formatting,
     * then this field will contain the raw transcript.
     * As an example, if the spoken utterance was "four people", and the
     * server was configured to format numbers, this field would be set to
     * "4 people".
     * </pre>
     *
     * <code>optional string transcript = 1;</code>
     */
    private void setTranscriptBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      transcript_ = value.toStringUtf8();
    }

    public static final int RAW_TRANSCRIPT_FIELD_NUMBER = 6;
    private String rawTranscript_;
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke,
     * without any formatting.  This field will be populated only the config
     * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
     * field will be an empty string. If you want the formatted transcript, please
     * see the field `transcript`.
     * As an example, if the spoken utterance was `here are four words`,
     * this field would be set to "HERE ARE FOUR WORDS".
     * </pre>
     *
     * <code>optional string raw_transcript = 6;</code>
     */
    public String getRawTranscript() {
      return rawTranscript_;
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke,
     * without any formatting.  This field will be populated only the config
     * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
     * field will be an empty string. If you want the formatted transcript, please
     * see the field `transcript`.
     * As an example, if the spoken utterance was `here are four words`,
     * this field would be set to "HERE ARE FOUR WORDS".
     * </pre>
     *
     * <code>optional string raw_transcript = 6;</code>
     */
    public com.google.protobuf.ByteString
        getRawTranscriptBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(rawTranscript_);
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke,
     * without any formatting.  This field will be populated only the config
     * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
     * field will be an empty string. If you want the formatted transcript, please
     * see the field `transcript`.
     * As an example, if the spoken utterance was `here are four words`,
     * this field would be set to "HERE ARE FOUR WORDS".
     * </pre>
     *
     * <code>optional string raw_transcript = 6;</code>
     */
    private void setRawTranscript(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      rawTranscript_ = value;
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke,
     * without any formatting.  This field will be populated only the config
     * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
     * field will be an empty string. If you want the formatted transcript, please
     * see the field `transcript`.
     * As an example, if the spoken utterance was `here are four words`,
     * this field would be set to "HERE ARE FOUR WORDS".
     * </pre>
     *
     * <code>optional string raw_transcript = 6;</code>
     */
    private void clearRawTranscript() {
      
      rawTranscript_ = getDefaultInstance().getRawTranscript();
    }
    /**
     * <pre>
     * Text representing the transcription of the words that the user spoke,
     * without any formatting.  This field will be populated only the config
     * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
     * field will be an empty string. If you want the formatted transcript, please
     * see the field `transcript`.
     * As an example, if the spoken utterance was `here are four words`,
     * this field would be set to "HERE ARE FOUR WORDS".
     * </pre>
     *
     * <code>optional string raw_transcript = 6;</code>
     */
    private void setRawTranscriptBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      rawTranscript_ = value.toStringUtf8();
    }

    public static final int CONFIDENCE_FIELD_NUMBER = 2;
    private double confidence_;
    /**
     * <pre>
     * Confidence estimate between 0 and 1. A higher number represents a higher
     * likelihood of the output being correct.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    public double getConfidence() {
      return confidence_;
    }
    /**
     * <pre>
     * Confidence estimate between 0 and 1. A higher number represents a higher
     * likelihood of the output being correct.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    private void setConfidence(double value) {
      
      confidence_ = value;
    }
    /**
     * <pre>
     * Confidence estimate between 0 and 1. A higher number represents a higher
     * likelihood of the output being correct.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    private void clearConfidence() {
      
      confidence_ = 0D;
    }

    public static final int WORDS_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<cobaltspeech.cubic.CubicOuterClass.WordInfo> words_;
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    public java.util.List<cobaltspeech.cubic.CubicOuterClass.WordInfo> getWordsList() {
      return words_;
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    public java.util.List<? extends cobaltspeech.cubic.CubicOuterClass.WordInfoOrBuilder> 
        getWordsOrBuilderList() {
      return words_;
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    public int getWordsCount() {
      return words_.size();
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.WordInfo getWords(int index) {
      return words_.get(index);
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.WordInfoOrBuilder getWordsOrBuilder(
        int index) {
      return words_.get(index);
    }
    private void ensureWordsIsMutable() {
      if (!words_.isModifiable()) {
        words_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(words_);
       }
    }

    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void setWords(
        int index, cobaltspeech.cubic.CubicOuterClass.WordInfo value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureWordsIsMutable();
      words_.set(index, value);
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void setWords(
        int index, cobaltspeech.cubic.CubicOuterClass.WordInfo.Builder builderForValue) {
      ensureWordsIsMutable();
      words_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void addWords(cobaltspeech.cubic.CubicOuterClass.WordInfo value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureWordsIsMutable();
      words_.add(value);
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void addWords(
        int index, cobaltspeech.cubic.CubicOuterClass.WordInfo value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureWordsIsMutable();
      words_.add(index, value);
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void addWords(
        cobaltspeech.cubic.CubicOuterClass.WordInfo.Builder builderForValue) {
      ensureWordsIsMutable();
      words_.add(builderForValue.build());
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void addWords(
        int index, cobaltspeech.cubic.CubicOuterClass.WordInfo.Builder builderForValue) {
      ensureWordsIsMutable();
      words_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void addAllWords(
        Iterable<? extends cobaltspeech.cubic.CubicOuterClass.WordInfo> values) {
      ensureWordsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, words_);
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void clearWords() {
      words_ = emptyProtobufList();
    }
    /**
     * <pre>
     * A list of word-specific information for each recognized word.  This is
     * available only if `enable_word_confidence` or `enable_word_time_offsets`
     * was set to `true` in the `RecognitionConfig`.
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
     */
    private void removeWords(int index) {
      ensureWordsIsMutable();
      words_.remove(index);
    }

    public static final int START_TIME_FIELD_NUMBER = 4;
    private com.google.protobuf.Duration startTime_;
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    public boolean hasStartTime() {
      return startTime_ != null;
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    public com.google.protobuf.Duration getStartTime() {
      return startTime_ == null ? com.google.protobuf.Duration.getDefaultInstance() : startTime_;
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    private void setStartTime(com.google.protobuf.Duration value) {
      if (value == null) {
        throw new NullPointerException();
      }
      startTime_ = value;
      
      }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    private void setStartTime(
        com.google.protobuf.Duration.Builder builderForValue) {
      startTime_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    private void mergeStartTime(com.google.protobuf.Duration value) {
      if (startTime_ != null &&
          startTime_ != com.google.protobuf.Duration.getDefaultInstance()) {
        startTime_ =
          com.google.protobuf.Duration.newBuilder(startTime_).mergeFrom(value).buildPartial();
      } else {
        startTime_ = value;
      }
      
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this utterance.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 4;</code>
     */
    private void clearStartTime() {  startTime_ = null;
      
    }

    public static final int DURATION_FIELD_NUMBER = 5;
    private com.google.protobuf.Duration duration_;
    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    public boolean hasDuration() {
      return duration_ != null;
    }
    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    public com.google.protobuf.Duration getDuration() {
      return duration_ == null ? com.google.protobuf.Duration.getDefaultInstance() : duration_;
    }
    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    private void setDuration(com.google.protobuf.Duration value) {
      if (value == null) {
        throw new NullPointerException();
      }
      duration_ = value;
      
      }
    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    private void setDuration(
        com.google.protobuf.Duration.Builder builderForValue) {
      duration_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    private void mergeDuration(com.google.protobuf.Duration value) {
      if (duration_ != null &&
          duration_ != com.google.protobuf.Duration.getDefaultInstance()) {
        duration_ =
          com.google.protobuf.Duration.newBuilder(duration_).mergeFrom(value).buildPartial();
      } else {
        duration_ = value;
      }
      
    }
    /**
     * <pre>
     * Duration of the current utterance in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 5;</code>
     */
    private void clearDuration() {  duration_ = null;
      
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!transcript_.isEmpty()) {
        output.writeString(1, getTranscript());
      }
      if (confidence_ != 0D) {
        output.writeDouble(2, confidence_);
      }
      for (int i = 0; i < words_.size(); i++) {
        output.writeMessage(3, words_.get(i));
      }
      if (startTime_ != null) {
        output.writeMessage(4, getStartTime());
      }
      if (duration_ != null) {
        output.writeMessage(5, getDuration());
      }
      if (!rawTranscript_.isEmpty()) {
        output.writeString(6, getRawTranscript());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!transcript_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getTranscript());
      }
      if (confidence_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(2, confidence_);
      }
      for (int i = 0; i < words_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, words_.get(i));
      }
      if (startTime_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getStartTime());
      }
      if (duration_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getDuration());
      }
      if (!rawTranscript_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(6, getRawTranscript());
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A recognition hypothesis
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognitionAlternative}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognitionAlternative)
        cobaltspeech.cubic.CubicOuterClass.RecognitionAlternativeOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke.
       * The transcript will be formatted according to the servers formatting
       * configuration. If you want the raw transcript, please see the field
       * `raw_transcript`.  If the server is configured to not use any formatting,
       * then this field will contain the raw transcript.
       * As an example, if the spoken utterance was "four people", and the
       * server was configured to format numbers, this field would be set to
       * "4 people".
       * </pre>
       *
       * <code>optional string transcript = 1;</code>
       */
      public String getTranscript() {
        return instance.getTranscript();
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke.
       * The transcript will be formatted according to the servers formatting
       * configuration. If you want the raw transcript, please see the field
       * `raw_transcript`.  If the server is configured to not use any formatting,
       * then this field will contain the raw transcript.
       * As an example, if the spoken utterance was "four people", and the
       * server was configured to format numbers, this field would be set to
       * "4 people".
       * </pre>
       *
       * <code>optional string transcript = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTranscriptBytes() {
        return instance.getTranscriptBytes();
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke.
       * The transcript will be formatted according to the servers formatting
       * configuration. If you want the raw transcript, please see the field
       * `raw_transcript`.  If the server is configured to not use any formatting,
       * then this field will contain the raw transcript.
       * As an example, if the spoken utterance was "four people", and the
       * server was configured to format numbers, this field would be set to
       * "4 people".
       * </pre>
       *
       * <code>optional string transcript = 1;</code>
       */
      public Builder setTranscript(
          String value) {
        copyOnWrite();
        instance.setTranscript(value);
        return this;
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke.
       * The transcript will be formatted according to the servers formatting
       * configuration. If you want the raw transcript, please see the field
       * `raw_transcript`.  If the server is configured to not use any formatting,
       * then this field will contain the raw transcript.
       * As an example, if the spoken utterance was "four people", and the
       * server was configured to format numbers, this field would be set to
       * "4 people".
       * </pre>
       *
       * <code>optional string transcript = 1;</code>
       */
      public Builder clearTranscript() {
        copyOnWrite();
        instance.clearTranscript();
        return this;
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke.
       * The transcript will be formatted according to the servers formatting
       * configuration. If you want the raw transcript, please see the field
       * `raw_transcript`.  If the server is configured to not use any formatting,
       * then this field will contain the raw transcript.
       * As an example, if the spoken utterance was "four people", and the
       * server was configured to format numbers, this field would be set to
       * "4 people".
       * </pre>
       *
       * <code>optional string transcript = 1;</code>
       */
      public Builder setTranscriptBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTranscriptBytes(value);
        return this;
      }

      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke,
       * without any formatting.  This field will be populated only the config
       * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
       * field will be an empty string. If you want the formatted transcript, please
       * see the field `transcript`.
       * As an example, if the spoken utterance was `here are four words`,
       * this field would be set to "HERE ARE FOUR WORDS".
       * </pre>
       *
       * <code>optional string raw_transcript = 6;</code>
       */
      public String getRawTranscript() {
        return instance.getRawTranscript();
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke,
       * without any formatting.  This field will be populated only the config
       * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
       * field will be an empty string. If you want the formatted transcript, please
       * see the field `transcript`.
       * As an example, if the spoken utterance was `here are four words`,
       * this field would be set to "HERE ARE FOUR WORDS".
       * </pre>
       *
       * <code>optional string raw_transcript = 6;</code>
       */
      public com.google.protobuf.ByteString
          getRawTranscriptBytes() {
        return instance.getRawTranscriptBytes();
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke,
       * without any formatting.  This field will be populated only the config
       * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
       * field will be an empty string. If you want the formatted transcript, please
       * see the field `transcript`.
       * As an example, if the spoken utterance was `here are four words`,
       * this field would be set to "HERE ARE FOUR WORDS".
       * </pre>
       *
       * <code>optional string raw_transcript = 6;</code>
       */
      public Builder setRawTranscript(
          String value) {
        copyOnWrite();
        instance.setRawTranscript(value);
        return this;
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke,
       * without any formatting.  This field will be populated only the config
       * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
       * field will be an empty string. If you want the formatted transcript, please
       * see the field `transcript`.
       * As an example, if the spoken utterance was `here are four words`,
       * this field would be set to "HERE ARE FOUR WORDS".
       * </pre>
       *
       * <code>optional string raw_transcript = 6;</code>
       */
      public Builder clearRawTranscript() {
        copyOnWrite();
        instance.clearRawTranscript();
        return this;
      }
      /**
       * <pre>
       * Text representing the transcription of the words that the user spoke,
       * without any formatting.  This field will be populated only the config
       * `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
       * field will be an empty string. If you want the formatted transcript, please
       * see the field `transcript`.
       * As an example, if the spoken utterance was `here are four words`,
       * this field would be set to "HERE ARE FOUR WORDS".
       * </pre>
       *
       * <code>optional string raw_transcript = 6;</code>
       */
      public Builder setRawTranscriptBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setRawTranscriptBytes(value);
        return this;
      }

      /**
       * <pre>
       * Confidence estimate between 0 and 1. A higher number represents a higher
       * likelihood of the output being correct.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public double getConfidence() {
        return instance.getConfidence();
      }
      /**
       * <pre>
       * Confidence estimate between 0 and 1. A higher number represents a higher
       * likelihood of the output being correct.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public Builder setConfidence(double value) {
        copyOnWrite();
        instance.setConfidence(value);
        return this;
      }
      /**
       * <pre>
       * Confidence estimate between 0 and 1. A higher number represents a higher
       * likelihood of the output being correct.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public Builder clearConfidence() {
        copyOnWrite();
        instance.clearConfidence();
        return this;
      }

      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public java.util.List<cobaltspeech.cubic.CubicOuterClass.WordInfo> getWordsList() {
        return java.util.Collections.unmodifiableList(
            instance.getWordsList());
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public int getWordsCount() {
        return instance.getWordsCount();
      }/**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.WordInfo getWords(int index) {
        return instance.getWords(index);
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder setWords(
          int index, cobaltspeech.cubic.CubicOuterClass.WordInfo value) {
        copyOnWrite();
        instance.setWords(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder setWords(
          int index, cobaltspeech.cubic.CubicOuterClass.WordInfo.Builder builderForValue) {
        copyOnWrite();
        instance.setWords(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder addWords(cobaltspeech.cubic.CubicOuterClass.WordInfo value) {
        copyOnWrite();
        instance.addWords(value);
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder addWords(
          int index, cobaltspeech.cubic.CubicOuterClass.WordInfo value) {
        copyOnWrite();
        instance.addWords(index, value);
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder addWords(
          cobaltspeech.cubic.CubicOuterClass.WordInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addWords(builderForValue);
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder addWords(
          int index, cobaltspeech.cubic.CubicOuterClass.WordInfo.Builder builderForValue) {
        copyOnWrite();
        instance.addWords(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder addAllWords(
          Iterable<? extends cobaltspeech.cubic.CubicOuterClass.WordInfo> values) {
        copyOnWrite();
        instance.addAllWords(values);
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder clearWords() {
        copyOnWrite();
        instance.clearWords();
        return this;
      }
      /**
       * <pre>
       * A list of word-specific information for each recognized word.  This is
       * available only if `enable_word_confidence` or `enable_word_time_offsets`
       * was set to `true` in the `RecognitionConfig`.
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.WordInfo words = 3;</code>
       */
      public Builder removeWords(int index) {
        copyOnWrite();
        instance.removeWords(index);
        return this;
      }

      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this utterance.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 4;</code>
       */
      public boolean hasStartTime() {
        return instance.hasStartTime();
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this utterance.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 4;</code>
       */
      public com.google.protobuf.Duration getStartTime() {
        return instance.getStartTime();
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this utterance.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 4;</code>
       */
      public Builder setStartTime(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.setStartTime(value);
        return this;
        }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this utterance.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 4;</code>
       */
      public Builder setStartTime(
          com.google.protobuf.Duration.Builder builderForValue) {
        copyOnWrite();
        instance.setStartTime(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this utterance.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 4;</code>
       */
      public Builder mergeStartTime(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.mergeStartTime(value);
        return this;
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this utterance.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 4;</code>
       */
      public Builder clearStartTime() {  copyOnWrite();
        instance.clearStartTime();
        return this;
      }

      /**
       * <pre>
       * Duration of the current utterance in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 5;</code>
       */
      public boolean hasDuration() {
        return instance.hasDuration();
      }
      /**
       * <pre>
       * Duration of the current utterance in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 5;</code>
       */
      public com.google.protobuf.Duration getDuration() {
        return instance.getDuration();
      }
      /**
       * <pre>
       * Duration of the current utterance in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 5;</code>
       */
      public Builder setDuration(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.setDuration(value);
        return this;
        }
      /**
       * <pre>
       * Duration of the current utterance in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 5;</code>
       */
      public Builder setDuration(
          com.google.protobuf.Duration.Builder builderForValue) {
        copyOnWrite();
        instance.setDuration(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Duration of the current utterance in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 5;</code>
       */
      public Builder mergeDuration(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.mergeDuration(value);
        return this;
      }
      /**
       * <pre>
       * Duration of the current utterance in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 5;</code>
       */
      public Builder clearDuration() {  copyOnWrite();
        instance.clearDuration();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognitionAlternative)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          words_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative other = (cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative) arg1;
          transcript_ = visitor.visitString(!transcript_.isEmpty(), transcript_,
              !other.transcript_.isEmpty(), other.transcript_);
          rawTranscript_ = visitor.visitString(!rawTranscript_.isEmpty(), rawTranscript_,
              !other.rawTranscript_.isEmpty(), other.rawTranscript_);
          confidence_ = visitor.visitDouble(confidence_ != 0D, confidence_,
              other.confidence_ != 0D, other.confidence_);
          words_= visitor.visitList(words_, other.words_);
          startTime_ = visitor.visitMessage(startTime_, other.startTime_);
          duration_ = visitor.visitMessage(duration_, other.duration_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readStringRequireUtf8();

                  transcript_ = s;
                  break;
                }
                case 17: {

                  confidence_ = input.readDouble();
                  break;
                }
                case 26: {
                  if (!words_.isModifiable()) {
                    words_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(words_);
                  }
                  words_.add(
                      input.readMessage(cobaltspeech.cubic.CubicOuterClass.WordInfo.parser(), extensionRegistry));
                  break;
                }
                case 34: {
                  com.google.protobuf.Duration.Builder subBuilder = null;
                  if (startTime_ != null) {
                    subBuilder = startTime_.toBuilder();
                  }
                  startTime_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(startTime_);
                    startTime_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 42: {
                  com.google.protobuf.Duration.Builder subBuilder = null;
                  if (duration_ != null) {
                    subBuilder = duration_.toBuilder();
                  }
                  duration_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(duration_);
                    duration_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 50: {
                  String s = input.readStringRequireUtf8();

                  rawTranscript_ = s;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognitionAlternative)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognitionAlternative();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionAlternative getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognitionAlternative> PARSER;

    public static com.google.protobuf.Parser<RecognitionAlternative> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface WordInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.WordInfo)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The actual word in the text
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    String getWord();
    /**
     * <pre>
     * The actual word in the text
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    com.google.protobuf.ByteString
        getWordBytes();

    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a
     * higher likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    double getConfidence();

    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    boolean hasStartTime();
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    com.google.protobuf.Duration getStartTime();

    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    boolean hasDuration();
    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    com.google.protobuf.Duration getDuration();
  }
  /**
   * <pre>
   * Word-specific information for recognized words
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.WordInfo}
   */
  public  static final class WordInfo extends
      com.google.protobuf.GeneratedMessageLite<
          WordInfo, WordInfo.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.WordInfo)
      WordInfoOrBuilder {
    private WordInfo() {
      word_ = "";
    }
    public static final int WORD_FIELD_NUMBER = 1;
    private String word_;
    /**
     * <pre>
     * The actual word in the text
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    public String getWord() {
      return word_;
    }
    /**
     * <pre>
     * The actual word in the text
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    public com.google.protobuf.ByteString
        getWordBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(word_);
    }
    /**
     * <pre>
     * The actual word in the text
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    private void setWord(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      word_ = value;
    }
    /**
     * <pre>
     * The actual word in the text
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    private void clearWord() {
      
      word_ = getDefaultInstance().getWord();
    }
    /**
     * <pre>
     * The actual word in the text
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    private void setWordBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      word_ = value.toStringUtf8();
    }

    public static final int CONFIDENCE_FIELD_NUMBER = 2;
    private double confidence_;
    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a
     * higher likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    public double getConfidence() {
      return confidence_;
    }
    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a
     * higher likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    private void setConfidence(double value) {
      
      confidence_ = value;
    }
    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a
     * higher likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    private void clearConfidence() {
      
      confidence_ = 0D;
    }

    public static final int START_TIME_FIELD_NUMBER = 3;
    private com.google.protobuf.Duration startTime_;
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    public boolean hasStartTime() {
      return startTime_ != null;
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    public com.google.protobuf.Duration getStartTime() {
      return startTime_ == null ? com.google.protobuf.Duration.getDefaultInstance() : startTime_;
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    private void setStartTime(com.google.protobuf.Duration value) {
      if (value == null) {
        throw new NullPointerException();
      }
      startTime_ = value;
      
      }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    private void setStartTime(
        com.google.protobuf.Duration.Builder builderForValue) {
      startTime_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    private void mergeStartTime(com.google.protobuf.Duration value) {
      if (startTime_ != null &&
          startTime_ != com.google.protobuf.Duration.getDefaultInstance()) {
        startTime_ =
          com.google.protobuf.Duration.newBuilder(startTime_).mergeFrom(value).buildPartial();
      } else {
        startTime_ = value;
      }
      
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this spoken word.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 3;</code>
     */
    private void clearStartTime() {  startTime_ = null;
      
    }

    public static final int DURATION_FIELD_NUMBER = 4;
    private com.google.protobuf.Duration duration_;
    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    public boolean hasDuration() {
      return duration_ != null;
    }
    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    public com.google.protobuf.Duration getDuration() {
      return duration_ == null ? com.google.protobuf.Duration.getDefaultInstance() : duration_;
    }
    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    private void setDuration(com.google.protobuf.Duration value) {
      if (value == null) {
        throw new NullPointerException();
      }
      duration_ = value;
      
      }
    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    private void setDuration(
        com.google.protobuf.Duration.Builder builderForValue) {
      duration_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    private void mergeDuration(com.google.protobuf.Duration value) {
      if (duration_ != null &&
          duration_ != com.google.protobuf.Duration.getDefaultInstance()) {
        duration_ =
          com.google.protobuf.Duration.newBuilder(duration_).mergeFrom(value).buildPartial();
      } else {
        duration_ = value;
      }
      
    }
    /**
     * <pre>
     * Duration of the current word in the spoken audio.
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 4;</code>
     */
    private void clearDuration() {  duration_ = null;
      
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!word_.isEmpty()) {
        output.writeString(1, getWord());
      }
      if (confidence_ != 0D) {
        output.writeDouble(2, confidence_);
      }
      if (startTime_ != null) {
        output.writeMessage(3, getStartTime());
      }
      if (duration_ != null) {
        output.writeMessage(4, getDuration());
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!word_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getWord());
      }
      if (confidence_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(2, confidence_);
      }
      if (startTime_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStartTime());
      }
      if (duration_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getDuration());
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.WordInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.WordInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Word-specific information for recognized words
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.WordInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.WordInfo, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.WordInfo)
        cobaltspeech.cubic.CubicOuterClass.WordInfoOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.WordInfo.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The actual word in the text
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public String getWord() {
        return instance.getWord();
      }
      /**
       * <pre>
       * The actual word in the text
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public com.google.protobuf.ByteString
          getWordBytes() {
        return instance.getWordBytes();
      }
      /**
       * <pre>
       * The actual word in the text
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public Builder setWord(
          String value) {
        copyOnWrite();
        instance.setWord(value);
        return this;
      }
      /**
       * <pre>
       * The actual word in the text
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public Builder clearWord() {
        copyOnWrite();
        instance.clearWord();
        return this;
      }
      /**
       * <pre>
       * The actual word in the text
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public Builder setWordBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setWordBytes(value);
        return this;
      }

      /**
       * <pre>
       * Confidence estimate between 0 and 1.  A higher number represents a
       * higher likelihood that the word was correctly recognized.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public double getConfidence() {
        return instance.getConfidence();
      }
      /**
       * <pre>
       * Confidence estimate between 0 and 1.  A higher number represents a
       * higher likelihood that the word was correctly recognized.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public Builder setConfidence(double value) {
        copyOnWrite();
        instance.setConfidence(value);
        return this;
      }
      /**
       * <pre>
       * Confidence estimate between 0 and 1.  A higher number represents a
       * higher likelihood that the word was correctly recognized.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public Builder clearConfidence() {
        copyOnWrite();
        instance.clearConfidence();
        return this;
      }

      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this spoken word.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 3;</code>
       */
      public boolean hasStartTime() {
        return instance.hasStartTime();
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this spoken word.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 3;</code>
       */
      public com.google.protobuf.Duration getStartTime() {
        return instance.getStartTime();
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this spoken word.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 3;</code>
       */
      public Builder setStartTime(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.setStartTime(value);
        return this;
        }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this spoken word.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 3;</code>
       */
      public Builder setStartTime(
          com.google.protobuf.Duration.Builder builderForValue) {
        copyOnWrite();
        instance.setStartTime(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this spoken word.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 3;</code>
       */
      public Builder mergeStartTime(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.mergeStartTime(value);
        return this;
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this spoken word.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 3;</code>
       */
      public Builder clearStartTime() {  copyOnWrite();
        instance.clearStartTime();
        return this;
      }

      /**
       * <pre>
       * Duration of the current word in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 4;</code>
       */
      public boolean hasDuration() {
        return instance.hasDuration();
      }
      /**
       * <pre>
       * Duration of the current word in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 4;</code>
       */
      public com.google.protobuf.Duration getDuration() {
        return instance.getDuration();
      }
      /**
       * <pre>
       * Duration of the current word in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 4;</code>
       */
      public Builder setDuration(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.setDuration(value);
        return this;
        }
      /**
       * <pre>
       * Duration of the current word in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 4;</code>
       */
      public Builder setDuration(
          com.google.protobuf.Duration.Builder builderForValue) {
        copyOnWrite();
        instance.setDuration(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Duration of the current word in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 4;</code>
       */
      public Builder mergeDuration(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.mergeDuration(value);
        return this;
      }
      /**
       * <pre>
       * Duration of the current word in the spoken audio.
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 4;</code>
       */
      public Builder clearDuration() {  copyOnWrite();
        instance.clearDuration();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.WordInfo)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.WordInfo();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.WordInfo other = (cobaltspeech.cubic.CubicOuterClass.WordInfo) arg1;
          word_ = visitor.visitString(!word_.isEmpty(), word_,
              !other.word_.isEmpty(), other.word_);
          confidence_ = visitor.visitDouble(confidence_ != 0D, confidence_,
              other.confidence_ != 0D, other.confidence_);
          startTime_ = visitor.visitMessage(startTime_, other.startTime_);
          duration_ = visitor.visitMessage(duration_, other.duration_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readStringRequireUtf8();

                  word_ = s;
                  break;
                }
                case 17: {

                  confidence_ = input.readDouble();
                  break;
                }
                case 26: {
                  com.google.protobuf.Duration.Builder subBuilder = null;
                  if (startTime_ != null) {
                    subBuilder = startTime_.toBuilder();
                  }
                  startTime_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(startTime_);
                    startTime_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 34: {
                  com.google.protobuf.Duration.Builder subBuilder = null;
                  if (duration_ != null) {
                    subBuilder = duration_.toBuilder();
                  }
                  duration_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(duration_);
                    duration_ = subBuilder.buildPartial();
                  }

                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.WordInfo.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.WordInfo)
    private static final cobaltspeech.cubic.CubicOuterClass.WordInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new WordInfo();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.WordInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<WordInfo> PARSER;

    public static com.google.protobuf.Parser<WordInfo> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface RecognitionConfusionNetworkOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.RecognitionConfusionNetwork)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    java.util.List<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink> 
        getLinksList();
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink getLinks(int index);
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    int getLinksCount();
  }
  /**
   * <pre>
   * Confusion network in recognition output
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.RecognitionConfusionNetwork}
   */
  public  static final class RecognitionConfusionNetwork extends
      com.google.protobuf.GeneratedMessageLite<
          RecognitionConfusionNetwork, RecognitionConfusionNetwork.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.RecognitionConfusionNetwork)
      RecognitionConfusionNetworkOrBuilder {
    private RecognitionConfusionNetwork() {
      links_ = emptyProtobufList();
    }
    public static final int LINKS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.ProtobufList<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink> links_;
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    public java.util.List<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink> getLinksList() {
      return links_;
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    public java.util.List<? extends cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLinkOrBuilder> 
        getLinksOrBuilderList() {
      return links_;
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    public int getLinksCount() {
      return links_.size();
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink getLinks(int index) {
      return links_.get(index);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLinkOrBuilder getLinksOrBuilder(
        int index) {
      return links_.get(index);
    }
    private void ensureLinksIsMutable() {
      if (!links_.isModifiable()) {
        links_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(links_);
       }
    }

    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void setLinks(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureLinksIsMutable();
      links_.set(index, value);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void setLinks(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.Builder builderForValue) {
      ensureLinksIsMutable();
      links_.set(index, builderForValue.build());
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void addLinks(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureLinksIsMutable();
      links_.add(value);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void addLinks(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureLinksIsMutable();
      links_.add(index, value);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void addLinks(
        cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.Builder builderForValue) {
      ensureLinksIsMutable();
      links_.add(builderForValue.build());
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void addLinks(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.Builder builderForValue) {
      ensureLinksIsMutable();
      links_.add(index, builderForValue.build());
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void addAllLinks(
        Iterable<? extends cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink> values) {
      ensureLinksIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, links_);
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void clearLinks() {
      links_ = emptyProtobufList();
    }
    /**
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
     */
    private void removeLinks(int index) {
      ensureLinksIsMutable();
      links_.remove(index);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < links_.size(); i++) {
        output.writeMessage(1, links_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < links_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, links_.get(i));
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Confusion network in recognition output
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.RecognitionConfusionNetwork}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.RecognitionConfusionNetwork)
        cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetworkOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public java.util.List<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink> getLinksList() {
        return java.util.Collections.unmodifiableList(
            instance.getLinksList());
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public int getLinksCount() {
        return instance.getLinksCount();
      }/**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink getLinks(int index) {
        return instance.getLinks(index);
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder setLinks(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink value) {
        copyOnWrite();
        instance.setLinks(index, value);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder setLinks(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.Builder builderForValue) {
        copyOnWrite();
        instance.setLinks(index, builderForValue);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder addLinks(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink value) {
        copyOnWrite();
        instance.addLinks(value);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder addLinks(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink value) {
        copyOnWrite();
        instance.addLinks(index, value);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder addLinks(
          cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.Builder builderForValue) {
        copyOnWrite();
        instance.addLinks(builderForValue);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder addLinks(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.Builder builderForValue) {
        copyOnWrite();
        instance.addLinks(index, builderForValue);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder addAllLinks(
          Iterable<? extends cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink> values) {
        copyOnWrite();
        instance.addAllLinks(values);
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder clearLinks() {
        copyOnWrite();
        instance.clearLinks();
        return this;
      }
      /**
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkLink links = 1;</code>
       */
      public Builder removeLinks(int index) {
        copyOnWrite();
        instance.removeLinks(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.RecognitionConfusionNetwork)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          links_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork other = (cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork) arg1;
          links_= visitor.visitList(links_, other.links_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  if (!links_.isModifiable()) {
                    links_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(links_);
                  }
                  links_.add(
                      input.readMessage(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.parser(), extensionRegistry));
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.RecognitionConfusionNetwork)
    private static final cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RecognitionConfusionNetwork();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.RecognitionConfusionNetwork getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<RecognitionConfusionNetwork> PARSER;

    public static com.google.protobuf.Parser<RecognitionConfusionNetwork> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ConfusionNetworkLinkOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.ConfusionNetworkLink)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    boolean hasStartTime();
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    com.google.protobuf.Duration getStartTime();

    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    boolean hasDuration();
    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    com.google.protobuf.Duration getDuration();

    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    java.util.List<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc> 
        getArcsList();
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc getArcs(int index);
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    int getArcsCount();
  }
  /**
   * <pre>
   * A Link inside a confusion network
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.ConfusionNetworkLink}
   */
  public  static final class ConfusionNetworkLink extends
      com.google.protobuf.GeneratedMessageLite<
          ConfusionNetworkLink, ConfusionNetworkLink.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.ConfusionNetworkLink)
      ConfusionNetworkLinkOrBuilder {
    private ConfusionNetworkLink() {
      arcs_ = emptyProtobufList();
    }
    private int bitField0_;
    public static final int START_TIME_FIELD_NUMBER = 1;
    private com.google.protobuf.Duration startTime_;
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    public boolean hasStartTime() {
      return startTime_ != null;
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    public com.google.protobuf.Duration getStartTime() {
      return startTime_ == null ? com.google.protobuf.Duration.getDefaultInstance() : startTime_;
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    private void setStartTime(com.google.protobuf.Duration value) {
      if (value == null) {
        throw new NullPointerException();
      }
      startTime_ = value;
      
      }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    private void setStartTime(
        com.google.protobuf.Duration.Builder builderForValue) {
      startTime_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    private void mergeStartTime(com.google.protobuf.Duration value) {
      if (startTime_ != null &&
          startTime_ != com.google.protobuf.Duration.getDefaultInstance()) {
        startTime_ =
          com.google.protobuf.Duration.newBuilder(startTime_).mergeFrom(value).buildPartial();
      } else {
        startTime_ = value;
      }
      
    }
    /**
     * <pre>
     * Time offset relative to the beginning of audio received by the recognizer
     * and corresponding to the start of this link
     * </pre>
     *
     * <code>optional .google.protobuf.Duration start_time = 1;</code>
     */
    private void clearStartTime() {  startTime_ = null;
      
    }

    public static final int DURATION_FIELD_NUMBER = 2;
    private com.google.protobuf.Duration duration_;
    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    public boolean hasDuration() {
      return duration_ != null;
    }
    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    public com.google.protobuf.Duration getDuration() {
      return duration_ == null ? com.google.protobuf.Duration.getDefaultInstance() : duration_;
    }
    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    private void setDuration(com.google.protobuf.Duration value) {
      if (value == null) {
        throw new NullPointerException();
      }
      duration_ = value;
      
      }
    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    private void setDuration(
        com.google.protobuf.Duration.Builder builderForValue) {
      duration_ = builderForValue.build();
      
    }
    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    private void mergeDuration(com.google.protobuf.Duration value) {
      if (duration_ != null &&
          duration_ != com.google.protobuf.Duration.getDefaultInstance()) {
        duration_ =
          com.google.protobuf.Duration.newBuilder(duration_).mergeFrom(value).buildPartial();
      } else {
        duration_ = value;
      }
      
    }
    /**
     * <pre>
     * Duration of the current link in the confusion network
     * </pre>
     *
     * <code>optional .google.protobuf.Duration duration = 2;</code>
     */
    private void clearDuration() {  duration_ = null;
      
    }

    public static final int ARCS_FIELD_NUMBER = 3;
    private com.google.protobuf.Internal.ProtobufList<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc> arcs_;
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    public java.util.List<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc> getArcsList() {
      return arcs_;
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    public java.util.List<? extends cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArcOrBuilder> 
        getArcsOrBuilderList() {
      return arcs_;
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    public int getArcsCount() {
      return arcs_.size();
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc getArcs(int index) {
      return arcs_.get(index);
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    public cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArcOrBuilder getArcsOrBuilder(
        int index) {
      return arcs_.get(index);
    }
    private void ensureArcsIsMutable() {
      if (!arcs_.isModifiable()) {
        arcs_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(arcs_);
       }
    }

    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void setArcs(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureArcsIsMutable();
      arcs_.set(index, value);
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void setArcs(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.Builder builderForValue) {
      ensureArcsIsMutable();
      arcs_.set(index, builderForValue.build());
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void addArcs(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureArcsIsMutable();
      arcs_.add(value);
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void addArcs(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc value) {
      if (value == null) {
        throw new NullPointerException();
      }
      ensureArcsIsMutable();
      arcs_.add(index, value);
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void addArcs(
        cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.Builder builderForValue) {
      ensureArcsIsMutable();
      arcs_.add(builderForValue.build());
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void addArcs(
        int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.Builder builderForValue) {
      ensureArcsIsMutable();
      arcs_.add(index, builderForValue.build());
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void addAllArcs(
        Iterable<? extends cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc> values) {
      ensureArcsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, arcs_);
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void clearArcs() {
      arcs_ = emptyProtobufList();
    }
    /**
     * <pre>
     * Arcs between this link
     * </pre>
     *
     * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
     */
    private void removeArcs(int index) {
      ensureArcsIsMutable();
      arcs_.remove(index);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (startTime_ != null) {
        output.writeMessage(1, getStartTime());
      }
      if (duration_ != null) {
        output.writeMessage(2, getDuration());
      }
      for (int i = 0; i < arcs_.size(); i++) {
        output.writeMessage(3, arcs_.get(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (startTime_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getStartTime());
      }
      if (duration_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getDuration());
      }
      for (int i = 0; i < arcs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, arcs_.get(i));
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * A Link inside a confusion network
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.ConfusionNetworkLink}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.ConfusionNetworkLink)
        cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLinkOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this link
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 1;</code>
       */
      public boolean hasStartTime() {
        return instance.hasStartTime();
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this link
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 1;</code>
       */
      public com.google.protobuf.Duration getStartTime() {
        return instance.getStartTime();
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this link
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 1;</code>
       */
      public Builder setStartTime(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.setStartTime(value);
        return this;
        }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this link
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 1;</code>
       */
      public Builder setStartTime(
          com.google.protobuf.Duration.Builder builderForValue) {
        copyOnWrite();
        instance.setStartTime(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this link
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 1;</code>
       */
      public Builder mergeStartTime(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.mergeStartTime(value);
        return this;
      }
      /**
       * <pre>
       * Time offset relative to the beginning of audio received by the recognizer
       * and corresponding to the start of this link
       * </pre>
       *
       * <code>optional .google.protobuf.Duration start_time = 1;</code>
       */
      public Builder clearStartTime() {  copyOnWrite();
        instance.clearStartTime();
        return this;
      }

      /**
       * <pre>
       * Duration of the current link in the confusion network
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 2;</code>
       */
      public boolean hasDuration() {
        return instance.hasDuration();
      }
      /**
       * <pre>
       * Duration of the current link in the confusion network
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 2;</code>
       */
      public com.google.protobuf.Duration getDuration() {
        return instance.getDuration();
      }
      /**
       * <pre>
       * Duration of the current link in the confusion network
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 2;</code>
       */
      public Builder setDuration(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.setDuration(value);
        return this;
        }
      /**
       * <pre>
       * Duration of the current link in the confusion network
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 2;</code>
       */
      public Builder setDuration(
          com.google.protobuf.Duration.Builder builderForValue) {
        copyOnWrite();
        instance.setDuration(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Duration of the current link in the confusion network
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 2;</code>
       */
      public Builder mergeDuration(com.google.protobuf.Duration value) {
        copyOnWrite();
        instance.mergeDuration(value);
        return this;
      }
      /**
       * <pre>
       * Duration of the current link in the confusion network
       * </pre>
       *
       * <code>optional .google.protobuf.Duration duration = 2;</code>
       */
      public Builder clearDuration() {  copyOnWrite();
        instance.clearDuration();
        return this;
      }

      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public java.util.List<cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc> getArcsList() {
        return java.util.Collections.unmodifiableList(
            instance.getArcsList());
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public int getArcsCount() {
        return instance.getArcsCount();
      }/**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc getArcs(int index) {
        return instance.getArcs(index);
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder setArcs(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc value) {
        copyOnWrite();
        instance.setArcs(index, value);
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder setArcs(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.Builder builderForValue) {
        copyOnWrite();
        instance.setArcs(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder addArcs(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc value) {
        copyOnWrite();
        instance.addArcs(value);
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder addArcs(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc value) {
        copyOnWrite();
        instance.addArcs(index, value);
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder addArcs(
          cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.Builder builderForValue) {
        copyOnWrite();
        instance.addArcs(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder addArcs(
          int index, cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.Builder builderForValue) {
        copyOnWrite();
        instance.addArcs(index, builderForValue);
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder addAllArcs(
          Iterable<? extends cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc> values) {
        copyOnWrite();
        instance.addAllArcs(values);
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder clearArcs() {
        copyOnWrite();
        instance.clearArcs();
        return this;
      }
      /**
       * <pre>
       * Arcs between this link
       * </pre>
       *
       * <code>repeated .cobaltspeech.cubic.ConfusionNetworkArc arcs = 3;</code>
       */
      public Builder removeArcs(int index) {
        copyOnWrite();
        instance.removeArcs(index);
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.ConfusionNetworkLink)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          arcs_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink other = (cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink) arg1;
          startTime_ = visitor.visitMessage(startTime_, other.startTime_);
          duration_ = visitor.visitMessage(duration_, other.duration_);
          arcs_= visitor.visitList(arcs_, other.arcs_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  com.google.protobuf.Duration.Builder subBuilder = null;
                  if (startTime_ != null) {
                    subBuilder = startTime_.toBuilder();
                  }
                  startTime_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(startTime_);
                    startTime_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 18: {
                  com.google.protobuf.Duration.Builder subBuilder = null;
                  if (duration_ != null) {
                    subBuilder = duration_.toBuilder();
                  }
                  duration_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(duration_);
                    duration_ = subBuilder.buildPartial();
                  }

                  break;
                }
                case 26: {
                  if (!arcs_.isModifiable()) {
                    arcs_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(arcs_);
                  }
                  arcs_.add(
                      input.readMessage(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.parser(), extensionRegistry));
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.ConfusionNetworkLink)
    private static final cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ConfusionNetworkLink();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkLink getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ConfusionNetworkLink> PARSER;

    public static com.google.protobuf.Parser<ConfusionNetworkLink> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ConfusionNetworkArcOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cobaltspeech.cubic.ConfusionNetworkArc)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Word in the recognized transcript
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    String getWord();
    /**
     * <pre>
     * Word in the recognized transcript
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    com.google.protobuf.ByteString
        getWordBytes();

    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a higher
     * likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    double getConfidence();
  }
  /**
   * <pre>
   * An Arc inside a Confusion Network Link
   * </pre>
   *
   * Protobuf type {@code cobaltspeech.cubic.ConfusionNetworkArc}
   */
  public  static final class ConfusionNetworkArc extends
      com.google.protobuf.GeneratedMessageLite<
          ConfusionNetworkArc, ConfusionNetworkArc.Builder> implements
      // @@protoc_insertion_point(message_implements:cobaltspeech.cubic.ConfusionNetworkArc)
      ConfusionNetworkArcOrBuilder {
    private ConfusionNetworkArc() {
      word_ = "";
    }
    public static final int WORD_FIELD_NUMBER = 1;
    private String word_;
    /**
     * <pre>
     * Word in the recognized transcript
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    public String getWord() {
      return word_;
    }
    /**
     * <pre>
     * Word in the recognized transcript
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    public com.google.protobuf.ByteString
        getWordBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(word_);
    }
    /**
     * <pre>
     * Word in the recognized transcript
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    private void setWord(
        String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  
      word_ = value;
    }
    /**
     * <pre>
     * Word in the recognized transcript
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    private void clearWord() {
      
      word_ = getDefaultInstance().getWord();
    }
    /**
     * <pre>
     * Word in the recognized transcript
     * </pre>
     *
     * <code>optional string word = 1;</code>
     */
    private void setWordBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      
      word_ = value.toStringUtf8();
    }

    public static final int CONFIDENCE_FIELD_NUMBER = 2;
    private double confidence_;
    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a higher
     * likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    public double getConfidence() {
      return confidence_;
    }
    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a higher
     * likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    private void setConfidence(double value) {
      
      confidence_ = value;
    }
    /**
     * <pre>
     * Confidence estimate between 0 and 1.  A higher number represents a higher
     * likelihood that the word was correctly recognized.
     * </pre>
     *
     * <code>optional double confidence = 2;</code>
     */
    private void clearConfidence() {
      
      confidence_ = 0D;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!word_.isEmpty()) {
        output.writeString(1, getWord());
      }
      if (confidence_ != 0D) {
        output.writeDouble(2, confidence_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (!word_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(1, getWord());
      }
      if (confidence_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(2, confidence_);
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * An Arc inside a Confusion Network Link
     * </pre>
     *
     * Protobuf type {@code cobaltspeech.cubic.ConfusionNetworkArc}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc, Builder> implements
        // @@protoc_insertion_point(builder_implements:cobaltspeech.cubic.ConfusionNetworkArc)
        cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArcOrBuilder {
      // Construct using cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Word in the recognized transcript
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public String getWord() {
        return instance.getWord();
      }
      /**
       * <pre>
       * Word in the recognized transcript
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public com.google.protobuf.ByteString
          getWordBytes() {
        return instance.getWordBytes();
      }
      /**
       * <pre>
       * Word in the recognized transcript
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public Builder setWord(
          String value) {
        copyOnWrite();
        instance.setWord(value);
        return this;
      }
      /**
       * <pre>
       * Word in the recognized transcript
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public Builder clearWord() {
        copyOnWrite();
        instance.clearWord();
        return this;
      }
      /**
       * <pre>
       * Word in the recognized transcript
       * </pre>
       *
       * <code>optional string word = 1;</code>
       */
      public Builder setWordBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setWordBytes(value);
        return this;
      }

      /**
       * <pre>
       * Confidence estimate between 0 and 1.  A higher number represents a higher
       * likelihood that the word was correctly recognized.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public double getConfidence() {
        return instance.getConfidence();
      }
      /**
       * <pre>
       * Confidence estimate between 0 and 1.  A higher number represents a higher
       * likelihood that the word was correctly recognized.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public Builder setConfidence(double value) {
        copyOnWrite();
        instance.setConfidence(value);
        return this;
      }
      /**
       * <pre>
       * Confidence estimate between 0 and 1.  A higher number represents a higher
       * likelihood that the word was correctly recognized.
       * </pre>
       *
       * <code>optional double confidence = 2;</code>
       */
      public Builder clearConfidence() {
        copyOnWrite();
        instance.clearConfidence();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:cobaltspeech.cubic.ConfusionNetworkArc)
    }
    protected final Object dynamicMethod(
        MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc other = (cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc) arg1;
          word_ = visitor.visitString(!word_.isEmpty(), word_,
              !other.word_.isEmpty(), other.word_);
          confidence_ = visitor.visitDouble(confidence_ != 0D, confidence_,
              other.confidence_ != 0D, other.confidence_);
          if (visitor == MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  String s = input.readStringRequireUtf8();

                  word_ = s;
                  break;
                }
                case 17: {

                  confidence_ = input.readDouble();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:cobaltspeech.cubic.ConfusionNetworkArc)
    private static final cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ConfusionNetworkArc();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static cobaltspeech.cubic.CubicOuterClass.ConfusionNetworkArc getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ConfusionNetworkArc> PARSER;

    public static com.google.protobuf.Parser<ConfusionNetworkArc> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
