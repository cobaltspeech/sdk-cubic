// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cubic.proto

package cubicpb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	empty "github.com/golang/protobuf/ptypes/empty"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The encoding of the audio data to be sent for recognition.
//
// For best results, the audio source should be captured and transmitted using
// the RAW_LINEAR16 encoding.
type RecognitionConfig_Encoding int32

const (
	// Raw (headerless) Uncompressed 16-bit signed little endian samples (linear
	// PCM), single channel, sampled at the rate expected by the chosen `Model`.
	RecognitionConfig_RAW_LINEAR16 RecognitionConfig_Encoding = 0
	// WAV (data with RIFF headers), with data sampled at a rate equal to or
	// higher than the sample rate expected by the chosen Model.
	RecognitionConfig_WAV RecognitionConfig_Encoding = 1
	// MP3 data, sampled at a rate equal to or higher than the sampling rate
	// expected by the chosen Model.
	RecognitionConfig_MP3 RecognitionConfig_Encoding = 2
	// FLAC data, sampled at a rate equal to or higher than the sample rate
	// expected by the chosen Model.
	RecognitionConfig_FLAC RecognitionConfig_Encoding = 3
	// VOX data (Dialogic ADPCM), sampled at 8 KHz.
	RecognitionConfig_VOX8000 RecognitionConfig_Encoding = 4
	// Î¼-law (8-bit) encoded RAW data, single channel, sampled at 8 KHz.
	RecognitionConfig_ULAW8000 RecognitionConfig_Encoding = 5
)

var RecognitionConfig_Encoding_name = map[int32]string{
	0: "RAW_LINEAR16",
	1: "WAV",
	2: "MP3",
	3: "FLAC",
	4: "VOX8000",
	5: "ULAW8000",
}

var RecognitionConfig_Encoding_value = map[string]int32{
	"RAW_LINEAR16": 0,
	"WAV":          1,
	"MP3":          2,
	"FLAC":         3,
	"VOX8000":      4,
	"ULAW8000":     5,
}

func (x RecognitionConfig_Encoding) String() string {
	return proto.EnumName(RecognitionConfig_Encoding_name, int32(x))
}

func (RecognitionConfig_Encoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{6, 0}
}

// The top-level message sent by the client for the `ListModels` method.
type ListModelsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListModelsRequest) Reset()         { *m = ListModelsRequest{} }
func (m *ListModelsRequest) String() string { return proto.CompactTextString(m) }
func (*ListModelsRequest) ProtoMessage()    {}
func (*ListModelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{0}
}

func (m *ListModelsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListModelsRequest.Unmarshal(m, b)
}
func (m *ListModelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListModelsRequest.Marshal(b, m, deterministic)
}
func (m *ListModelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListModelsRequest.Merge(m, src)
}
func (m *ListModelsRequest) XXX_Size() int {
	return xxx_messageInfo_ListModelsRequest.Size(m)
}
func (m *ListModelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListModelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListModelsRequest proto.InternalMessageInfo

// The top-level message sent by the client for the `Recognize` method.  Both
// the `RecognitionConfig` and `RecognitionAudio` fields are required.  The
// entire audio data must be sent in one request.  If your audio data is larger,
// please use the `StreamingRecognize` call..
type RecognizeRequest struct {
	// Provides configuration to create the recognizer.
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	// The audio data to be recognized
	Audio                *RecognitionAudio `protobuf:"bytes,2,opt,name=audio,proto3" json:"audio,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RecognizeRequest) Reset()         { *m = RecognizeRequest{} }
func (m *RecognizeRequest) String() string { return proto.CompactTextString(m) }
func (*RecognizeRequest) ProtoMessage()    {}
func (*RecognizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{1}
}

func (m *RecognizeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognizeRequest.Unmarshal(m, b)
}
func (m *RecognizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognizeRequest.Marshal(b, m, deterministic)
}
func (m *RecognizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognizeRequest.Merge(m, src)
}
func (m *RecognizeRequest) XXX_Size() int {
	return xxx_messageInfo_RecognizeRequest.Size(m)
}
func (m *RecognizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecognizeRequest proto.InternalMessageInfo

func (m *RecognizeRequest) GetConfig() *RecognitionConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *RecognizeRequest) GetAudio() *RecognitionAudio {
	if m != nil {
		return m.Audio
	}
	return nil
}

// The top-level message sent by the client for the `StreamingRecognize`
// request.  Multiple `StreamingRecognizeRequest` messages are sent. The first
// message must contain a `RecognitionConfig` message only, and all subsequent
// messages must contain `RecognitionAudio` only.  All `RecognitionAudio`
// messages must contain non-empty audio.  If audio content is empty, the server
// may interpret it as end of stream and stop accepting any further messages.
type StreamingRecognizeRequest struct {
	// Types that are valid to be assigned to Request:
	//	*StreamingRecognizeRequest_Config
	//	*StreamingRecognizeRequest_Audio
	Request              isStreamingRecognizeRequest_Request `protobuf_oneof:"request"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *StreamingRecognizeRequest) Reset()         { *m = StreamingRecognizeRequest{} }
func (m *StreamingRecognizeRequest) String() string { return proto.CompactTextString(m) }
func (*StreamingRecognizeRequest) ProtoMessage()    {}
func (*StreamingRecognizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{2}
}

func (m *StreamingRecognizeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StreamingRecognizeRequest.Unmarshal(m, b)
}
func (m *StreamingRecognizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StreamingRecognizeRequest.Marshal(b, m, deterministic)
}
func (m *StreamingRecognizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamingRecognizeRequest.Merge(m, src)
}
func (m *StreamingRecognizeRequest) XXX_Size() int {
	return xxx_messageInfo_StreamingRecognizeRequest.Size(m)
}
func (m *StreamingRecognizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamingRecognizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamingRecognizeRequest proto.InternalMessageInfo

type isStreamingRecognizeRequest_Request interface {
	isStreamingRecognizeRequest_Request()
}

type StreamingRecognizeRequest_Config struct {
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config,proto3,oneof"`
}

type StreamingRecognizeRequest_Audio struct {
	Audio *RecognitionAudio `protobuf:"bytes,2,opt,name=audio,proto3,oneof"`
}

func (*StreamingRecognizeRequest_Config) isStreamingRecognizeRequest_Request() {}

func (*StreamingRecognizeRequest_Audio) isStreamingRecognizeRequest_Request() {}

func (m *StreamingRecognizeRequest) GetRequest() isStreamingRecognizeRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *StreamingRecognizeRequest) GetConfig() *RecognitionConfig {
	if x, ok := m.GetRequest().(*StreamingRecognizeRequest_Config); ok {
		return x.Config
	}
	return nil
}

func (m *StreamingRecognizeRequest) GetAudio() *RecognitionAudio {
	if x, ok := m.GetRequest().(*StreamingRecognizeRequest_Audio); ok {
		return x.Audio
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StreamingRecognizeRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StreamingRecognizeRequest_Config)(nil),
		(*StreamingRecognizeRequest_Audio)(nil),
	}
}

// The message sent by the server for the `Version` method.
type VersionResponse struct {
	// version of the cubic library handling the recognition
	Cubic string `protobuf:"bytes,1,opt,name=cubic,proto3" json:"cubic,omitempty"`
	// version of the server handling these requests
	Server               string   `protobuf:"bytes,2,opt,name=server,proto3" json:"server,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VersionResponse) Reset()         { *m = VersionResponse{} }
func (m *VersionResponse) String() string { return proto.CompactTextString(m) }
func (*VersionResponse) ProtoMessage()    {}
func (*VersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{3}
}

func (m *VersionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VersionResponse.Unmarshal(m, b)
}
func (m *VersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VersionResponse.Marshal(b, m, deterministic)
}
func (m *VersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionResponse.Merge(m, src)
}
func (m *VersionResponse) XXX_Size() int {
	return xxx_messageInfo_VersionResponse.Size(m)
}
func (m *VersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VersionResponse proto.InternalMessageInfo

func (m *VersionResponse) GetCubic() string {
	if m != nil {
		return m.Cubic
	}
	return ""
}

func (m *VersionResponse) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

// The message returned to the client by the `ListModels` method.
type ListModelsResponse struct {
	// List of models available for use that match the request.
	Models               []*Model `protobuf:"bytes,1,rep,name=models,proto3" json:"models,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListModelsResponse) Reset()         { *m = ListModelsResponse{} }
func (m *ListModelsResponse) String() string { return proto.CompactTextString(m) }
func (*ListModelsResponse) ProtoMessage()    {}
func (*ListModelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{4}
}

func (m *ListModelsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListModelsResponse.Unmarshal(m, b)
}
func (m *ListModelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListModelsResponse.Marshal(b, m, deterministic)
}
func (m *ListModelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListModelsResponse.Merge(m, src)
}
func (m *ListModelsResponse) XXX_Size() int {
	return xxx_messageInfo_ListModelsResponse.Size(m)
}
func (m *ListModelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListModelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListModelsResponse proto.InternalMessageInfo

func (m *ListModelsResponse) GetModels() []*Model {
	if m != nil {
		return m.Models
	}
	return nil
}

// Collection of sequence of recognition results in a portion of audio.  When
// transcribing a single audio channel (e.g. RAW_LINEAR16 input, or a mono
// file), results will be ordered chronologically.  When transcribing multiple
// channels, the results of all channels will be interleaved.  Results of each
// individual channel will be chronological.  No such promise is made for the
// ordering of results of different channels, as results are returned for each
// channel individually as soon as they are ready.
type RecognitionResponse struct {
	Results              []*RecognitionResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RecognitionResponse) Reset()         { *m = RecognitionResponse{} }
func (m *RecognitionResponse) String() string { return proto.CompactTextString(m) }
func (*RecognitionResponse) ProtoMessage()    {}
func (*RecognitionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{5}
}

func (m *RecognitionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognitionResponse.Unmarshal(m, b)
}
func (m *RecognitionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognitionResponse.Marshal(b, m, deterministic)
}
func (m *RecognitionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionResponse.Merge(m, src)
}
func (m *RecognitionResponse) XXX_Size() int {
	return xxx_messageInfo_RecognitionResponse.Size(m)
}
func (m *RecognitionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionResponse proto.InternalMessageInfo

func (m *RecognitionResponse) GetResults() []*RecognitionResult {
	if m != nil {
		return m.Results
	}
	return nil
}

// Configuration for setting up a Recognizer
type RecognitionConfig struct {
	// Unique identifier of the model to use, as obtained from a `Model` message.
	ModelId string `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id,omitempty"`
	// Encoding of audio data sent/streamed through the `RecognitionAudio`
	// messages.  For encodings like WAV/MP3 that have headers, the headers are
	// expected to be sent at the beginning of the stream, not in every
	// `RecognitionAudio` message.
	//
	// If not specified, the default encoding is RAW_LINEAR16.
	//
	// Depending on how they are configured, server instances of this service may
	// not support all the encodings enumerated above. They are always required to
	// accept RAW_LINEAR16.  If any other `Encoding` is specified, and it is not
	// available on the server being used, the recognition request will result in
	// an appropriate error message.
	AudioEncoding RecognitionConfig_Encoding `protobuf:"varint,2,opt,name=audio_encoding,json=audioEncoding,proto3,enum=cobaltspeech.cubic.RecognitionConfig_Encoding" json:"audio_encoding,omitempty"`
	// Idle Timeout of the created Recognizer.  If no audio data is received by
	// the recognizer for this duration, ongoing rpc calls will result in an
	// error, the recognizer will be destroyed and thus more audio may not be sent
	// to the same recognizer.  The server may impose a limit on the maximum idle
	// timeout that can be specified, and if the value in this message exceeds
	// that serverside value, creating of the recognizer will fail with an error.
	IdleTimeout *duration.Duration `protobuf:"bytes,3,opt,name=idle_timeout,json=idleTimeout,proto3" json:"idle_timeout,omitempty"`
	// This is an optional field.  If this is set to true, each result will
	// include a list of words and the start time offset (timestamp) and the
	// duration for each of those words.  If set to `false`, no word-level
	// timestamps will be returned.  The default is `false`.
	EnableWordTimeOffsets bool `protobuf:"varint,4,opt,name=enable_word_time_offsets,json=enableWordTimeOffsets,proto3" json:"enable_word_time_offsets,omitempty"`
	// This is an optional field.  If this is set to true, each result will
	// include a list of words and the confidence for those words.  If `false`, no
	// word-level confidence information is returned.  The default is `false`.
	EnableWordConfidence bool `protobuf:"varint,5,opt,name=enable_word_confidence,json=enableWordConfidence,proto3" json:"enable_word_confidence,omitempty"`
	// This is an optional field.  If this is set to true, the field
	// `RecognitionAlternative.raw_transcript` will be populated with the raw
	// transcripts output from the recognizer will be exposed without any
	// formatting rules applied.  If this is set to false, that field will not
	// be set in the results.  The RecognitionAlternative.transcript will
	// always be populated with text formatted according to the server's settings.
	EnableRawTranscript bool `protobuf:"varint,6,opt,name=enable_raw_transcript,json=enableRawTranscript,proto3" json:"enable_raw_transcript,omitempty"`
	// This is an optional field.  If this is set to true, the results will
	// include a confusion network.  If set to `false`, no confusion network will
	// be returned.  The default is `false`.  If the model being used does not
	// support a confusion network, results may be returned without a confusion
	// network available.  If this field is set to `true`, then
	// `enable_raw_transcript` is also forced to be true.
	EnableConfusionNetwork bool `protobuf:"varint,7,opt,name=enable_confusion_network,json=enableConfusionNetwork,proto3" json:"enable_confusion_network,omitempty"`
	// This is an optional field.  If the audio has multiple channels, this field
	// should be configured with the list of channel indices that should be
	// transcribed.  Channels are 0-indexed.
	//
	// Example: `[0]` for a mono file, `[0, 1]` for a stereo file.
	//
	// If this field is not set, a mono file will be assumed by default and only
	// channel-0 will be transcribed even if the file actually has additional
	// channels.
	//
	// Channels that are present in the audio may be omitted, but it is an error
	// to include a channel index in this field that is not present in the audio.
	// Channels may be listed in any order but the same index may not be repeated
	// in this list.
	//
	// BAD: `[0, 2]` for a stereo file; BAD: `[0, 0]` for a mono file.
	AudioChannels        []uint32 `protobuf:"varint,8,rep,packed,name=audio_channels,json=audioChannels,proto3" json:"audio_channels,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecognitionConfig) Reset()         { *m = RecognitionConfig{} }
func (m *RecognitionConfig) String() string { return proto.CompactTextString(m) }
func (*RecognitionConfig) ProtoMessage()    {}
func (*RecognitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{6}
}

func (m *RecognitionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognitionConfig.Unmarshal(m, b)
}
func (m *RecognitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognitionConfig.Marshal(b, m, deterministic)
}
func (m *RecognitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionConfig.Merge(m, src)
}
func (m *RecognitionConfig) XXX_Size() int {
	return xxx_messageInfo_RecognitionConfig.Size(m)
}
func (m *RecognitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionConfig proto.InternalMessageInfo

func (m *RecognitionConfig) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *RecognitionConfig) GetAudioEncoding() RecognitionConfig_Encoding {
	if m != nil {
		return m.AudioEncoding
	}
	return RecognitionConfig_RAW_LINEAR16
}

func (m *RecognitionConfig) GetIdleTimeout() *duration.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *RecognitionConfig) GetEnableWordTimeOffsets() bool {
	if m != nil {
		return m.EnableWordTimeOffsets
	}
	return false
}

func (m *RecognitionConfig) GetEnableWordConfidence() bool {
	if m != nil {
		return m.EnableWordConfidence
	}
	return false
}

func (m *RecognitionConfig) GetEnableRawTranscript() bool {
	if m != nil {
		return m.EnableRawTranscript
	}
	return false
}

func (m *RecognitionConfig) GetEnableConfusionNetwork() bool {
	if m != nil {
		return m.EnableConfusionNetwork
	}
	return false
}

func (m *RecognitionConfig) GetAudioChannels() []uint32 {
	if m != nil {
		return m.AudioChannels
	}
	return nil
}

// Audio to be sent to the recognizer
type RecognitionAudio struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecognitionAudio) Reset()         { *m = RecognitionAudio{} }
func (m *RecognitionAudio) String() string { return proto.CompactTextString(m) }
func (*RecognitionAudio) ProtoMessage()    {}
func (*RecognitionAudio) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{7}
}

func (m *RecognitionAudio) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognitionAudio.Unmarshal(m, b)
}
func (m *RecognitionAudio) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognitionAudio.Marshal(b, m, deterministic)
}
func (m *RecognitionAudio) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionAudio.Merge(m, src)
}
func (m *RecognitionAudio) XXX_Size() int {
	return xxx_messageInfo_RecognitionAudio.Size(m)
}
func (m *RecognitionAudio) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionAudio.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionAudio proto.InternalMessageInfo

func (m *RecognitionAudio) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Description of a Cubic Model
type Model struct {
	// Unique identifier of the model.  This identifier is used to choose the
	// model that should be used for recognition, and is specified in the
	// `RecognitionConfig` message.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Model name.  This is a concise name describing the model, and maybe
	// presented to the end-user, for example, to help choose which model to use
	// for their recognition task.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Model attributes
	Attributes           *ModelAttributes `protobuf:"bytes,3,opt,name=attributes,proto3" json:"attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Model) Reset()         { *m = Model{} }
func (m *Model) String() string { return proto.CompactTextString(m) }
func (*Model) ProtoMessage()    {}
func (*Model) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{8}
}

func (m *Model) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Model.Unmarshal(m, b)
}
func (m *Model) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Model.Marshal(b, m, deterministic)
}
func (m *Model) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Model.Merge(m, src)
}
func (m *Model) XXX_Size() int {
	return xxx_messageInfo_Model.Size(m)
}
func (m *Model) XXX_DiscardUnknown() {
	xxx_messageInfo_Model.DiscardUnknown(m)
}

var xxx_messageInfo_Model proto.InternalMessageInfo

func (m *Model) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Model) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Model) GetAttributes() *ModelAttributes {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// Attributes of a Cubic Model
type ModelAttributes struct {
	// Audio sample rate supported by the model
	SampleRate           uint32   `protobuf:"varint,1,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ModelAttributes) Reset()         { *m = ModelAttributes{} }
func (m *ModelAttributes) String() string { return proto.CompactTextString(m) }
func (*ModelAttributes) ProtoMessage()    {}
func (*ModelAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{9}
}

func (m *ModelAttributes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModelAttributes.Unmarshal(m, b)
}
func (m *ModelAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModelAttributes.Marshal(b, m, deterministic)
}
func (m *ModelAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelAttributes.Merge(m, src)
}
func (m *ModelAttributes) XXX_Size() int {
	return xxx_messageInfo_ModelAttributes.Size(m)
}
func (m *ModelAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_ModelAttributes proto.InternalMessageInfo

func (m *ModelAttributes) GetSampleRate() uint32 {
	if m != nil {
		return m.SampleRate
	}
	return 0
}

// A recognition result corresponding to a portion of audio.
type RecognitionResult struct {
	// An n-best list of recognition hypotheses alternatives
	Alternatives []*RecognitionAlternative `protobuf:"bytes,1,rep,name=alternatives,proto3" json:"alternatives,omitempty"`
	// If this is set to true, it denotes that the result is an interim partial
	// result, and could change after more audio is processed.  If unset, or set
	// to false, it denotes that this is a final result and will not change.
	//
	// Servers are not required to implement support for returning partial
	// results, and clients should generally not depend on their availability.
	IsPartial bool `protobuf:"varint,2,opt,name=is_partial,json=isPartial,proto3" json:"is_partial,omitempty"`
	// If `enable_confusion_network` was set to true in the `RecognitionConfig`,
	// and if the model supports it, a confusion network will be available in the
	// results.
	Cnet *RecognitionConfusionNetwork `protobuf:"bytes,3,opt,name=cnet,proto3" json:"cnet,omitempty"`
	// Channel of the audio file that this result was transcribed from.  For a
	// mono file, or RAW_LINEAR16 input, this will be set to 0.
	AudioChannel         uint32   `protobuf:"varint,4,opt,name=audio_channel,json=audioChannel,proto3" json:"audio_channel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecognitionResult) Reset()         { *m = RecognitionResult{} }
func (m *RecognitionResult) String() string { return proto.CompactTextString(m) }
func (*RecognitionResult) ProtoMessage()    {}
func (*RecognitionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{10}
}

func (m *RecognitionResult) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognitionResult.Unmarshal(m, b)
}
func (m *RecognitionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognitionResult.Marshal(b, m, deterministic)
}
func (m *RecognitionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionResult.Merge(m, src)
}
func (m *RecognitionResult) XXX_Size() int {
	return xxx_messageInfo_RecognitionResult.Size(m)
}
func (m *RecognitionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionResult.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionResult proto.InternalMessageInfo

func (m *RecognitionResult) GetAlternatives() []*RecognitionAlternative {
	if m != nil {
		return m.Alternatives
	}
	return nil
}

func (m *RecognitionResult) GetIsPartial() bool {
	if m != nil {
		return m.IsPartial
	}
	return false
}

func (m *RecognitionResult) GetCnet() *RecognitionConfusionNetwork {
	if m != nil {
		return m.Cnet
	}
	return nil
}

func (m *RecognitionResult) GetAudioChannel() uint32 {
	if m != nil {
		return m.AudioChannel
	}
	return 0
}

// A recognition hypothesis
type RecognitionAlternative struct {
	// Text representing the transcription of the words that the user spoke.
	//
	// The transcript will be formatted according to the servers formatting
	// configuration. If you want the raw transcript, please see the field
	// `raw_transcript`.  If the server is configured to not use any formatting,
	// then this field will contain the raw transcript.
	//
	// As an example, if the spoken utterance was "four people", and the
	// server was configured to format numbers, this field would be set to
	// "4 people".
	Transcript string `protobuf:"bytes,1,opt,name=transcript,proto3" json:"transcript,omitempty"`
	// Text representing the transcription of the words that the user spoke,
	// without any formatting.  This field will be populated only the config
	// `RecognitionConfig.enable_raw_transcript` is set to true. Otherwise this
	// field will be an empty string. If you want the formatted transcript, please
	// see the field `transcript`.
	//
	// As an example, if the spoken utterance was `here are four words`,
	// this field would be set to "HERE ARE FOUR WORDS".
	RawTranscript string `protobuf:"bytes,6,opt,name=raw_transcript,json=rawTranscript,proto3" json:"raw_transcript,omitempty"`
	// Confidence estimate between 0 and 1. A higher number represents a higher
	// likelihood of the output being correct.
	Confidence float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// A list of word-specific information for each recognized word.  This is
	// available only if `enable_word_confidence` or `enable_word_time_offsets`
	// was set to `true` in the `RecognitionConfig`.
	Words []*WordInfo `protobuf:"bytes,3,rep,name=words,proto3" json:"words,omitempty"`
	// Time offset relative to the beginning of audio received by the recognizer
	// and corresponding to the start of this utterance.
	StartTime *duration.Duration `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Duration of the current utterance in the spoken audio.
	Duration             *duration.Duration `protobuf:"bytes,5,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RecognitionAlternative) Reset()         { *m = RecognitionAlternative{} }
func (m *RecognitionAlternative) String() string { return proto.CompactTextString(m) }
func (*RecognitionAlternative) ProtoMessage()    {}
func (*RecognitionAlternative) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{11}
}

func (m *RecognitionAlternative) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognitionAlternative.Unmarshal(m, b)
}
func (m *RecognitionAlternative) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognitionAlternative.Marshal(b, m, deterministic)
}
func (m *RecognitionAlternative) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionAlternative.Merge(m, src)
}
func (m *RecognitionAlternative) XXX_Size() int {
	return xxx_messageInfo_RecognitionAlternative.Size(m)
}
func (m *RecognitionAlternative) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionAlternative.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionAlternative proto.InternalMessageInfo

func (m *RecognitionAlternative) GetTranscript() string {
	if m != nil {
		return m.Transcript
	}
	return ""
}

func (m *RecognitionAlternative) GetRawTranscript() string {
	if m != nil {
		return m.RawTranscript
	}
	return ""
}

func (m *RecognitionAlternative) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *RecognitionAlternative) GetWords() []*WordInfo {
	if m != nil {
		return m.Words
	}
	return nil
}

func (m *RecognitionAlternative) GetStartTime() *duration.Duration {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *RecognitionAlternative) GetDuration() *duration.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

// Word-specific information for recognized words
type WordInfo struct {
	// The actual word in the text
	Word string `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	// Confidence estimate between 0 and 1.  A higher number represents a
	// higher likelihood that the word was correctly recognized.
	Confidence float64 `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// Time offset relative to the beginning of audio received by the recognizer
	// and corresponding to the start of this spoken word.
	StartTime *duration.Duration `protobuf:"bytes,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Duration of the current word in the spoken audio.
	Duration             *duration.Duration `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *WordInfo) Reset()         { *m = WordInfo{} }
func (m *WordInfo) String() string { return proto.CompactTextString(m) }
func (*WordInfo) ProtoMessage()    {}
func (*WordInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{12}
}

func (m *WordInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WordInfo.Unmarshal(m, b)
}
func (m *WordInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WordInfo.Marshal(b, m, deterministic)
}
func (m *WordInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WordInfo.Merge(m, src)
}
func (m *WordInfo) XXX_Size() int {
	return xxx_messageInfo_WordInfo.Size(m)
}
func (m *WordInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WordInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WordInfo proto.InternalMessageInfo

func (m *WordInfo) GetWord() string {
	if m != nil {
		return m.Word
	}
	return ""
}

func (m *WordInfo) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *WordInfo) GetStartTime() *duration.Duration {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *WordInfo) GetDuration() *duration.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

// Confusion network in recognition output
type RecognitionConfusionNetwork struct {
	Links                []*ConfusionNetworkLink `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *RecognitionConfusionNetwork) Reset()         { *m = RecognitionConfusionNetwork{} }
func (m *RecognitionConfusionNetwork) String() string { return proto.CompactTextString(m) }
func (*RecognitionConfusionNetwork) ProtoMessage()    {}
func (*RecognitionConfusionNetwork) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{13}
}

func (m *RecognitionConfusionNetwork) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RecognitionConfusionNetwork.Unmarshal(m, b)
}
func (m *RecognitionConfusionNetwork) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RecognitionConfusionNetwork.Marshal(b, m, deterministic)
}
func (m *RecognitionConfusionNetwork) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecognitionConfusionNetwork.Merge(m, src)
}
func (m *RecognitionConfusionNetwork) XXX_Size() int {
	return xxx_messageInfo_RecognitionConfusionNetwork.Size(m)
}
func (m *RecognitionConfusionNetwork) XXX_DiscardUnknown() {
	xxx_messageInfo_RecognitionConfusionNetwork.DiscardUnknown(m)
}

var xxx_messageInfo_RecognitionConfusionNetwork proto.InternalMessageInfo

func (m *RecognitionConfusionNetwork) GetLinks() []*ConfusionNetworkLink {
	if m != nil {
		return m.Links
	}
	return nil
}

// A Link inside a confusion network
type ConfusionNetworkLink struct {
	// Time offset relative to the beginning of audio received by the recognizer
	// and corresponding to the start of this link
	StartTime *duration.Duration `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Duration of the current link in the confusion network
	Duration *duration.Duration `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty"`
	// Arcs between this link
	Arcs                 []*ConfusionNetworkArc `protobuf:"bytes,3,rep,name=arcs,proto3" json:"arcs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ConfusionNetworkLink) Reset()         { *m = ConfusionNetworkLink{} }
func (m *ConfusionNetworkLink) String() string { return proto.CompactTextString(m) }
func (*ConfusionNetworkLink) ProtoMessage()    {}
func (*ConfusionNetworkLink) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{14}
}

func (m *ConfusionNetworkLink) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfusionNetworkLink.Unmarshal(m, b)
}
func (m *ConfusionNetworkLink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfusionNetworkLink.Marshal(b, m, deterministic)
}
func (m *ConfusionNetworkLink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfusionNetworkLink.Merge(m, src)
}
func (m *ConfusionNetworkLink) XXX_Size() int {
	return xxx_messageInfo_ConfusionNetworkLink.Size(m)
}
func (m *ConfusionNetworkLink) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfusionNetworkLink.DiscardUnknown(m)
}

var xxx_messageInfo_ConfusionNetworkLink proto.InternalMessageInfo

func (m *ConfusionNetworkLink) GetStartTime() *duration.Duration {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ConfusionNetworkLink) GetDuration() *duration.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *ConfusionNetworkLink) GetArcs() []*ConfusionNetworkArc {
	if m != nil {
		return m.Arcs
	}
	return nil
}

// An Arc inside a Confusion Network Link
type ConfusionNetworkArc struct {
	// Word in the recognized transcript
	Word string `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	// Confidence estimate between 0 and 1.  A higher number represents a higher
	// likelihood that the word was correctly recognized.
	Confidence           float64  `protobuf:"fixed64,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfusionNetworkArc) Reset()         { *m = ConfusionNetworkArc{} }
func (m *ConfusionNetworkArc) String() string { return proto.CompactTextString(m) }
func (*ConfusionNetworkArc) ProtoMessage()    {}
func (*ConfusionNetworkArc) Descriptor() ([]byte, []int) {
	return fileDescriptor_82ad8c6e2ec8aa3b, []int{15}
}

func (m *ConfusionNetworkArc) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfusionNetworkArc.Unmarshal(m, b)
}
func (m *ConfusionNetworkArc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfusionNetworkArc.Marshal(b, m, deterministic)
}
func (m *ConfusionNetworkArc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfusionNetworkArc.Merge(m, src)
}
func (m *ConfusionNetworkArc) XXX_Size() int {
	return xxx_messageInfo_ConfusionNetworkArc.Size(m)
}
func (m *ConfusionNetworkArc) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfusionNetworkArc.DiscardUnknown(m)
}

var xxx_messageInfo_ConfusionNetworkArc proto.InternalMessageInfo

func (m *ConfusionNetworkArc) GetWord() string {
	if m != nil {
		return m.Word
	}
	return ""
}

func (m *ConfusionNetworkArc) GetConfidence() float64 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func init() {
	proto.RegisterEnum("cobaltspeech.cubic.RecognitionConfig_Encoding", RecognitionConfig_Encoding_name, RecognitionConfig_Encoding_value)
	proto.RegisterType((*ListModelsRequest)(nil), "cobaltspeech.cubic.ListModelsRequest")
	proto.RegisterType((*RecognizeRequest)(nil), "cobaltspeech.cubic.RecognizeRequest")
	proto.RegisterType((*StreamingRecognizeRequest)(nil), "cobaltspeech.cubic.StreamingRecognizeRequest")
	proto.RegisterType((*VersionResponse)(nil), "cobaltspeech.cubic.VersionResponse")
	proto.RegisterType((*ListModelsResponse)(nil), "cobaltspeech.cubic.ListModelsResponse")
	proto.RegisterType((*RecognitionResponse)(nil), "cobaltspeech.cubic.RecognitionResponse")
	proto.RegisterType((*RecognitionConfig)(nil), "cobaltspeech.cubic.RecognitionConfig")
	proto.RegisterType((*RecognitionAudio)(nil), "cobaltspeech.cubic.RecognitionAudio")
	proto.RegisterType((*Model)(nil), "cobaltspeech.cubic.Model")
	proto.RegisterType((*ModelAttributes)(nil), "cobaltspeech.cubic.ModelAttributes")
	proto.RegisterType((*RecognitionResult)(nil), "cobaltspeech.cubic.RecognitionResult")
	proto.RegisterType((*RecognitionAlternative)(nil), "cobaltspeech.cubic.RecognitionAlternative")
	proto.RegisterType((*WordInfo)(nil), "cobaltspeech.cubic.WordInfo")
	proto.RegisterType((*RecognitionConfusionNetwork)(nil), "cobaltspeech.cubic.RecognitionConfusionNetwork")
	proto.RegisterType((*ConfusionNetworkLink)(nil), "cobaltspeech.cubic.ConfusionNetworkLink")
	proto.RegisterType((*ConfusionNetworkArc)(nil), "cobaltspeech.cubic.ConfusionNetworkArc")
}

func init() { proto.RegisterFile("cubic.proto", fileDescriptor_82ad8c6e2ec8aa3b) }

var fileDescriptor_82ad8c6e2ec8aa3b = []byte{
	// 1118 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4f, 0x6f, 0x1b, 0x55,
	0x10, 0xef, 0xfa, 0x4f, 0x6c, 0x8f, 0xed, 0xd4, 0x1d, 0x87, 0xe0, 0xa4, 0x25, 0x44, 0x5b, 0xda,
	0x5a, 0x95, 0x70, 0x52, 0x97, 0x3f, 0x55, 0x29, 0x54, 0xae, 0x09, 0x34, 0x52, 0x9a, 0x56, 0x2f,
	0x6d, 0x82, 0x10, 0xc8, 0x7a, 0xde, 0x7d, 0x71, 0x9f, 0x62, 0xbf, 0x35, 0xbb, 0xcf, 0x89, 0xe0,
	0x88, 0xc4, 0x91, 0x13, 0x57, 0x8e, 0x70, 0xe1, 0xc2, 0x97, 0xe0, 0x1b, 0x70, 0xe3, 0xcc, 0x91,
	0x0f, 0x81, 0x76, 0xf6, 0xed, 0xc6, 0x89, 0xdd, 0xd8, 0xca, 0x6d, 0xf7, 0xcd, 0xfc, 0xe6, 0xfd,
	0x66, 0xe6, 0x37, 0xbb, 0x03, 0x45, 0x67, 0xd4, 0x95, 0x4e, 0x63, 0xe8, 0x7b, 0xda, 0x43, 0x74,
	0xbc, 0x2e, 0xef, 0xeb, 0x60, 0x28, 0x84, 0xf3, 0xba, 0x41, 0x96, 0xd5, 0x1b, 0x3d, 0xcf, 0xeb,
	0xf5, 0xc5, 0x06, 0x1f, 0xca, 0x0d, 0xae, 0x94, 0xa7, 0xb9, 0x96, 0x9e, 0x0a, 0x22, 0xc4, 0xea,
	0x9a, 0xb1, 0xd2, 0x5b, 0x77, 0x74, 0xb8, 0xe1, 0x8e, 0x7c, 0x72, 0x30, 0xf6, 0xeb, 0xe7, 0xed,
	0x62, 0x30, 0xd4, 0xdf, 0x47, 0x46, 0xbb, 0x0a, 0xd7, 0x76, 0x64, 0xa0, 0x9f, 0x79, 0xae, 0xe8,
	0x07, 0x4c, 0x7c, 0x37, 0x12, 0x81, 0xb6, 0x7f, 0xb6, 0xa0, 0xc2, 0x84, 0xe3, 0xf5, 0x94, 0xfc,
	0x41, 0x98, 0x43, 0xfc, 0x14, 0x16, 0x1c, 0x4f, 0x1d, 0xca, 0x5e, 0xcd, 0x5a, 0xb7, 0xea, 0xc5,
	0xe6, 0xad, 0xc6, 0x24, 0xd3, 0x86, 0x41, 0x85, 0xb7, 0xb7, 0xc9, 0x99, 0x19, 0x10, 0x3e, 0x84,
	0x2c, 0x1f, 0xb9, 0xd2, 0xab, 0xa5, 0x08, 0xfd, 0xde, 0x0c, 0x74, 0x2b, 0xf4, 0x65, 0x11, 0xc4,
	0xfe, 0xdd, 0x82, 0x95, 0x3d, 0xed, 0x0b, 0x3e, 0x90, 0xaa, 0x37, 0x41, 0xec, 0xf1, 0xa5, 0x88,
	0x3d, 0xbd, 0x92, 0x50, 0x7b, 0x74, 0x09, 0x6a, 0x4f, 0xaf, 0x18, 0x72, 0x4f, 0x0a, 0x90, 0xf3,
	0x4d, 0xdd, 0x1e, 0xc3, 0xd5, 0x7d, 0xe1, 0x07, 0xd2, 0x53, 0x4c, 0x04, 0x43, 0x4f, 0x05, 0x02,
	0x97, 0x20, 0x4b, 0x01, 0x88, 0x5b, 0x81, 0x45, 0x2f, 0xb8, 0x0c, 0x0b, 0x81, 0xf0, 0x8f, 0x85,
	0x4f, 0x57, 0x16, 0x98, 0x79, 0xb3, 0xbf, 0x04, 0x1c, 0xef, 0x86, 0x89, 0x71, 0x0f, 0x16, 0x06,
	0x74, 0x52, 0xb3, 0xd6, 0xd3, 0xf5, 0x62, 0x73, 0x65, 0x1a, 0x41, 0xc2, 0x30, 0xe3, 0x68, 0xef,
	0x43, 0x75, 0x8c, 0x71, 0x12, 0xe9, 0x71, 0xc8, 0x35, 0x18, 0xf5, 0x75, 0x1c, 0x6a, 0x56, 0xad,
	0x18, 0x79, 0xb3, 0x18, 0x65, 0xff, 0x9a, 0x81, 0x6b, 0x13, 0xa5, 0xc4, 0x15, 0xc8, 0xd3, 0xbd,
	0x1d, 0xe9, 0x9a, 0x3c, 0x73, 0xf4, 0xbe, 0xed, 0xe2, 0x2b, 0x58, 0xa4, 0x32, 0x75, 0x84, 0x72,
	0x3c, 0x57, 0xaa, 0x1e, 0x65, 0xbc, 0xd8, 0x6c, 0xcc, 0xd5, 0xa4, 0xc6, 0x96, 0x41, 0xb1, 0x32,
	0x45, 0x89, 0x5f, 0xf1, 0x11, 0x94, 0xa4, 0xdb, 0x17, 0x1d, 0x2d, 0x07, 0xc2, 0x1b, 0xe9, 0x5a,
	0x9a, 0x3a, 0xb7, 0xd2, 0x88, 0xa4, 0xde, 0x88, 0xa5, 0xde, 0xf8, 0xdc, 0x8c, 0x02, 0x2b, 0x86,
	0xee, 0x2f, 0x23, 0x6f, 0xfc, 0x18, 0x6a, 0x42, 0xf1, 0x6e, 0x5f, 0x74, 0x4e, 0x3c, 0xdf, 0xa5,
	0x20, 0x1d, 0xef, 0xf0, 0x30, 0x10, 0x3a, 0xa8, 0x65, 0xd6, 0xad, 0x7a, 0x9e, 0xbd, 0x15, 0xd9,
	0x0f, 0x3c, 0xdf, 0x0d, 0x41, 0xcf, 0x23, 0x23, 0x7e, 0x00, 0xcb, 0xe3, 0x40, 0xd2, 0x8f, 0x2b,
	0x94, 0x23, 0x6a, 0x59, 0x82, 0x2d, 0x9d, 0xc2, 0xda, 0x89, 0x0d, 0x9b, 0x60, 0xc2, 0x75, 0x7c,
	0x7e, 0xd2, 0xd1, 0x3e, 0x57, 0x81, 0xe3, 0xcb, 0xa1, 0xae, 0x2d, 0x10, 0xa8, 0x1a, 0x19, 0x19,
	0x3f, 0x79, 0x99, 0x98, 0xf0, 0x41, 0x42, 0x31, 0xbc, 0x64, 0x14, 0x6a, 0xaa, 0xa3, 0x84, 0x3e,
	0xf1, 0xfc, 0xa3, 0x5a, 0x8e, 0x60, 0x86, 0x49, 0x3b, 0x36, 0xef, 0x46, 0x56, 0xbc, 0x15, 0x57,
	0xdc, 0x79, 0xcd, 0x95, 0x0a, 0x55, 0x93, 0x5f, 0x4f, 0xd7, 0xcb, 0xa6, 0x82, 0x6d, 0x73, 0x68,
	0xef, 0x41, 0x3e, 0xa9, 0x66, 0x05, 0x4a, 0xac, 0x75, 0xd0, 0xd9, 0xd9, 0xde, 0xdd, 0x6a, 0xb1,
	0x7b, 0x1f, 0x55, 0xae, 0x60, 0x0e, 0xd2, 0x07, 0xad, 0xfd, 0x8a, 0x15, 0x3e, 0x3c, 0x7b, 0x71,
	0xbf, 0x92, 0xc2, 0x3c, 0x64, 0xbe, 0xd8, 0x69, 0xb5, 0x2b, 0x69, 0x2c, 0x42, 0x6e, 0xff, 0xf9,
	0x57, 0x0f, 0x36, 0x37, 0x37, 0x2b, 0x19, 0x2c, 0x41, 0xfe, 0xd5, 0x4e, 0xeb, 0x80, 0xde, 0xb2,
	0xf6, 0xed, 0xe4, 0xbb, 0x91, 0x0c, 0x0a, 0x22, 0x64, 0x5c, 0xae, 0x39, 0x09, 0xa3, 0xc4, 0xe8,
	0xd9, 0x1e, 0x42, 0x96, 0xf4, 0x8a, 0x8b, 0x90, 0x4a, 0x34, 0x93, 0x92, 0x6e, 0xe8, 0xac, 0xf8,
	0x40, 0x98, 0xb1, 0xa0, 0x67, 0x6c, 0x03, 0x70, 0xad, 0x7d, 0xd9, 0x1d, 0x69, 0x11, 0x98, 0x4e,
	0xdf, 0x7c, 0xe3, 0x08, 0xb4, 0x12, 0x57, 0x36, 0x06, 0xb3, 0x9b, 0x70, 0xf5, 0x9c, 0x19, 0xdf,
	0x85, 0x62, 0xc0, 0x07, 0x43, 0x6a, 0x8b, 0x16, 0x44, 0xa2, 0xcc, 0x20, 0x3a, 0x62, 0x5c, 0x0b,
	0xfb, 0x3f, 0xeb, 0x8c, 0xd8, 0xa3, 0x59, 0xc0, 0x5d, 0x28, 0xf1, 0xbe, 0x16, 0xbe, 0xe2, 0x5a,
	0x1e, 0x8b, 0x78, 0x90, 0xee, 0xce, 0xfa, 0x68, 0x9c, 0x42, 0xd8, 0x19, 0x3c, 0xbe, 0x03, 0x20,
	0x83, 0xce, 0x90, 0xfb, 0x5a, 0xf2, 0x3e, 0x25, 0x9e, 0x67, 0x05, 0x19, 0xbc, 0x88, 0x0e, 0xb0,
	0x0d, 0x19, 0x47, 0x89, 0x58, 0xe1, 0x1b, 0x73, 0x8c, 0xcd, 0xb8, 0x1a, 0x18, 0x81, 0xf1, 0x26,
	0x94, 0xcf, 0x68, 0x82, 0x54, 0x5e, 0x66, 0xa5, 0x71, 0x49, 0xd8, 0xbf, 0xa5, 0x60, 0x79, 0x3a,
	0x63, 0x5c, 0x03, 0x18, 0x93, 0x6d, 0xd4, 0xae, 0xb1, 0x93, 0x50, 0x73, 0x53, 0xa4, 0x5d, 0x60,
	0x65, 0xff, 0x8c, 0xa8, 0xd7, 0x00, 0xc6, 0x46, 0x26, 0x4c, 0xd5, 0x62, 0x63, 0x27, 0xd8, 0x84,
	0x6c, 0x38, 0x57, 0x61, 0x93, 0xc3, 0x9a, 0xde, 0x98, 0x96, 0x6c, 0x38, 0x5b, 0xdb, 0xea, 0xd0,
	0x63, 0x91, 0x2b, 0x3e, 0x00, 0x08, 0x34, 0xf7, 0x35, 0x4d, 0x31, 0xe5, 0x75, 0xe1, 0x77, 0xa0,
	0x40, 0xce, 0xe1, 0x4c, 0xe3, 0x87, 0x90, 0x8f, 0xff, 0x94, 0x34, 0xbe, 0x17, 0xe2, 0x12, 0x57,
	0xfb, 0x4f, 0x0b, 0xf2, 0x31, 0x89, 0x50, 0xaf, 0x21, 0x0d, 0x53, 0x12, 0x7a, 0x9e, 0x99, 0xe5,
	0x59, 0xc6, 0xe9, 0x4b, 0x32, 0xce, 0xcc, 0xcf, 0xf8, 0x5b, 0xb8, 0x7e, 0x81, 0x44, 0xf0, 0x33,
	0xc8, 0xf6, 0xa5, 0x3a, 0x8a, 0x95, 0x5c, 0x9f, 0x56, 0xf5, 0xf3, 0xa0, 0x1d, 0xa9, 0x8e, 0x58,
	0x04, 0xb3, 0xff, 0xb2, 0x60, 0x69, 0x9a, 0xfd, 0x5c, 0xa2, 0xd6, 0x25, 0x13, 0x4d, 0xcd, 0x9d,
	0x28, 0x7e, 0x02, 0x19, 0xee, 0x3b, 0xb1, 0x7c, 0xee, 0xcc, 0x93, 0x48, 0xcb, 0x77, 0x18, 0x81,
	0xec, 0x6d, 0xa8, 0x4e, 0x31, 0x5e, 0xa6, 0xc3, 0xcd, 0x7f, 0xd2, 0x90, 0x6d, 0xd3, 0x8f, 0xfe,
	0x1b, 0xc8, 0x99, 0x8d, 0x00, 0x97, 0x27, 0x32, 0xd8, 0x0a, 0xf7, 0xb0, 0xd5, 0xa9, 0x9f, 0xb2,
	0x73, 0x6b, 0x84, 0xbd, 0xf4, 0xe3, 0xdf, 0xff, 0xfe, 0x92, 0x5a, 0xc4, 0x12, 0xed, 0x80, 0xc7,
	0x26, 0xa4, 0x06, 0x38, 0x5d, 0x17, 0x70, 0xea, 0xbf, 0x7c, 0x62, 0xb9, 0x5b, 0xbd, 0x3d, 0xcb,
	0xcd, 0x5c, 0xf9, 0x36, 0x5d, 0x79, 0x0d, 0xaf, 0xd2, 0x95, 0x7d, 0x19, 0xe8, 0x68, 0xb7, 0xc0,
	0x11, 0x14, 0x92, 0x1d, 0x0c, 0x2f, 0x5a, 0x96, 0x92, 0x15, 0x6d, 0xf5, 0xce, 0xec, 0x35, 0x23,
	0xba, 0x74, 0x85, 0x2e, 0xad, 0xda, 0x8b, 0x74, 0xa9, 0x1f, 0xc7, 0x79, 0x68, 0xdd, 0xc5, 0x9f,
	0x2c, 0xc0, 0xc9, 0x25, 0x10, 0xdf, 0x9f, 0x16, 0xfa, 0x8d, 0xcb, 0xe2, 0xfc, 0x4c, 0xaa, 0xc4,
	0xa4, 0x8c, 0x45, 0x62, 0x12, 0x50, 0xc0, 0xba, 0xb5, 0x69, 0x3d, 0x59, 0xfb, 0x3a, 0x47, 0xa8,
	0x61, 0xf7, 0x8f, 0x14, 0xb6, 0x29, 0xd8, 0x5e, 0x14, 0x8c, 0x5a, 0xde, 0x5d, 0xa0, 0xfe, 0xde,
	0xff, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x0c, 0xac, 0x53, 0x40, 0xd6, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CubicClient is the client API for Cubic service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CubicClient interface {
	// Queries the Version of the Server
	Version(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// Retrieves a list of available speech recognition models
	ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error)
	// Performs synchronous speech recognition: receive results after all audio
	// has been sent and processed.  It is expected that this request be typically
	// used for short audio content: less than a minute long.  For longer content,
	// the `StreamingRecognize` method should be preferred.
	Recognize(ctx context.Context, in *RecognizeRequest, opts ...grpc.CallOption) (*RecognitionResponse, error)
	// Performs bidirectional streaming speech recognition.  Receive results while
	// sending audio.  This method is only available via GRPC and not via
	// HTTP+JSON. However, a web browser may use websockets to use this service.
	StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Cubic_StreamingRecognizeClient, error)
}

type cubicClient struct {
	cc *grpc.ClientConn
}

func NewCubicClient(cc *grpc.ClientConn) CubicClient {
	return &cubicClient{cc}
}

func (c *cubicClient) Version(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.cubic.Cubic/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cubicClient) ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error) {
	out := new(ListModelsResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.cubic.Cubic/ListModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cubicClient) Recognize(ctx context.Context, in *RecognizeRequest, opts ...grpc.CallOption) (*RecognitionResponse, error) {
	out := new(RecognitionResponse)
	err := c.cc.Invoke(ctx, "/cobaltspeech.cubic.Cubic/Recognize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cubicClient) StreamingRecognize(ctx context.Context, opts ...grpc.CallOption) (Cubic_StreamingRecognizeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Cubic_serviceDesc.Streams[0], "/cobaltspeech.cubic.Cubic/StreamingRecognize", opts...)
	if err != nil {
		return nil, err
	}
	x := &cubicStreamingRecognizeClient{stream}
	return x, nil
}

type Cubic_StreamingRecognizeClient interface {
	Send(*StreamingRecognizeRequest) error
	Recv() (*RecognitionResponse, error)
	grpc.ClientStream
}

type cubicStreamingRecognizeClient struct {
	grpc.ClientStream
}

func (x *cubicStreamingRecognizeClient) Send(m *StreamingRecognizeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cubicStreamingRecognizeClient) Recv() (*RecognitionResponse, error) {
	m := new(RecognitionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CubicServer is the server API for Cubic service.
type CubicServer interface {
	// Queries the Version of the Server
	Version(context.Context, *empty.Empty) (*VersionResponse, error)
	// Retrieves a list of available speech recognition models
	ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error)
	// Performs synchronous speech recognition: receive results after all audio
	// has been sent and processed.  It is expected that this request be typically
	// used for short audio content: less than a minute long.  For longer content,
	// the `StreamingRecognize` method should be preferred.
	Recognize(context.Context, *RecognizeRequest) (*RecognitionResponse, error)
	// Performs bidirectional streaming speech recognition.  Receive results while
	// sending audio.  This method is only available via GRPC and not via
	// HTTP+JSON. However, a web browser may use websockets to use this service.
	StreamingRecognize(Cubic_StreamingRecognizeServer) error
}

func RegisterCubicServer(s *grpc.Server, srv CubicServer) {
	s.RegisterService(&_Cubic_serviceDesc, srv)
}

func _Cubic_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CubicServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.cubic.Cubic/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CubicServer).Version(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cubic_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CubicServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.cubic.Cubic/ListModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CubicServer).ListModels(ctx, req.(*ListModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cubic_Recognize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecognizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CubicServer).Recognize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cobaltspeech.cubic.Cubic/Recognize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CubicServer).Recognize(ctx, req.(*RecognizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cubic_StreamingRecognize_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CubicServer).StreamingRecognize(&cubicStreamingRecognizeServer{stream})
}

type Cubic_StreamingRecognizeServer interface {
	Send(*RecognitionResponse) error
	Recv() (*StreamingRecognizeRequest, error)
	grpc.ServerStream
}

type cubicStreamingRecognizeServer struct {
	grpc.ServerStream
}

func (x *cubicStreamingRecognizeServer) Send(m *RecognitionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cubicStreamingRecognizeServer) Recv() (*StreamingRecognizeRequest, error) {
	m := new(StreamingRecognizeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Cubic_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cobaltspeech.cubic.Cubic",
	HandlerType: (*CubicServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Cubic_Version_Handler,
		},
		{
			MethodName: "ListModels",
			Handler:    _Cubic_ListModels_Handler,
		},
		{
			MethodName: "Recognize",
			Handler:    _Cubic_Recognize_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamingRecognize",
			Handler:       _Cubic_StreamingRecognize_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cubic.proto",
}
