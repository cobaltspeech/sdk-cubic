<!DOCTYPE html>
<html>
  <head>
    <title>Cubic SDK -- Cobalt</title>
    
      <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Recognition Context :: Cubic SDK -- Cobalt</title>
<link rel="shortcut icon" href="../../images/favicon.ico" type="image/x-icon" />
<link href="../../css/nucleus.css" rel="stylesheet">
<link href="../../css/font-awesome.min.css" rel="stylesheet">
<link href="../../css/hybrid.css" rel="stylesheet">
<link href="../../css/featherlight.min.css" rel="stylesheet">
<link href="../../css/auto-complete.css" rel="stylesheet">
<link href="../../theme-original/style.css" rel="stylesheet">

  <link href="../../theme-original/variant-blue.css" rel="stylesheet">

<link rel="stylesheet" href="../../css/bootstrap.min.css">
<script src="../../js/jquery-2.x.min.js"></script>
<style type="text/css">
  :root #header + #content > #left > #rlblock_left {
    display:none !important;
  }
</style>
<link href="../../css/tabs.css" rel="stylesheet" type="text/css">
<script src="../../js/tabs.js"></script>


    
  </head>
  <body data-url="/using-cubic-sdk/recognition-context/">
    
      <div id="headermain"></div>
<nav id="sidebar" class="showVisitedLinks">



<div class="highlightable">
  <div id="header-wrapper">
    <div id="header">
      
	
  
    <p><img src="images/logo-white.png" alt="Cobalt&rsquo;s SDK Documentation"></p>
<p>Cubic SDK &ndash; Cobalt</p>

  


    </div>
        <div class="searchbox">
		    <label for="search-by"><i class="fa fa-search"></i></label>
		    <input data-search-input id="search-by" type="text" placeholder="Search...">
		    <span data-search-clear=""><i class="fa fa-close"></i></span>
		</div>
		<script type="text/javascript" src="../../js/lunr.min.js"></script>
		<script type="text/javascript" src="../../js/auto-complete.js"></script>
		<script type="text/javascript">
        
            var baseurl = "";
        
		</script>
		<script type="text/javascript" src="../../js/search.js"></script>
  </div>

      <ul class="topics">
            <li data-nav-id="/" class="dd-item">
            <a href="../../"><i class="fa fa-fw fa-home"></i></a>
            </li>
    <li data-nav-id="/getting-started/" class="dd-item
        ">
      <div>
      <a href="../../getting-started/">Server Setup</a><i class="fa fa-circle-thin read-icon"></i>
      </div>
    </li>
    <li data-nav-id="/using-cubic-sdk/" class="dd-item parent haschildren
        ">
      <div>
      <a href="../../using-cubic-sdk/">Using Cubic-SDK</a>
            <i class="fa fa-angle-down fa-lg category-icon"></i><i class="fa fa-circle-thin read-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/using-cubic-sdk/installation/" class="dd-item">
        <div>
          <a href="../../using-cubic-sdk/installation/">
            Installing the SDK
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/using-cubic-sdk/connecting/" class="dd-item">
        <div>
          <a href="../../using-cubic-sdk/connecting/">
            Setup Connection
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/using-cubic-sdk/recognize/" class="dd-item">
        <div>
          <a href="../../using-cubic-sdk/recognize/">
            Synchronous Recognition
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/using-cubic-sdk/streaming/" class="dd-item">
        <div>
          <a href="../../using-cubic-sdk/streaming/">
            Streaming Recognition
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/using-cubic-sdk/recognition-context/" class="dd-item active">
        <div>
          <a href="../../using-cubic-sdk/recognition-context/">
            Recognition Context
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/using-cubic-sdk/client-configs/" class="dd-item">
        <div>
          <a href="../../using-cubic-sdk/client-configs/">
            Recognition Configurations
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/using-cubic-sdk/android/" class="dd-item">
        <div>
          <a href="../../using-cubic-sdk/android/">
            Android Integrations
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/protobuf/" class="dd-item haschildren
        ">
      <div>
      <a href="../../protobuf/">Cubic API Reference</a><i class="fa fa-angle-right fa-lg category-icon"></i><i class="fa fa-circle-thin read-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/protobuf/autogen-doc-cubic-proto/" class="dd-item">
        <div>
          <a href="../../protobuf/autogen-doc-cubic-proto/">
            Cubic Protobuf API Docs
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
        </ul>
    </li>



        <section id="shortcuts">
                <li class="" role=""><h3>More</h3><a href="https://github.com/cobaltspeech/sdk-cubic" target="_blank" rel="noopener"><i class='fa fa-github'></i> <label>Github repo</label></a></li>
                <li class="" role=""><a href="https://www.cobaltspeech.com/contact" target="_blank" rel="noopener"><i class='fa fa-bookmark'></i> <label>Contact us</label></a></li>
        </section>
            <a id="clear-history" class="" href="#" data-clear-history-toggle=""><i class="fa  fa-history"></i> Clear History</a>

    <hr />
    <li></li>
    
    </ul>

 <section id="footer">
    </section>
  </div>
</nav>



<section id="body">
<div id="overlay"></div>
<div class="padding highlightable">

  <div id="top-bar">
    <div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
        <span id="sidebar-toggle-span">
          <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
            <i class="fa fa-bars"></i>
          </a>
        </span>
        <span id="toc-menu"><i class="fa fa-list-alt"></i></span>
        <span class="links">
        







 <a href='../../'>Cubic SDK Documentation</a> > <a href='../../using-cubic-sdk/'>Using Cubic-SDK</a> > Recognition Context

 

 

   
        </span>
    </div>
    
    
    <div class="progress">
        <div class="wrapper">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#compiling-recognition-context">Compiling Recognition Context</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
    </div>
    

  </div>


<div id="body-inner">
  
    <h1>Recognition Context</h1>
  



    
    
    
    <p>Cubic allows users to send context information with a recognition request which
may aid the speech recognition. For example, if you have a list of names that
you want to make sure the Cubic model transcribes correctly, with the correct
spelling, then you may provide the list in the form of a
<a href="../../protobuf/autogen-doc-cubic-proto/#message-recognitioncontext"><code>RecognitionContext</code></a> object along with the <a href="../client-configs/#fields"><code>RecognitionConfig</code></a>
before streaming data.</p>
<p>Cubic models allow different sets of &ldquo;context tokens&rdquo; each of which can be
paired with a list of words or phrases. For example, a Cubic model may have a
context token for airport names, and you can provide a list of airport names you
want to be recognized correctly for this context token. Likewise, models may
also be configured with tokens for &ldquo;contact list names&rdquo;, &ldquo;menu items&rdquo;, &ldquo;medical jargon&rdquo; etc.</p>
<p>To ensure that there is no added latency in processing the list of words or
phrases during a recognition request, we have a API method called
<a href="../../protobuf/autogen-doc-cubic-proto/#service-cubic"><code>CompileContext()</code></a> that
allows the user to compile the list into a compact, efficient format for
passing to the <code>Recognize()</code> or <code>StreamingRecognize()</code> methods.</p>
<h3 id="compiling-recognition-context">Compiling Recognition Context</h3>
<p>We have several examples in different langagues below showing you how to compile
context data and send it during a recognition request.</p>
<div class='code-tabs'><ul class="nav-tabs"></ul><div class="tab-content">

<div class="tab-pane" title="Go">
  <div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#6ab825;font-weight:bold">package</span> main

<span style="color:#6ab825;font-weight:bold">import</span> (
    <span style="color:#ed9d13">&#34;context&#34;</span>
    <span style="color:#ed9d13">&#34;fmt&#34;</span>
    <span style="color:#ed9d13">&#34;log&#34;</span>
    <span style="color:#ed9d13">&#34;os&#34;</span>
    <span style="color:#ed9d13">&#34;strings&#34;</span>

    <span style="color:#ed9d13">&#34;github.com/cobaltspeech/sdk-cubic/grpc/go-cubic&#34;</span>
    <span style="color:#ed9d13">&#34;github.com/cobaltspeech/sdk-cubic/grpc/go-cubic/cubicpb&#34;</span>
)

<span style="color:#6ab825;font-weight:bold">func</span> <span style="color:#447fcf">main</span>() {

    <span style="color:#999;font-style:italic">// creating client without TLS. Remove WithInsecure() if using TLS
</span><span style="color:#999;font-style:italic"></span>    serverAddr := <span style="color:#ed9d13">&#34;127.0.0.1:2727&#34;</span>
    client, err := cubic.<span style="color:#447fcf">NewClient</span>(serverAddr, cubic.<span style="color:#447fcf">WithInsecure</span>())
    <span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
        log.<span style="color:#447fcf">Fatal</span>(err)
    }
    <span style="color:#6ab825;font-weight:bold">defer</span> client.<span style="color:#447fcf">Close</span>()

    <span style="color:#999;font-style:italic">// Get list of available models
</span><span style="color:#999;font-style:italic"></span>    modelResp, err := client.<span style="color:#447fcf">ListModels</span>(context.<span style="color:#447fcf">Background</span>())
    <span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
        log.<span style="color:#447fcf">Fatal</span>(err)
    }
    <span style="color:#6ab825;font-weight:bold">for</span> _, m := <span style="color:#6ab825;font-weight:bold">range</span> modelResp.Models {
        fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;\nID = %v, Name = %v, Supports Context = %v\n&#34;</span>,
            m.Id, m.Name, m.Attributes.ContextInfo.SupportsContext)
        <span style="color:#999;font-style:italic">// printing allowed context tokens
</span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">if</span> m.Attributes.ContextInfo.SupportsContext {
            fmt.<span style="color:#447fcf">Printf</span>(<span style="color:#ed9d13">&#34;Allowed Context Tokens = %v\n\n&#34;</span>,
                strings.<span style="color:#447fcf">Join</span>(m.Attributes.ContextInfo.AllowedContextTokens, <span style="color:#ed9d13">&#34;, &#34;</span>))
        }
    }

    <span style="color:#999;font-style:italic">// Assuming the first model supports context
</span><span style="color:#999;font-style:italic"></span>    model := modelResp.Models[<span style="color:#3677a9">0</span>]

    <span style="color:#999;font-style:italic">// Let&#39;s say this model has an allowed context token called &#34;airport_names&#34; and
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// we have a list of airport names that we want to make sure the recognizer gets
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// right. We compile the list of names using the CompileContext(), save the compiled
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// data and send it back with subsequent recognize requests to customize and improve the results.
</span><span style="color:#999;font-style:italic"></span>
    <span style="color:#999;font-style:italic">// a small example list
</span><span style="color:#999;font-style:italic"></span>    phrases := []<span style="color:#6ab825;font-weight:bold">string</span>{<span style="color:#ed9d13">&#34;NARITA&#34;</span>, <span style="color:#ed9d13">&#34;KUALA LUMPUR INTERNATIONAL&#34;</span>, <span style="color:#ed9d13">&#34;ISTANBUL ATATURK&#34;</span>, <span style="color:#ed9d13">&#34;LAGUARDIA&#34;</span>}
    contextToken := model.Attributes.ContextInfo.AllowedContextTokens[<span style="color:#3677a9">0</span>] <span style="color:#999;font-style:italic">// &#34;airport_names&#34;
</span><span style="color:#999;font-style:italic"></span>
    <span style="color:#999;font-style:italic">// sending request to server
</span><span style="color:#999;font-style:italic"></span>    compiledResp, err := client.<span style="color:#447fcf">CompileContext</span>(
        context.<span style="color:#447fcf">Background</span>(), model.Id, contextToken, phrases, <span style="color:#6ab825;font-weight:bold">nil</span>)
    <span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
        log.<span style="color:#447fcf">Fatal</span>(err)
    }

    <span style="color:#999;font-style:italic">// saving the compiled result for later use; note this compiled data is only
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// compatible with the model whose ID was provided in the CompileContext call
</span><span style="color:#999;font-style:italic"></span>    compiledContexts := <span style="color:#24909d">make</span>([]*cubicpb.CompiledContext, <span style="color:#3677a9">0</span>)
    compiledContexts = <span style="color:#24909d">append</span>(compiledContexts, compiledResp.Context)

    <span style="color:#999;font-style:italic">// Now we can send a recognize request along with the compiled context. The
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// context data is provided through the recognition config as a list of compiled
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// contexts (i.e. we can provide more than one compiled context if the model
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#999;font-style:italic">// supports more than one context token).
</span><span style="color:#999;font-style:italic"></span>    cfg := &amp;cubicpb.RecognitionConfig{
        ModelId:       model.Id,
        AudioEncoding: cubicpb.RecognitionConfig_WAV,
        Context:       &amp;cubicpb.RecognitionContext{Compiled: compiledContexts},
    }

    <span style="color:#999;font-style:italic">// The rest is the same as a usual streaming recognize request
</span><span style="color:#999;font-style:italic"></span>
    <span style="color:#999;font-style:italic">// open audio file stream
</span><span style="color:#999;font-style:italic"></span>    f, err := os.<span style="color:#447fcf">Open</span>(<span style="color:#ed9d13">&#34;test.wav&#34;</span>)
    <span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
        log.<span style="color:#447fcf">Fatal</span>(err)
    }
    <span style="color:#6ab825;font-weight:bold">defer</span> f.<span style="color:#447fcf">Close</span>()

    <span style="color:#999;font-style:italic">// define a callback function to handle results
</span><span style="color:#999;font-style:italic"></span>    resultHandler := <span style="color:#6ab825;font-weight:bold">func</span>(resp *cubicpb.RecognitionResponse) {
        <span style="color:#6ab825;font-weight:bold">for</span> _, r := <span style="color:#6ab825;font-weight:bold">range</span> resp.Results {
            <span style="color:#6ab825;font-weight:bold">if</span> !r.IsPartial {
                fmt.<span style="color:#447fcf">Println</span>(r.Alternatives[<span style="color:#3677a9">0</span>].Transcript)
            }
        }
    }

    err = client.<span style="color:#447fcf">StreamingRecognize</span>(context.<span style="color:#447fcf">Background</span>(), cfg, f, resultHandler)
    <span style="color:#6ab825;font-weight:bold">if</span> err != <span style="color:#6ab825;font-weight:bold">nil</span> {
        log.<span style="color:#447fcf">Fatal</span>(err)
    }
}
</code></pre></div>
</div>


<div class="tab-pane" title="Python">
  <div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">cubic</span>

<span style="color:#999;font-style:italic"># set insecure to False if server uses TLS</span>
serverAddress = <span style="color:#ed9d13">&#39;127.0.0.1:2727&#39;</span>
client = cubic.Client(serverAddress, insecure=True)

<span style="color:#999;font-style:italic"># Get list of available models</span>
modelResp = client.ListModels()
<span style="color:#6ab825;font-weight:bold">for</span> m <span style="color:#6ab825;font-weight:bold">in</span> modelResp.models:
    <span style="color:#6ab825;font-weight:bold">print</span>(<span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\n</span><span style="color:#ed9d13">ID = {}, Name = {}, Supports Context = {}&#34;</span>.format(
        m.id, m.name, m.attributes.context_info.supports_context))
    <span style="color:#6ab825;font-weight:bold">if</span> m.attributes.context_info.supports_context:
        <span style="color:#999;font-style:italic"># printing allowed context tokens</span>
        <span style="color:#6ab825;font-weight:bold">print</span>(<span style="color:#ed9d13">&#34;Allowed context tokens =  {}</span><span style="color:#ed9d13">\n</span><span style="color:#ed9d13">&#34;</span>.format(
            <span style="color:#24909d">str</span>(m.attributes.context_info.allowed_context_tokens)))

<span style="color:#999;font-style:italic"># Assuming the first model supports context</span>
model = modelResp.models[<span style="color:#3677a9">0</span>]

<span style="color:#999;font-style:italic"># Let&#39;s say this model has an allowed context token called &#34;airport_names&#34; and</span>
<span style="color:#999;font-style:italic"># we have a list of airport names that we want to make sure the recognizer gets</span>
<span style="color:#999;font-style:italic"># right. We compile the list of names using the CompileContext(), save the compiled</span>
<span style="color:#999;font-style:italic"># data and send it back with subsequent recognize requests to customize and improve the results.</span>

<span style="color:#999;font-style:italic"># a small example list</span>
phrases = [<span style="color:#ed9d13">&#34;NARITA&#34;</span>, <span style="color:#ed9d13">&#34;KUALA LUMPUR INTERNATIONAL&#34;</span>, <span style="color:#ed9d13">&#34;ISTANBUL ATATURK&#34;</span>, <span style="color:#ed9d13">&#34;LAGUARDIA&#34;</span>]
contextToken = model.attributes.context_info.allowed_context_tokens[<span style="color:#3677a9">0</span>]  <span style="color:#999;font-style:italic"># &#34;airport_names&#34;</span>

<span style="color:#999;font-style:italic"># sending request to server</span>
compiledResp = client.CompileContext(model.id, contextToken, phrases)

<span style="color:#999;font-style:italic"># saving the compiled result for later use; note this compiled data is only</span>
<span style="color:#999;font-style:italic"># compatible with the model whose ID was provided in the CompileContext call</span>
compiledContexts = []
compiledContexts.append(compiledResp.context)

<span style="color:#999;font-style:italic"># Now we can send a recognize request along with the compiled context. The</span>
<span style="color:#999;font-style:italic"># context data is provided through the recognition config as a list of compiled</span>
<span style="color:#999;font-style:italic"># contexts (i.e. we can provide more than one compiled context if the model</span>
<span style="color:#999;font-style:italic"># supports more than one context token).</span>
cfg = cubic.RecognitionConfig(
    model_id=model.id,
    audio_encoding=<span style="color:#ed9d13">&#34;WAV&#34;</span>,
    context=cubic.RecognitionContext(compiled=compiledContexts),
)

<span style="color:#999;font-style:italic"># The rest is the same as a usual streaming recognize request</span>

<span style="color:#999;font-style:italic"># open audio file stream</span>
audio = <span style="color:#24909d">open</span>(<span style="color:#ed9d13">&#39;test.wav&#39;</span>, <span style="color:#ed9d13">&#39;rb&#39;</span>)

<span style="color:#999;font-style:italic"># send streaming request to cubic and print out results as they come in</span>
<span style="color:#6ab825;font-weight:bold">for</span> resp <span style="color:#6ab825;font-weight:bold">in</span> client.StreamingRecognize(cfg, audio):
    <span style="color:#6ab825;font-weight:bold">for</span> result <span style="color:#6ab825;font-weight:bold">in</span> resp.results:
        <span style="color:#6ab825;font-weight:bold">if</span> result.is_partial:
            <span style="color:#6ab825;font-weight:bold">print</span>(<span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\r</span><span style="color:#ed9d13">{0}&#34;</span>.format(result.alternatives[<span style="color:#3677a9">0</span>].transcript), end=<span style="color:#ed9d13">&#34;&#34;</span>)
        <span style="color:#6ab825;font-weight:bold">else</span>:
            <span style="color:#6ab825;font-weight:bold">print</span>(<span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\r</span><span style="color:#ed9d13">{0}&#34;</span>.format(result.alternatives[<span style="color:#3677a9">0</span>].transcript), end=<span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\n</span><span style="color:#ed9d13">&#34;</span>)
</code></pre></div>
</div>


<div class="tab-pane" title="C#">
  <div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">
<span style="color:#6ab825;font-weight:bold">using</span> <span style="color:#447fcf;text-decoration:underline">System</span>;
<span style="color:#6ab825;font-weight:bold">using</span> <span style="color:#447fcf;text-decoration:underline">System.Collections.Generic</span>;
<span style="color:#6ab825;font-weight:bold">using</span> <span style="color:#447fcf;text-decoration:underline">System.IO</span>;
<span style="color:#6ab825;font-weight:bold">using</span> <span style="color:#447fcf;text-decoration:underline">System.Linq</span>;
<span style="color:#6ab825;font-weight:bold">using</span> <span style="color:#447fcf;text-decoration:underline">System.Threading.Tasks</span>;
<span style="color:#6ab825;font-weight:bold">using</span> <span style="color:#447fcf;text-decoration:underline">Grpc.Core</span>;

<span style="color:#6ab825;font-weight:bold">namespace</span> <span style="color:#447fcf;text-decoration:underline">CubicRecognitionContextExample</span> {
    <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">Program</span> {
        <span style="color:#6ab825;font-weight:bold">static</span> <span style="color:#6ab825;font-weight:bold">async</span> Task Main(<span style="color:#6ab825;font-weight:bold">string</span>[] args) {

            <span style="color:#999;font-style:italic">// set creds = new Grpc.Core.SslCredentials(); if using TLS
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> serverAddress = <span style="color:#ed9d13">&#34;127.0.0.1:2727&#34;</span>;
            <span style="color:#6ab825;font-weight:bold">var</span> creds = Grpc.Core.ChannelCredentials.Insecure;

            <span style="color:#999;font-style:italic">// Initialize a gRPC connection
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> channel = <span style="color:#6ab825;font-weight:bold">new</span> Grpc.Core.Channel(serverAddress, creds);
            <span style="color:#6ab825;font-weight:bold">var</span> client = <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.Cubic.CubicClient(channel);

            <span style="color:#999;font-style:italic">// Get list of available models
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> listModelsRequest = <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.ListModelsRequest();
            <span style="color:#6ab825;font-weight:bold">var</span> modelResp = client.ListModels(listModelsRequest);

            <span style="color:#6ab825;font-weight:bold">foreach</span> (<span style="color:#6ab825;font-weight:bold">var</span> m <span style="color:#6ab825;font-weight:bold">in</span> modelResp.Models) {
                Console.WriteLine(<span style="color:#ed9d13">&#34;\nID = {0}, Name = {1}, Supports Context = {2}&#34;</span>,
                    m.Id, m.Name, m.Attributes.ContextInfo.SupportsContext);
                <span style="color:#999;font-style:italic">// printing allowed context tokens
</span><span style="color:#999;font-style:italic"></span>                <span style="color:#6ab825;font-weight:bold">if</span> (m.Attributes.ContextInfo.SupportsContext) {
                    Console.WriteLine(<span style="color:#ed9d13">&#34;Allowed Context Tokens = {0}\n&#34;</span>,
                        m.Attributes.ContextInfo.AllowedContextTokens);
                }
            }

            <span style="color:#999;font-style:italic">// Assuming the first model supports context
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> model = modelResp.Models[<span style="color:#3677a9">0</span>];

            <span style="color:#999;font-style:italic">// Let&#39;s say this model has an allowed context token called &#34;airport_names&#34; and
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// we have a list of airport names that we want to make sure the recognizer gets
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// right. We compile the list of names using the CompileContext(), save the compiled
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// data and send it back with subsequent recognize requests to customize and improve the results.
</span><span style="color:#999;font-style:italic"></span>
            <span style="color:#999;font-style:italic">// a small example list
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">string</span>[] phrases = { <span style="color:#ed9d13">&#34;NARITA&#34;</span>, <span style="color:#ed9d13">&#34;KUALA LUMPUR INTERNATIONAL&#34;</span>, <span style="color:#ed9d13">&#34;ISTANBUL ATATURK&#34;</span>, <span style="color:#ed9d13">&#34;LAGUARDIA&#34;</span> };
            <span style="color:#6ab825;font-weight:bold">string</span> contextToken = model.Attributes.ContextInfo.AllowedContextTokens[<span style="color:#3677a9">0</span>]; <span style="color:#999;font-style:italic">// &#34;airport_names&#34;
</span><span style="color:#999;font-style:italic"></span>
            <span style="color:#999;font-style:italic">// create compile context request
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> compileRequest = <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.CompileContextRequest {
                ModelId = model.Id,
                Token = contextToken,
            };
            <span style="color:#999;font-style:italic">// put phrases into an compileRequest.Phrases
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">foreach</span> (<span style="color:#6ab825;font-weight:bold">var</span> phrase <span style="color:#6ab825;font-weight:bold">in</span> phrases) {
                compileRequest.Phrases.Add(
                    <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.ContextPhrase {
                        Text = phrase,
                    });
            }

            <span style="color:#999;font-style:italic">// send request to server
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> compiledResp = client.CompileContext(compileRequest);

            <span style="color:#999;font-style:italic">// saving the compiled result for later use; note this compiled data is only
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// compatible with the model whose ID was provided in the CompileContext call
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> compiledContexts = <span style="color:#6ab825;font-weight:bold">new</span> List&lt;CobaltSpeech.Cubic.CompiledContext&gt;();
            compiledContexts.Add(compiledResp.Context);

            <span style="color:#999;font-style:italic">// Now we can send a recognize request along with the compiled context. The
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// context data is provided through the recognition config as a list of compiled
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// contexts (i.e. we can provide more than one compiled context if the model
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#999;font-style:italic">// supports more than one context token).
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> cfg = <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.RecognitionConfig {
                ModelId = model.Id,
                AudioEncoding = CobaltSpeech.Cubic.RecognitionConfig.Types.Encoding.Wav,
                Context = <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.RecognitionContext(),
            };
            <span style="color:#6ab825;font-weight:bold">foreach</span> (<span style="color:#6ab825;font-weight:bold">var</span> ctx <span style="color:#6ab825;font-weight:bold">in</span> compiledContexts) {
                cfg.Context.Compiled.Add(ctx);
            }

            <span style="color:#999;font-style:italic">// The rest is the same as a usual streaming recognize request
</span><span style="color:#999;font-style:italic"></span>
            <span style="color:#6ab825;font-weight:bold">string</span> audioPath = <span style="color:#ed9d13">&#34;test.wav&#34;</span>;

            <span style="color:#999;font-style:italic">// Setup the bi-directional gRPC stream.
</span><span style="color:#999;font-style:italic"></span>            <span style="color:#6ab825;font-weight:bold">var</span> call = client.StreamingRecognize();
            using(call) {
                <span style="color:#999;font-style:italic">// Setup recieve task
</span><span style="color:#999;font-style:italic"></span>                <span style="color:#6ab825;font-weight:bold">var</span> responseReaderTask = Task.Run(<span style="color:#6ab825;font-weight:bold">async</span>() =&gt; {
                    <span style="color:#999;font-style:italic">// Wait for the next response
</span><span style="color:#999;font-style:italic"></span>                    <span style="color:#6ab825;font-weight:bold">while</span> (<span style="color:#6ab825;font-weight:bold">await</span> call.ResponseStream.MoveNext()) {
                        <span style="color:#6ab825;font-weight:bold">var</span> response = call.ResponseStream.Current;
                        <span style="color:#6ab825;font-weight:bold">foreach</span> (<span style="color:#6ab825;font-weight:bold">var</span> result <span style="color:#6ab825;font-weight:bold">in</span> response.Results) {
                            Console.WriteLine(result.Alternatives[<span style="color:#3677a9">0</span>].Transcript);
                        }
                    }
                });

                <span style="color:#999;font-style:italic">// Send config first, followed by the audio
</span><span style="color:#999;font-style:italic"></span>                {
                    <span style="color:#999;font-style:italic">// Send the configs
</span><span style="color:#999;font-style:italic"></span>                    <span style="color:#6ab825;font-weight:bold">var</span> request = <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.StreamingRecognizeRequest();
                    request.Config = cfg;
                    <span style="color:#6ab825;font-weight:bold">await</span> call.RequestStream.WriteAsync(request);

                    <span style="color:#999;font-style:italic">// Setup object for streaming audio
</span><span style="color:#999;font-style:italic"></span>                    request.Config = <span style="color:#6ab825;font-weight:bold">null</span>;
                    request.Audio = <span style="color:#6ab825;font-weight:bold">new</span> CobaltSpeech.Cubic.RecognitionAudio { };

                    <span style="color:#999;font-style:italic">// Send the audio, in 8kb chunks
</span><span style="color:#999;font-style:italic"></span>                    <span style="color:#6ab825;font-weight:bold">const</span> <span style="color:#6ab825;font-weight:bold">int</span> chunkSize = <span style="color:#3677a9">8192</span>;
                    using(FileStream file = File.OpenRead(audioPath)) {
                        <span style="color:#6ab825;font-weight:bold">int</span> bytesRead;
                        <span style="color:#6ab825;font-weight:bold">var</span> buffer = <span style="color:#6ab825;font-weight:bold">new</span> <span style="color:#6ab825;font-weight:bold">byte</span>[chunkSize];
                        <span style="color:#6ab825;font-weight:bold">while</span> ((bytesRead = file.Read(buffer, <span style="color:#3677a9">0</span>, buffer.Length)) &gt; <span style="color:#3677a9">0</span>) {
                            <span style="color:#6ab825;font-weight:bold">var</span> bytes = Google.Protobuf.ByteString.CopyFrom(buffer.Take(bytesRead).ToArray());
                            request.Audio.Data = bytes;
                            <span style="color:#6ab825;font-weight:bold">await</span> call.RequestStream.WriteAsync(request);
                        }

                        <span style="color:#999;font-style:italic">// Close the sending stream
</span><span style="color:#999;font-style:italic"></span>                        <span style="color:#6ab825;font-weight:bold">await</span> call.RequestStream.CompleteAsync();
                    }
                }

                <span style="color:#999;font-style:italic">// Wait for all of the responses to come back through the receiving stream
</span><span style="color:#999;font-style:italic"></span>                <span style="color:#6ab825;font-weight:bold">await</span> responseReaderTask;
            }
        }
    }
}
</code></pre></div>
</div>


<div class="tab-pane" title="Swift/iOS">
  <div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift">
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">Foundation</span>
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">Cubic</span>

<span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">CubicExample</span> {

    <span style="color:#999;font-style:italic">// set useTLS to true if using TLS</span>
    <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">client</span> = Client(host: <span style="color:#ed9d13">&#34;127.0.0.1&#34;</span>, port: <span style="color:#3677a9">2727</span>, useTLS: <span style="color:#6ab825;font-weight:bold">false</span>)
    <span style="color:#6ab825;font-weight:bold">var</span> <span style="color:#40ffff">config</span> = Cobaltspeech_Cubic_RecognitionConfig()
    <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">fileName</span> = <span style="color:#ed9d13">&#34;test.wav&#34;</span>
    <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">chunkSize</span> = <span style="color:#3677a9">8192</span>
    
    <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">init</span>() {
        <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">dispatchGroup</span> = DispatchGroup()
        dispatchGroup.enter()
        
        <span style="color:#6ab825;font-weight:bold">var</span> <span style="color:#40ffff">model</span>: Cobaltspeech_Cubic_Model!

        client.listModels(success: { (models) <span style="color:#6ab825;font-weight:bold">in</span>
            <span style="color:#6ab825;font-weight:bold">guard</span> <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">models</span> = models <span style="color:#6ab825;font-weight:bold">else</span> { <span style="color:#6ab825;font-weight:bold">return</span> }
            
            <span style="color:#6ab825;font-weight:bold">for</span> model <span style="color:#6ab825;font-weight:bold">in</span> models {
                print(<span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\n</span><span style="color:#ed9d13">ID = </span><span style="color:#ed9d13">\(</span>model.id<span style="color:#ed9d13">)</span><span style="color:#ed9d13">, Name = </span><span style="color:#ed9d13">\(</span>model.name<span style="color:#ed9d13">)</span><span style="color:#ed9d13">, Supports Context = </span><span style="color:#ed9d13">\(</span>model.attributes.contextInfo.supportsContext<span style="color:#ed9d13">)</span><span style="color:#ed9d13">&#34;</span>)
                <span style="color:#999;font-style:italic">// printing allowed context tokens</span>
                <span style="color:#6ab825;font-weight:bold">if</span> model.attributes.contextInfo.supportsContext {
                    print(<span style="color:#ed9d13">&#34;Allowed Context Tokens = </span><span style="color:#ed9d13">\(</span>model.attributes.contextInfo.allowedContextTokens<span style="color:#ed9d13">)</span><span style="color:#ed9d13">\n</span><span style="color:#ed9d13">&#34;</span>)
                }
            }
            
            <span style="color:#999;font-style:italic">// Assuming the first model supports context</span>
            <span style="color:#6ab825;font-weight:bold">if</span> <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">firstModel</span> = models.first {
                model = firstModel
            } <span style="color:#6ab825;font-weight:bold">else</span> {
                <span style="color:#6ab825;font-weight:bold">return</span>
            }
            
            dispatchGroup.leave()
        }) { (error) <span style="color:#6ab825;font-weight:bold">in</span>
            print(error.localizedDescription)
            dispatchGroup.leave()
        }
        
        dispatchGroup.wait()
        
        <span style="color:#999;font-style:italic">// Let&#39;s say this model has an allowed context token called &#34;airport_names&#34; and</span>
        <span style="color:#999;font-style:italic">// we have a list of airport names that we want to make sure the recognizer gets</span>
        <span style="color:#999;font-style:italic">// right. We compile the list of names using the CompileContext(), save the compiled</span>
        <span style="color:#999;font-style:italic">// data and send it back with subsequent recognize requests to customize and improve the results.</span>
        
        <span style="color:#999;font-style:italic">// a small example list</span>
        <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">phrases</span> = [<span style="color:#ed9d13">&#34;NARITA&#34;</span>, <span style="color:#ed9d13">&#34;KUALA LUMPUR INTERNATIONAL&#34;</span>, <span style="color:#ed9d13">&#34;ISTANBUL ATATURK&#34;</span>, <span style="color:#ed9d13">&#34;LAGUARDIA&#34;</span>]
        <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">contextToken</span> = model.attributes.contextInfo.allowedContextTokens[<span style="color:#3677a9">0</span>] <span style="color:#999;font-style:italic">// &#34;airport_names&#34;</span>
        
        <span style="color:#999;font-style:italic">// create compile context request</span>
        <span style="color:#6ab825;font-weight:bold">var</span> <span style="color:#40ffff">compileRequest</span> = Cobaltspeech_Cubic_CompileContextRequest()
        compileRequest.modelID = model.id
        compileRequest.token = contextToken
        
        <span style="color:#999;font-style:italic">// put phrases into an compileRequest.Phrases</span>
        <span style="color:#6ab825;font-weight:bold">for</span> phrase <span style="color:#6ab825;font-weight:bold">in</span> phrases {
            <span style="color:#6ab825;font-weight:bold">var</span> <span style="color:#40ffff">contextPhrase</span> = Cobaltspeech_Cubic_ContextPhrase()
            contextPhrase.text = phrase
            compileRequest.phrases.append(contextPhrase)
        }

        <span style="color:#999;font-style:italic">// send request to server</span>
        <span style="color:#6ab825;font-weight:bold">var</span> <span style="color:#40ffff">compiledContexts</span>: [Cobaltspeech_Cubic_CompiledContext] = []
        
        dispatchGroup.enter()
        
        <span style="color:#6ab825;font-weight:bold">self</span>.client.compileContext(compileRequest).response.whenComplete { (result) <span style="color:#6ab825;font-weight:bold">in</span>
            <span style="color:#6ab825;font-weight:bold">switch</span> result {
            <span style="color:#6ab825;font-weight:bold">case</span> .success(<span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">response</span>):
                <span style="color:#999;font-style:italic">// saving the compiled result for later use; note this compiled data is only</span>
                <span style="color:#999;font-style:italic">// compatible with the model whose ID was provided in the CompileContext call</span>
                compiledContexts.append(response.context)
                dispatchGroup.leave()
            <span style="color:#6ab825;font-weight:bold">case</span> .failure(<span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">error</span>):
                print(error.localizedDescription)
                dispatchGroup.leave()
            }
        }
        
        dispatchGroup.wait()
        
        <span style="color:#999;font-style:italic">// Now we can send a recognize request along with the compiled context. The</span>
        <span style="color:#999;font-style:italic">// context data is provided through the recognition config as a list of compiled</span>
        <span style="color:#999;font-style:italic">// contexts (i.e. we can provide more than one compiled context if the model</span>
        <span style="color:#999;font-style:italic">// supports more than one context token).</span>
        <span style="color:#6ab825;font-weight:bold">self</span>.config.modelID = model.id
        <span style="color:#6ab825;font-weight:bold">self</span>.config.audioEncoding = .wav
        <span style="color:#6ab825;font-weight:bold">self</span>.config.context = Cobaltspeech_Cubic_RecognitionContext()
        <span style="color:#6ab825;font-weight:bold">self</span>.config.context.compiled.append(contentsOf: compiledContexts)

        <span style="color:#999;font-style:italic">// The rest is the same as a usual streaming recognize request</span>
        <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">fileUrl</span> = URL(fileURLWithPath: <span style="color:#6ab825;font-weight:bold">self</span>.fileName)
        <span style="color:#6ab825;font-weight:bold">guard</span> <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">audioData</span> = <span style="color:#6ab825;font-weight:bold">try</span>? Data(contentsOf: fileUrl) <span style="color:#6ab825;font-weight:bold">else</span> { <span style="color:#6ab825;font-weight:bold">return</span> }
        
        dispatchGroup.enter()
        
        <span style="color:#6ab825;font-weight:bold">self</span>.client.streamingRecognize(audioData: audioData, chunkSize: <span style="color:#6ab825;font-weight:bold">self</span>.chunkSize, config: <span style="color:#6ab825;font-weight:bold">self</span>.config, success: { (response) <span style="color:#6ab825;font-weight:bold">in</span>
            <span style="color:#6ab825;font-weight:bold">for</span> result <span style="color:#6ab825;font-weight:bold">in</span> response.results {
                <span style="color:#6ab825;font-weight:bold">if</span> !result.isPartial, <span style="color:#6ab825;font-weight:bold">let</span> <span style="color:#40ffff">alternative</span> = result.alternatives.first {
                    print(alternative.transcript)
                }
            }
            
            dispatchGroup.leave()
        }) { (error) <span style="color:#6ab825;font-weight:bold">in</span>
            print(error.localizedDescription)
            dispatchGroup.leave()
        }
    }
}
</code></pre></div>
</div>


</div></div>

    
    
          <footer class=" footline" >
	
</footer>
  </div>
</div>

<div id="navigation">
<a class="nav nav-prev" href="../../using-cubic-sdk/streaming/" title="Streaming Recognition"> <i class="fa fa-chevron-left"></i><label>Streaming Recognition</label></a>
    <a class="nav nav-next" href="../../using-cubic-sdk/client-configs/" title="Recognition Configurations" style="margin-right: 0px;"><label>Recognition Configurations</label><i class="fa fa-chevron-right"></i></a></div>

</section>
<div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
  <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
</div>    

<script src="../../js/clipboard.min.js"></script>
<script src="../../js/featherlight.min.js"></script>
<script src="../../js/html5shiv-printshiv.min.js"></script>

<script src="../../js/modernizr.custom.71422.js"></script>
<script src="../../js/docdock.js"></script>
<script src="../../theme-original/script.js"></script>


    

    
    

    
  </body>
</html>